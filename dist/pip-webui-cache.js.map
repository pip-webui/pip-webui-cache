{"version":3,"sources":["../node_modules/browser-pack/_prelude.js","../node_modules/dexie/dist/dexie.js","src/cache/cache-config.service.ts","src/cache/cache.interceptor.ts","src/cache/cache.models.ts","src/cache/cache.service.ts","src/cache/index.ts","src/index.ts"],"names":[],"mappings":"AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACl3IA;IACI,4BACW,UAAmB,EACnB,MAAoB,EACpB,MAAc;QAFd,eAAU,GAAV,UAAU,CAAS;QACnB,WAAM,GAAN,MAAM,CAAc;QACpB,WAAM,GAAN,MAAM,CAAQ;IACrB,CAAC;IACT,yBAAC;AAAD,CANA,AAMC,IAAA;AANY,gDAAkB;AAc/B;IAQI;QACI,UAAU,CAAC;QALf,eAAU,GAAY,KAAK,CAAC;QAC5B,WAAM,GAAiB,EAAE,CAAC;QAC1B,WAAM,GAAW,UAAU,CAAC;IAI5B,CAAC;IAEM,kCAAI,GAAX;QACI,UAAU,CAAC;QAEX,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,QAAQ,GAAG,IAAI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","file":"pip-webui-cache.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 2.0.4, Fri May 25 2018\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.Dexie = factory());\n}(this, (function () { 'use strict';\n\nvar keys = Object.keys;\nvar isArray = Array.isArray;\nvar _global = typeof self !== 'undefined' ? self :\n    typeof window !== 'undefined' ? window :\n        global;\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nvar getProto = Object.getPrototypeOf;\nvar _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    keys(extension).forEach(function (key) {\n        setProp(proto, key, extension[key]);\n    });\n}\nvar defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    var pd = getOwnPropertyDescriptor(obj, prop), proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nvar _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\n\n/** Generate an object (hash map) based on given array.\n * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to\n *        instert on the resulting object for each item in the array. If this function returns a falsy value, the\n *        current item wont affect the resulting object.\n */\nfunction arrayToObject(array, extractor) {\n    return array.reduce(function (result, item, i) {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction trycatcher(fn, reject) {\n    return function () {\n        try {\n            fn.apply(this, arguments);\n        }\n        catch (e) {\n            reject(e);\n        }\n    };\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    // http://www.w3.org/TR/IndexedDB/#steps-for-extracting-a-key-from-a-value-using-a-key-path\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath]; // This line is moved from last to first for optimization purpose.\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined)\n                    delete obj[currentKeyPath];\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj)\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined)\n                delete obj[keyPath];\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nvar concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\n//https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\nvar intrinsicTypes = \"Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; }).map(function (t) { return _global[t]; });\nfunction deepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    var rv;\n    if (isArray(any)) {\n        rv = [];\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(deepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        rv = any.constructor ? Object.create(any.constructor.prototype) : {};\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = deepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nfunction getObjectDiff(a, b, rv, prfx) {\n    // Compares objects a and b and produces a diff object.\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach(function (prop) {\n        if (!hasOwn(b, prop))\n            rv[prfx + prop] = undefined; // Property removed\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' &&\n                ap && bp &&\n                // Now compare constructors are same (not equal because wont work in Safari)\n                ('' + ap.constructor) === ('' + bp.constructor))\n                // Same type of object but its properties may have changed\n                getObjectDiff(ap, bp, rv, prfx + prop + \".\");\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop]; // Primitive value changed\n        }\n    });\n    keys(b).forEach(function (prop) {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop]; // Property added\n        }\n    });\n    return rv;\n}\n// If first argument is iterable or array-like, return it as an array\nvar iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;\nvar getIteratorOf = iteratorSymbol ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nvar NO_CHAR_ARRAY = {};\n// Takes one or several arguments and returns an array based on the following criteras:\n// * If several arguments provided, return arguments converted to an array in a way that\n//   still allows javascript engine to optimize the code.\n// * If single argument is an array, return a clone of it.\n// * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special\n//   case to the two bullets below.\n// * If single argument is an iterable, convert it to an array and return the resulting array.\n// * If single argument is array-like (has length of type number), convert it to an array.\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\n\n// By default, debug will be true only if platform is a web platform and its page is served from localhost.\n// When debug = true, error's stacks will contain asyncronic long stacks.\nvar debug = typeof location !== 'undefined' &&\n    // By default, use debug mode if served from localhost.\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = function () { return true; };\nvar NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    \"use strict\";\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            // Doing something naughty in strict mode here to trigger a specific error\n            // that can be explicitely ignored in debugger's exception settings.\n            // If we'd just throw new Error() here, IE's debugger's exception settings\n            // will just consider it as \"exception thrown by javascript code\" which is\n            // something you wouldn't want it to ignore.\n            getErrorWithStack.arguments;\n            throw new Error(); // Fallback if above line don't throw.\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(function (frame) { return \"\\n\" + frame; })\n        .join('');\n}\nfunction deprecated(what, fn) {\n    return function () {\n        console.warn(what + \" is deprecated. See https://github.com/dfahlander/Dexie.js/wiki/Deprecations. \" + prettyStack(getErrorWithStack(), 1));\n        return fn.apply(this, arguments);\n    };\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\"\n};\n//\n// DexieError - base class of all out exceptions.\n//\nfunction DexieError(name, msg) {\n    // Reason we don't use ES6 classes is because:\n    // 1. It bloats transpiled code and increases size of minified code.\n    // 2. It doesn't give us much in this case.\n    // 3. It would require sub classes to call super(), which\n    //    is not needed when deriving from Error.\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + failures\n        .map(function (f) { return f.toString(); })\n        .filter(function (v, i, s) { return s.indexOf(v) === i; }) // Only unique error strings\n        .join('\\n');\n}\n//\n// ModifyError - thrown in Collection.modify()\n// Specific constructor because it contains members failures and failedKeys.\n//\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\n//\n//\n// Dynamically generate error names and exception classes based\n// on the names in errorList.\n//\n//\n// Map of {ErrorName -> ErrorName + \"Error\"}\nvar errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n// Need an alias for DexieError because we're gonna create subclasses with the same name.\nvar BaseException = DexieError;\n// Map of {ErrorName -> exception constructor}\nvar exceptions = errorList.reduce(function (obj, name) {\n    // Let the name be \"DexieError\" because this name may\n    // be shown in call stack and when debugging. DexieError is\n    // the most true name because it derives from DexieError,\n    // and we cannot change Function.name programatically without\n    // dynamically create a Function object, which would be considered\n    // 'eval-evil'.\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = msgOrInner;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = msgOrInner.name + \" \" + msgOrInner.message;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\n// Use ECMASCRIPT standard exceptions where applicable:\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        // Derive stack from inner exception if it has a stack\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce(function (obj, name) {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    // Enables chained events that takes ONE argument and returns it to the next function in chain.\n    // This pattern is used in the hook(\"reading\") event.\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    // Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.\n    // This pattern is used in the hook(\"creating\") event.\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\n        onerror = this.onerror; // In case event listener has set this.onerror\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\n        onerror = this.onerror; // In case event listener has set this.onerror\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res); // If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\n        onerror = this.onerror; // In case event listener has set this.onerror\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\n\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\n/*\n * Copyright (c) 2014-2017 David Fahlander\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/LICENSE-2.0\n */\n//\n// Promise and Zone (PSD) for Dexie library\n//\n// I started out writing this Promise class by copying promise-light (https://github.com/taylorhakes/promise-light) by\n// https://github.com/taylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.\n//\n// In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another\n// tick. In Dexie v1.4.0, I've rewritten the Promise class entirely. Just some fragments of promise-light is left. I use\n// another strategy now that simplifies everything a lot: to always execute callbacks in a new micro-task, but have an own micro-task\n// engine that is indexedDB compliant across all browsers.\n// Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.\n// Also with inspiration from bluebird, asyncronic stacks in debug mode.\n//\n// Specific non-standard features of this Promise class:\n// * Custom zone support (a.k.a. PSD) with ability to keep zones also when using native promises as well as\n//   native async / await.\n// * Promise.follow() method built upon the custom zone engine, that allows user to track all promises created from current stack frame\n//   and below + all promises that those promises creates or awaits.\n// * Detect any unhandled promise in a PSD-scope (PSD.onunhandled). \n//\n// David Fahlander, https://github.com/dfahlander\n//\n// Just a pointer that only this module knows about.\n// Used in Promise constructor to emulate a private constructor.\nvar INTERNAL = {};\n// Async stacks (long stacks) must not grow infinitely.\nvar LONG_STACKS_CLIP_LIMIT = 100;\nvar MAX_LONG_STACKS = 20;\nvar ZONE_ECHO_LIMIT = 7;\nvar nativePromiseInstanceAndProto = (function () {\n    try {\n        // Be able to patch native async functions\n        return new Function(\"let F=async ()=>{},p=F();return [p,Object.getPrototypeOf(p),Promise.resolve(),F.constructor];\")();\n    }\n    catch (e) {\n        var P = _global.Promise;\n        return P ?\n            [P.resolve(), P.prototype, P.resolve()] :\n            [];\n    }\n})();\nvar resolvedNativePromise = nativePromiseInstanceAndProto[0];\nvar nativePromiseProto = nativePromiseInstanceAndProto[1];\nvar resolvedGlobalPromise = nativePromiseInstanceAndProto[2];\nvar nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nvar NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nvar AsyncFunction = nativePromiseInstanceAndProto[3];\nvar patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\n/* The default function used only for the very first promise in a promise chain.\n   As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks\n   emulated in this module. For indexedDB compatibility, this means that every method needs to\n   execute at least one promise before doing an indexedDB operation. Dexie will always call\n   db.ready().then() for every operation to make sure the indexedDB event is started in an\n   indexedDB-compatible emulated micro task loop.\n*/\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    function () { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            // setImmediate supported. Those modern platforms also supports Function.bind().\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                // MutationObserver supported\n                function () {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(function () {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                // No support for setImmediate or MutationObserver. No worry, setTimeout is only called\n                // once time. Every tick that follows will be our emulated micro tick.\n                // Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug \n                function () { setTimeout(physicalTick, 0); };\n// Configurable through Promise.scheduler.\n// Don't export because it would be unsafe to let unknown\n// code call it unless they do try..catch within their callback.\n// This function can be retrieved through getter of Promise.scheduler though,\n// but users must not do Promise.scheduler = myFuncThatThrowsException\nvar asap$1 = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true;\nvar needsNewPhysicalTick = true;\nvar unhandledErrors = [];\nvar rejectingErrors = [];\nvar currentFulfiller = null;\nvar rejectionMapper = mirror; // Remove in next major when removing error mapping of DOMErrors and DOMExceptions\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(function (uh) {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = []; // Callbacks to call in this or next physical tick.\nvar numScheduledCalls = 0; // Number of listener-calls left to do in this physical tick.\nvar tickFinalizers = []; // Finalizers to call when there are no more async calls scheduled within current physical tick.\nfunction Promise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop; // Deprecate in next major. Not needed. Better to use global error handler.\n    // A library may set `promise._lib = true;` after promise is created to make resolve() or reject()\n    // execute the microtask engine implicitely within the call to resolve() or reject().\n    // To remain A+ compliant, a library must only set `_lib=true` if it can guarantee that the stack\n    // only contains library code when calling resolve() or reject().\n    // RULE OF THUMB: ONLY set _lib = true for promises explicitely resolving/rejecting directly from\n    // global scope (event handler, timer etc)!\n    this._lib = false;\n    // Current async scope\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0; // Number of previous promises (for long stacks)\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        // Private constructor (INTERNAL, state, value).\n        // Used internally by Promise.resolve() and Promise.reject().\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value); // Map error, set stack and addPossiblyUnhandledError().\n        return;\n    }\n    this._state = null; // null (=pending), false (=rejected) or true (=resolved)\n    this._value = null; // error or result\n    ++psd.ref; // Refcounting current scope\n    executePromiseTask(this, fn);\n}\n// Prepare a property descriptor to put onto Promise.prototype.then\nvar thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var _this = this;\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            if (possibleAwait)\n                decrementExpectedAwaits();\n            var rv = new Promise(function (resolve, reject) {\n                propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL; // For idempotense, see setter below.\n        return then;\n    },\n    // Be idempotent and allow another framework (such as zone.js or another instance of a Dexie.Promise module) to replace Promise.prototype.then\n    // and when that framework wants to restore the original property, we must identify that and restore the original property descriptor.\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp : // Restore to original property descriptor.\n            {\n                get: function () {\n                    return value; // Getter returning provided value (behaves like value is just changed)\n                },\n                set: thenProp.set // Keep a setter that is prepared to restore original.\n            });\n    }\n};\nprops(Promise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        // A little tinier version of then() that don't have to create a resulting promise.\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        // First argument is the Error type to catch\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, function (err) {\n            // Catching errors by its constructor type (similar to java / c++ / c#)\n            // Sample: promise.catch(TypeError, function (e) { ... });\n            return err instanceof type ? handler(err) : PromiseReject(err);\n        })\n            : this.then(null, function (err) {\n                // Catching errors by the error.name property. Makes sense for indexedDB where error type\n                // is always DOMError but where e.name tells the actual error type.\n                // Sample: promise.catch('ConstraintError', function (e) { ... });\n                return err && err.name === type ? handler(err) : PromiseReject(err);\n            });\n    },\n    finally: function (onFinally) {\n        return this.then(function (value) {\n            onFinally();\n            return value;\n        }, function (err) {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack; // Stack may be updated on reject.\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        var _this = this;\n        return ms < Infinity ?\n            new Promise(function (resolve, reject) {\n                var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n                _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(Promise.prototype, Symbol.toStringTag, 'Promise');\n// Now that Promise.prototype is defined, we have all it takes to set globalPSD.env.\n// Environment globals snapshotted on leaving global zone\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\n// Promise Static Properties\nprops(Promise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments) // Supports iterables, implicit arguments and array-like.\n            .map(onPossibleParallellAsync); // Handle parallell async/awaits \n        return new Promise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach(function (a, i) { return Promise.resolve(a).then(function (x) {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject); });\n        });\n    },\n    resolve: function (value) {\n        if (value instanceof Promise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new Promise(function (resolve, reject) {\n                value.then(resolve, reject);\n            });\n        var rv = new Promise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new Promise(function (resolve, reject) {\n            values.map(function (value) { return Promise.resolve(value).then(resolve, reject); });\n        });\n    },\n    PSD: {\n        get: function () { return PSD; },\n        set: function (value) { return PSD = value; }\n    },\n    //totalEchoes: {get: ()=>totalEchoes},\n    //task: {get: ()=>task},\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: function () { return asap$1; },\n        set: function (value) { asap$1 = value; }\n    },\n    rejectionMapper: {\n        get: function () { return rejectionMapper; },\n        set: function (value) { rejectionMapper = value; } // Map reject failures\n    },\n    follow: function (fn, zoneProps) {\n        return new Promise(function (resolve, reject) {\n            return newScope(function (resolve, reject) {\n                var psd = PSD;\n                psd.unhandleds = []; // For unhandled standard- or 3rd party Promises. Checked at psd.finalize()\n                psd.onunhandled = reject; // Triggered directly on unhandled promises of this library.\n                psd.finalize = callBoth(function () {\n                    var _this = this;\n                    // Unhandled standard or 3rd part promises are put in PSD.unhandleds and\n                    // examined upon scope completion while unhandled rejections in this Promise\n                    // will trigger directly through psd.onunhandled\n                    run_at_end_of_this_or_next_physical_tick(function () {\n                        _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\n/**\n* Take a potentially misbehaving resolver function and make sure\n* onFulfilled and onRejected are only called once.\n*\n* Makes no guarantees about asynchrony.\n*/\nfunction executePromiseTask(promise, fn) {\n    // Promise Resolution Procedure:\n    // https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    try {\n        fn(function (value) {\n            if (promise._state !== null)\n                return; // Already settled\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, function (resolve, reject) {\n                    value instanceof Promise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise)); // If Function.bind is not supported. Exception is handled in catch below\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: function () {\n                return stack_being_generated ?\n                    origProp && (origProp.get ?\n                        origProp.get.apply(reason) :\n                        origProp.value) :\n                    promise.stack;\n            }\n        });\n    });\n    // Add the failure to a list of possibly uncaught errors\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    //debug && linkToPreviousPromise(promise);\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize(); // if psd.ref reaches zero, call psd.finalize();\n    if (numScheduledCalls === 0) {\n        // If numScheduledCalls is 0, it means that our stack is not in a callback of a scheduled call,\n        // and that no deferreds where listening to this rejection or success.\n        // Since there is a risk that our stack can contain application code that may\n        // do stuff after this code is finished that may generate new calls, we cannot\n        // call finalizers here.\n        ++numScheduledCalls;\n        asap$1(function () {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick(); // Will detect unhandled errors\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        // This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap$1(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        // Set static variable currentFulfiller to the promise that is being fullfilled,\n        // so that we connect the chain of promises (for long stacks support)\n        currentFulfiller = promise;\n        // Call callback and resolve our listener with it's return value.\n        var ret, value = promise._value;\n        if (promise._state) {\n            // cb is onResolved\n            ret = cb(value);\n        }\n        else {\n            // cb is onRejected\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise); // Callback didnt do Promise.reject(err) nor reject(err) onto another promise.\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        // Exception thrown in callback. Reject our listener.\n        listener.reject(e);\n    }\n    finally {\n        // Restore env and currentFulfiller.\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure; // If error is undefined or null, show that.\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    // Support long stacks by linking to previous completed promise.\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\n/* The callback to schedule with setImmediate() or setTimeout().\n   It runs a virtual microtick and executes any callback registered in microtickQueue.\n */\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\n/* Executes micro-ticks without doing try..catch.\n   This can be possible because we only use this internally and\n   the registered functions are exception-safe (they do try..catch\n   internally before calling any external method). If registering\n   functions in the microtickQueue that are not exception-safe, this\n   would destroy the framework and make it instable. So we don't export\n   our asap method.\n*/\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(function (p) {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0); // Clone first because finalizer may remove itself from list.\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap$1(function () {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    // Only add to unhandledErrors if not already there. The first one to add to this list\n    // will be upon the first rejection so that the root cause (first promise in the\n    // rejection chain) is the one listed.\n    if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    // Called when a reject handled is actually being called.\n    // Search in unhandledErrors for any promise whos _value is this promise_value (list\n    // contains only rejected promises, and only one item per error)\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            // Found a promise that failed with this same error object pointer,\n            // Remove that since there is a listener that actually takes care of it.\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new Promise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\n//\n// variables used for native await support\n//\nvar task = { awaits: 0, echoes: 0, id: 0 }; // The ongoing macro-task when using zone-echoing.\nvar taskCounter = 0; // ID counter for macro tasks.\nvar zoneStack = []; // Stack of left zones to restore asynchronically.\nvar zoneEchoes = 0; // zoneEchoes is a must in order to persist zones between native await expressions.\nvar totalEchoes = 0; // ID counter for micro-tasks. Used to detect possible native await in our Promise.prototype.then.\nvar zone_id_counter = 0;\nfunction newScope(fn, props$$1, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    // Prepare for promise patching (done in usePSD):\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: Promise,\n        PromiseProp: { value: Promise, configurable: true, writable: true },\n        all: Promise.all,\n        race: Promise.race,\n        resolve: Promise.resolve,\n        reject: Promise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd) // global then\n    } : {};\n    if (props$$1)\n        extend(psd, props$$1);\n    // unhandleds and onunhandled should not be specifically set here.\n    // Leave them on parent prototype.\n    // unhandleds.push(err) will push to parent's prototype\n    // onunhandled() will call parents onunhandled (with this scope's this-pointer though!)\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\n// Function to call if scopeFunc returns NativePromise\n// Also for each NativePromise in the arguments to Promise.all()\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\n// Function to call when 'then' calls back on a native promise where onAwaitExpected() had been called.\n// Also call this when a native await calls then method on a promise. In that case, don't supply\n// sourceTaskId because we already know it refers to current task.\nfunction decrementExpectedAwaits(sourceTaskId) {\n    if (!task.awaits || (sourceTaskId && sourceTaskId !== task.id))\n        return;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT; // Will reset echoes to 0 if awaits is 0.\n}\n// Call from Promise.all() and Promise.race()\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(function (x) {\n            decrementExpectedAwaits();\n            return x;\n        }, function (e) {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0; // Cancel zone echoing.\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        // Enter or leave zone asynchronically as well, so that tasks initiated during current tick\n        // will be surrounded by the zone when they are invoked.\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone; // The actual zone switch occurs at this line.\n    // Snapshot on every leave from global zone.\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        // Let's patch the global and native Promises (may be same or may be different)\n        var GlobalPromise = globalPSD.env.Promise;\n        // Swich environments (may be PSD-zone or the global zone. Both apply.)\n        var targetEnv = targetZone.env;\n        // Change Promise.prototype.then for native and global Promise (they MAY differ on polyfilled environments, but both can be accessed)\n        // Must be done on each zone change because the patched method contains targetZone in its closure.\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            // Leaving or entering global zone. It's time to patch / restore global Promise.\n            // Set this Promise to window.Promise so that transiled async functions will work on Firefox, Safari and IE, as well as with Zonejs and angular.\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            // Support Promise.all() etc to work indexedDB-safe also when people are including es6-promise as a module (they might\n            // not be accessing global.Promise but a local reference to it)\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    //\n    // Precondition: nativePromiseThen !== undefined\n    //\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone, false), nativeAwaitCompatibleWrap(onRejected, zone, false));\n    };\n}\nvar UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    // No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (!event.defaultPrevented) {\n                console.warn(\"Unhandled rejection: \" + (err.stack || err));\n            }\n        }\n        catch (e) { }\n}\nvar rejection = Promise.reject;\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            // Subscribe. If additional arguments than just the subscriber was provided, forward them as well.\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            // Return interface allowing to fire or unsubscribe from event\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        // events(this, {reading: [functionChain, nop]});\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                // Rather than approaching event subscription using a functional approach, we here do it in a for-loop where subscriber is executed in its own stack\n                // enabling that any exception that occur wont disturb the initiator and also not nescessary be catched and forgotten.\n                var context = add(eventName, mirror, function fire() {\n                    // Optimazation-safe cloning of arguments into args.\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    // All each subscriber:\n                    context.subscribers.forEach(function (fn) {\n                        asap(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * Copyright (c) 2014-2017 David Fahlander\n *\n * Version 2.0.4, Fri May 25 2018\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/LICENSE-2.0\n *\n */\nvar DEXIE_VERSION = '2.0.4';\nvar maxString = String.fromCharCode(65535);\nvar maxKey = (function () { try {\n    IDBKeyRange.only([[]]);\n    return [[]];\n}\ncatch (e) {\n    return maxString;\n} })();\nvar minKey = -Infinity;\nvar INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nvar STRING_EXPECTED = \"String expected.\";\nvar connections = [];\nvar isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nvar hasIEDeleteObjectStoreBug = isIEOrEdge;\nvar hangsOnDeleteLargeKeyRange = isIEOrEdge;\nvar dexieStackFrameFilter = function (frame) { return !/(dexie\\.js|dexie\\.min\\.js)/.test(frame); };\nvar dbNamesDB; // Global database for backing Dexie.getDatabaseNames() on browser without indexedDB.webkitGetDatabaseNames() \n// Init debug\nsetDebug(debug, dexieStackFrameFilter);\nfunction Dexie(dbName, options) {\n    /// <param name=\"options\" type=\"Object\" optional=\"true\">Specify only if you wich to control which addons that should run on this instance</param>\n    var deps = Dexie.dependencies;\n    var opts = extend({\n        // Default Options\n        addons: Dexie.addons,\n        autoOpen: true,\n        indexedDB: deps.indexedDB,\n        IDBKeyRange: deps.IDBKeyRange // Backend IDBKeyRange api. Default to browser env.\n    }, options);\n    var addons = opts.addons, autoOpen = opts.autoOpen, indexedDB = opts.indexedDB, IDBKeyRange = opts.IDBKeyRange;\n    var globalSchema = this._dbSchema = {};\n    var versions = [];\n    var dbStoreNames = [];\n    var allTables = {};\n    ///<var type=\"IDBDatabase\" />\n    var idbdb = null; // Instance of IDBDatabase\n    var dbOpenError = null;\n    var isBeingOpened = false;\n    var onReadyBeingFired = null;\n    var openComplete = false;\n    var READONLY = \"readonly\", READWRITE = \"readwrite\";\n    var db = this;\n    var dbReadyResolve, dbReadyPromise = new Promise(function (resolve) {\n        dbReadyResolve = resolve;\n    }), cancelOpen, openCanceller = new Promise(function (_, reject) {\n        cancelOpen = reject;\n    });\n    var autoSchema = true;\n    var hasNativeGetDatabaseNames = !!getNativeGetDatabaseNamesFn(indexedDB), hasGetAll;\n    function init() {\n        // Default subscribers to \"versionchange\" and \"blocked\".\n        // Can be overridden by custom handlers. If custom handlers return false, these default\n        // behaviours will be prevented.\n        db.on(\"versionchange\", function (ev) {\n            // Default behavior for versionchange event is to close database connection.\n            // Caller can override this behavior by doing db.on(\"versionchange\", function(){ return false; });\n            // Let's not block the other window from making it's delete() or open() call.\n            // NOTE! This event is never fired in IE,Edge or Safari.\n            if (ev.newVersion > 0)\n                console.warn(\"Another connection wants to upgrade database '\" + db.name + \"'. Closing db now to resume the upgrade.\");\n            else\n                console.warn(\"Another connection wants to delete database '\" + db.name + \"'. Closing db now to resume the delete request.\");\n            db.close();\n            // In many web applications, it would be recommended to force window.reload()\n            // when this event occurs. To do that, subscribe to the versionchange event\n            // and call window.location.reload(true) if ev.newVersion > 0 (not a deletion)\n            // The reason for this is that your current web app obviously has old schema code that needs\n            // to be updated. Another window got a newer version of the app and needs to upgrade DB but\n            // your window is blocking it unless we close it here.\n        });\n        db.on(\"blocked\", function (ev) {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(\"Dexie.delete('\" + db.name + \"') was blocked\");\n            else\n                console.warn(\"Upgrade '\" + db.name + \"' blocked by other connection holding version \" + ev.oldVersion / 10);\n        });\n    }\n    //\n    //\n    //\n    // ------------------------- Versioning Framework---------------------------\n    //\n    //\n    //\n    this.version = function (versionNumber) {\n        /// <param name=\"versionNumber\" type=\"Number\"></param>\n        /// <returns type=\"Version\"></returns>\n        if (idbdb || isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        // Disable autoschema mode, as at least one version is specified.\n        autoSchema = false;\n        return versionInstance;\n    };\n    function Version(versionNumber) {\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n        this.stores({}); // Derive earlier schemas by default.\n    }\n    extend(Version.prototype, {\n        stores: function (stores) {\n            /// <summary>\n            ///   Defines the schema for a particular version\n            /// </summary>\n            /// <param name=\"stores\" type=\"Object\">\n            /// Example: <br/>\n            ///   {users: \"id++,first,last,&amp;username,*email\", <br/>\n            ///   passwords: \"id++,&amp;username\"}<br/>\n            /// <br/>\n            /// Syntax: {Table: \"[primaryKey][++],[&amp;][*]index1,[&amp;][*]index2,...\"}<br/><br/>\n            /// Special characters:<br/>\n            ///  \"&amp;\"  means unique key, <br/>\n            ///  \"*\"  means value is multiEntry, <br/>\n            ///  \"++\" means auto-increment and only applicable for primary key <br/>\n            /// </param>\n            this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n            // Derive stores from earlier versions if they are not explicitely specified as null or a new syntax.\n            var storesSpec = {};\n            versions.forEach(function (version) {\n                extend(storesSpec, version._cfg.storesSource);\n            });\n            var dbschema = (this._cfg.dbschema = {});\n            this._parseStoresSpec(storesSpec, dbschema);\n            // Update the latest schema to this version\n            // Update API\n            globalSchema = db._dbSchema = dbschema;\n            removeTablesApi([allTables, db, Transaction.prototype]); // Keep Transaction.prototype even though it should be depr.\n            setApiOnPlace([allTables, db, Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n            dbStoreNames = keys(dbschema);\n            return this;\n        },\n        upgrade: function (upgradeFunction) {\n            this._cfg.contentUpgrade = upgradeFunction;\n            return this;\n        },\n        _parseStoresSpec: function (stores, outSchema) {\n            keys(stores).forEach(function (tableName) {\n                if (stores[tableName] !== null) {\n                    var instanceTemplate = {};\n                    var indexes = parseIndexSyntax(stores[tableName]);\n                    var primKey = indexes.shift();\n                    if (primKey.multi)\n                        throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                    if (primKey.keyPath)\n                        setByKeyPath(instanceTemplate, primKey.keyPath, primKey.auto ? 0 : primKey.keyPath);\n                    indexes.forEach(function (idx) {\n                        if (idx.auto)\n                            throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                        if (!idx.keyPath)\n                            throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                        setByKeyPath(instanceTemplate, idx.keyPath, idx.compound ? idx.keyPath.map(function () { return \"\"; }) : \"\");\n                    });\n                    outSchema[tableName] = new TableSchema(tableName, primKey, indexes, instanceTemplate);\n                }\n            });\n        }\n    });\n    function runUpgraders(oldVersion, idbtrans, reject) {\n        var trans = db._createTransaction(READWRITE, dbStoreNames, globalSchema);\n        trans.create(idbtrans);\n        trans._completion.catch(reject);\n        var rejectTransaction = trans._reject.bind(trans);\n        newScope(function () {\n            PSD.trans = trans;\n            if (oldVersion === 0) {\n                // Create tables:\n                keys(globalSchema).forEach(function (tableName) {\n                    createTable(idbtrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n                });\n                Promise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n            }\n            else\n                updateTablesAndIndexes(oldVersion, trans, idbtrans).catch(rejectTransaction);\n        });\n    }\n    function updateTablesAndIndexes(oldVersion, trans, idbtrans) {\n        // Upgrade version to version, step-by-step from oldest to newest version.\n        // Each transaction object will contain the table set that was current in that version (but also not-yet-deleted tables from its previous version)\n        var queue = [];\n        var oldVersionStruct = versions.filter(function (version) { return version._cfg.version === oldVersion; })[0];\n        if (!oldVersionStruct)\n            throw new exceptions.Upgrade(\"Dexie specification of currently installed DB version is missing\");\n        globalSchema = db._dbSchema = oldVersionStruct._cfg.dbschema;\n        var anyContentUpgraderHasRun = false;\n        var versToRun = versions.filter(function (v) { return v._cfg.version > oldVersion; });\n        versToRun.forEach(function (version) {\n            /// <param name=\"version\" type=\"Version\"></param>\n            queue.push(function () {\n                var oldSchema = globalSchema;\n                var newSchema = version._cfg.dbschema;\n                adjustToExistingIndexNames(oldSchema, idbtrans);\n                adjustToExistingIndexNames(newSchema, idbtrans);\n                globalSchema = db._dbSchema = newSchema;\n                var diff = getSchemaDiff(oldSchema, newSchema);\n                // Add tables           \n                diff.add.forEach(function (tuple) {\n                    createTable(idbtrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n                });\n                // Change tables\n                diff.change.forEach(function (change) {\n                    if (change.recreate) {\n                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                    }\n                    else {\n                        var store = idbtrans.objectStore(change.name);\n                        // Add indexes\n                        change.add.forEach(function (idx) {\n                            addIndex(store, idx);\n                        });\n                        // Update indexes\n                        change.change.forEach(function (idx) {\n                            store.deleteIndex(idx.name);\n                            addIndex(store, idx);\n                        });\n                        // Delete indexes\n                        change.del.forEach(function (idxName) {\n                            store.deleteIndex(idxName);\n                        });\n                    }\n                });\n                if (version._cfg.contentUpgrade) {\n                    anyContentUpgraderHasRun = true;\n                    return Promise.follow(function () {\n                        version._cfg.contentUpgrade(trans);\n                    });\n                }\n            });\n            queue.push(function (idbtrans) {\n                if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                    var newSchema = version._cfg.dbschema;\n                    // Delete old tables\n                    deleteRemovedTables(newSchema, idbtrans);\n                }\n            });\n        });\n        // Now, create a queue execution engine\n        function runQueue() {\n            return queue.length ? Promise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n                Promise.resolve();\n        }\n        return runQueue().then(function () {\n            createMissingTables(globalSchema, idbtrans); // At last, make sure to create any missing tables. (Needed by addons that add stores to DB without specifying version)\n        });\n    }\n    function getSchemaDiff(oldSchema, newSchema) {\n        var diff = {\n            del: [],\n            add: [],\n            change: [] // Array of {name: tableName, recreate: newDefinition, del: delIndexNames, add: newIndexDefs, change: changedIndexDefs}\n        };\n        for (var table in oldSchema) {\n            if (!newSchema[table])\n                diff.del.push(table);\n        }\n        for (table in newSchema) {\n            var oldDef = oldSchema[table], newDef = newSchema[table];\n            if (!oldDef) {\n                diff.add.push([table, newDef]);\n            }\n            else {\n                var change = {\n                    name: table,\n                    def: newDef,\n                    recreate: false,\n                    del: [],\n                    add: [],\n                    change: []\n                };\n                if (oldDef.primKey.src !== newDef.primKey.src) {\n                    // Primary key has changed. Remove and re-add table.\n                    change.recreate = true;\n                    diff.change.push(change);\n                }\n                else {\n                    // Same primary key. Just find out what differs:\n                    var oldIndexes = oldDef.idxByName;\n                    var newIndexes = newDef.idxByName;\n                    for (var idxName in oldIndexes) {\n                        if (!newIndexes[idxName])\n                            change.del.push(idxName);\n                    }\n                    for (idxName in newIndexes) {\n                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                        if (!oldIdx)\n                            change.add.push(newIdx);\n                        else if (oldIdx.src !== newIdx.src)\n                            change.change.push(newIdx);\n                    }\n                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                        diff.change.push(change);\n                    }\n                }\n            }\n        }\n        return diff;\n    }\n    function createTable(idbtrans, tableName, primKey, indexes) {\n        /// <param name=\"idbtrans\" type=\"IDBTransaction\"></param>\n        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });\n        indexes.forEach(function (idx) { addIndex(store, idx); });\n        return store;\n    }\n    function createMissingTables(newSchema, idbtrans) {\n        keys(newSchema).forEach(function (tableName) {\n            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n            }\n        });\n    }\n    function deleteRemovedTables(newSchema, idbtrans) {\n        for (var i = 0; i < idbtrans.db.objectStoreNames.length; ++i) {\n            var storeName = idbtrans.db.objectStoreNames[i];\n            if (newSchema[storeName] == null) {\n                idbtrans.db.deleteObjectStore(storeName);\n            }\n        }\n    }\n    function addIndex(store, idx) {\n        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n    }\n    //\n    //\n    //      Dexie Protected API\n    //\n    //\n    this._allTables = allTables;\n    this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {\n        return new Transaction(mode, storeNames, dbschema, parentTransaction);\n    };\n    /* Generate a temporary transaction when db operations are done outside a transaction scope.\n    */\n    function tempTransaction(mode, storeNames, fn) {\n        if (!openComplete && (!PSD.letThrough)) {\n            if (!isBeingOpened) {\n                if (!autoOpen)\n                    return rejection(new exceptions.DatabaseClosed());\n                db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.\n            }\n            return dbReadyPromise.then(function () { return tempTransaction(mode, storeNames, fn); });\n        }\n        else {\n            var trans = db._createTransaction(mode, storeNames, globalSchema);\n            try {\n                trans.create();\n            }\n            catch (ex) {\n                return rejection(ex);\n            }\n            return trans._promise(mode, function (resolve, reject) {\n                return newScope(function () {\n                    PSD.trans = trans;\n                    return fn(resolve, reject, trans);\n                });\n            }).then(function (result) {\n                // Instead of resolving value directly, wait with resolving it until transaction has completed.\n                // Otherwise the data would not be in the DB if requesting it in the then() operation.\n                // Specifically, to ensure that the following expression will work:\n                //\n                //   db.friends.put({name: \"Arne\"}).then(function () {\n                //       db.friends.where(\"name\").equals(\"Arne\").count(function(count) {\n                //           assert (count === 1);\n                //       });\n                //   });\n                //\n                return trans._completion.then(function () { return result; });\n            }); /*.catch(err => { // Don't do this as of now. If would affect bulk- and modify methods in a way that could be more intuitive. But wait! Maybe change in next major.\n                trans._reject(err);\n                return rejection(err);\n            });*/\n        }\n    }\n    this._whenReady = function (fn) {\n        return openComplete || PSD.letThrough ? fn() : new Promise(function (resolve, reject) {\n            if (!isBeingOpened) {\n                if (!autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.\n            }\n            dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    };\n    //\n    //\n    //\n    //\n    //      Dexie API\n    //\n    //\n    //\n    this.verno = 0;\n    this.open = function () {\n        if (isBeingOpened || idbdb)\n            return dbReadyPromise.then(function () { return dbOpenError ? rejection(dbOpenError) : db; });\n        debug && (openCanceller._stackHolder = getErrorWithStack()); // Let stacks point to when open() was called rather than where new Dexie() was called.\n        isBeingOpened = true;\n        dbOpenError = null;\n        openComplete = false;\n        // Function pointers to call when the core opening process completes.\n        var resolveDbReady = dbReadyResolve, \n        // upgradeTransaction to abort on failure.\n        upgradeTransaction = null;\n        return Promise.race([openCanceller, new Promise(function (resolve, reject) {\n                // Multiply db.verno with 10 will be needed to workaround upgrading bug in IE:\n                // IE fails when deleting objectStore after reading from it.\n                // A future version of Dexie.js will stopover an intermediate version to workaround this.\n                // At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number.\n                // If no API, throw!\n                if (!indexedDB)\n                    throw new exceptions.MissingAPI(\"indexedDB API not found. If using IE10+, make sure to run your code on a server URL \" +\n                        \"(not locally). If using old Safari versions, make sure to include indexedDB polyfill.\");\n                var req = autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));\n                if (!req)\n                    throw new exceptions.MissingAPI(\"IndexedDB API not available\"); // May happen in Safari private mode, see https://github.com/dfahlander/Dexie.js/issues/134\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = wrap(fireOnBlocked);\n                req.onupgradeneeded = wrap(function (e) {\n                    upgradeTransaction = req.transaction;\n                    if (autoSchema && !db._allowEmptyDB) {\n                        // Caller did not specify a version or schema. Doing that is only acceptable for opening alread existing databases.\n                        // If onupgradeneeded is called it means database did not exist. Reject the open() promise and make sure that we\n                        // do not create a new database by accident here.\n                        req.onerror = preventDefault; // Prohibit onabort error from firing before we're done!\n                        upgradeTransaction.abort(); // Abort transaction (would hope that this would make DB disappear but it doesnt.)\n                        // Close database and delete it.\n                        req.result.close();\n                        var delreq = indexedDB.deleteDatabase(dbName); // The upgrade transaction is atomic, and javascript is single threaded - meaning that there is no risk that we delete someone elses database here!\n                        delreq.onsuccess = delreq.onerror = wrap(function () {\n                            reject(new exceptions.NoSuchDatabase(\"Database \" + dbName + \" doesnt exist\"));\n                        });\n                    }\n                    else {\n                        upgradeTransaction.onerror = eventRejectHandler(reject);\n                        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion; // Safari 8 fix.\n                        runUpgraders(oldVer / 10, upgradeTransaction, reject, req);\n                    }\n                }, reject);\n                req.onsuccess = wrap(function () {\n                    // Core opening procedure complete. Now let's just record some stuff.\n                    upgradeTransaction = null;\n                    idbdb = req.result;\n                    connections.push(db); // Used for emulating versionchange event on IE/Edge/Safari.\n                    if (autoSchema)\n                        readGlobalSchema();\n                    else if (idbdb.objectStoreNames.length > 0) {\n                        try {\n                            adjustToExistingIndexNames(globalSchema, idbdb.transaction(safariMultiStoreFix(idbdb.objectStoreNames), READONLY));\n                        }\n                        catch (e) {\n                            // Safari may bail out if > 1 store names. However, this shouldnt be a showstopper. Issue #120.\n                        }\n                    }\n                    idbdb.onversionchange = wrap(function (ev) {\n                        db._vcFired = true; // detect implementations that not support versionchange (IE/Edge/Safari)\n                        db.on(\"versionchange\").fire(ev);\n                    });\n                    if (!hasNativeGetDatabaseNames && dbName !== '__dbnames') {\n                        dbNamesDB.dbnames.put({ name: dbName }).catch(nop);\n                    }\n                    resolve();\n                }, reject);\n            })]).then(function () {\n            // Before finally resolving the dbReadyPromise and this promise,\n            // call and await all on('ready') subscribers:\n            // Dexie.vip() makes subscribers able to use the database while being opened.\n            // This is a must since these subscribers take part of the opening procedure.\n            onReadyBeingFired = [];\n            return Promise.resolve(Dexie.vip(db.on.ready.fire)).then(function fireRemainders() {\n                if (onReadyBeingFired.length > 0) {\n                    // In case additional subscribers to db.on('ready') were added during the time db.on.ready.fire was executed.\n                    var remainders = onReadyBeingFired.reduce(promisableChain, nop);\n                    onReadyBeingFired = [];\n                    return Promise.resolve(Dexie.vip(remainders)).then(fireRemainders);\n                }\n            });\n        }).finally(function () {\n            onReadyBeingFired = null;\n        }).then(function () {\n            // Resolve the db.open() with the db instance.\n            isBeingOpened = false;\n            return db;\n        }).catch(function (err) {\n            try {\n                // Did we fail within onupgradeneeded? Make sure to abort the upgrade transaction so it doesnt commit.\n                upgradeTransaction && upgradeTransaction.abort();\n            }\n            catch (e) { }\n            isBeingOpened = false; // Set before calling db.close() so that it doesnt reject openCanceller again (leads to unhandled rejection event).\n            db.close(); // Closes and resets idbdb, removes connections, resets dbReadyPromise and openCanceller so that a later db.open() is fresh.\n            // A call to db.close() may have made on-ready subscribers fail. Use dbOpenError if set, since err could be a follow-up error on that.\n            dbOpenError = err; // Record the error. It will be used to reject further promises of db operations.\n            return rejection(dbOpenError);\n        }).finally(function () {\n            openComplete = true;\n            resolveDbReady(); // dbReadyPromise is resolved no matter if open() rejects or resolved. It's just to wake up waiters.\n        });\n    };\n    this.close = function () {\n        var idx = connections.indexOf(db);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (idbdb) {\n            try {\n                idbdb.close();\n            }\n            catch (e) { }\n            idbdb = null;\n        }\n        autoOpen = false;\n        dbOpenError = new exceptions.DatabaseClosed();\n        if (isBeingOpened)\n            cancelOpen(dbOpenError);\n        // Reset dbReadyPromise promise:\n        dbReadyPromise = new Promise(function (resolve) {\n            dbReadyResolve = resolve;\n        });\n        openCanceller = new Promise(function (_, reject) {\n            cancelOpen = reject;\n        });\n    };\n    this.delete = function () {\n        var hasArguments = arguments.length > 0;\n        return new Promise(function (resolve, reject) {\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (isBeingOpened) {\n                dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n            function doDelete() {\n                db.close();\n                var req = indexedDB.deleteDatabase(dbName);\n                req.onsuccess = wrap(function () {\n                    if (!hasNativeGetDatabaseNames) {\n                        dbNamesDB.dbnames.delete(dbName).catch(nop);\n                    }\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = fireOnBlocked;\n            }\n        });\n    };\n    this.backendDB = function () {\n        return idbdb;\n    };\n    this.isOpen = function () {\n        return idbdb !== null;\n    };\n    this.hasBeenClosed = function () {\n        return dbOpenError && (dbOpenError instanceof exceptions.DatabaseClosed);\n    };\n    this.hasFailed = function () {\n        return dbOpenError !== null;\n    };\n    this.dynamicallyOpened = function () {\n        return autoSchema;\n    };\n    //\n    // Properties\n    //\n    this.name = dbName;\n    // db.tables - an array of all Table instances.\n    props(this, {\n        tables: {\n            get: function () {\n                /// <returns type=\"Array\" elementType=\"Table\" />\n                return keys(allTables).map(function (name) { return allTables[name]; });\n            }\n        }\n    });\n    //\n    // Events\n    //\n    this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", { ready: [promisableChain, nop] });\n    this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n        return function (subscriber, bSticky) {\n            Dexie.vip(function () {\n                if (openComplete) {\n                    // Database already open. Call subscriber asap.\n                    if (!dbOpenError)\n                        Promise.resolve().then(subscriber);\n                    // bSticky: Also subscribe to future open sucesses (after close / reopen) \n                    if (bSticky)\n                        subscribe(subscriber);\n                }\n                else if (onReadyBeingFired) {\n                    // db.on('ready') subscribers are currently being executed and have not yet resolved or rejected\n                    onReadyBeingFired.push(subscriber);\n                    if (bSticky)\n                        subscribe(subscriber);\n                }\n                else {\n                    // Database not yet open. Subscribe to it.\n                    subscribe(subscriber);\n                    // If bSticky is falsy, make sure to unsubscribe subscriber when fired once.\n                    if (!bSticky)\n                        subscribe(function unsubscribe() {\n                            db.on.ready.unsubscribe(subscriber);\n                            db.on.ready.unsubscribe(unsubscribe);\n                        });\n                }\n            });\n        };\n    });\n    this.transaction = function () {\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"mode\" type=\"String\">\"r\" for readonly, or \"rw\" for readwrite</param>\n        /// <param name=\"tableInstances\">Table instance, Array of Table instances, String or String Array of object stores to include in the transaction</param>\n        /// <param name=\"scopeFunc\" type=\"Function\">Function to execute with transaction</param>\n        var args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    };\n    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n        // Let table arguments be all arguments between mode and last argument.\n        var i = arguments.length;\n        if (i < 2)\n            throw new exceptions.InvalidArgument(\"Too few arguments\");\n        // Prevent optimzation killer (https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments)\n        // and clone arguments except the first one into local var 'args'.\n        var args = new Array(i - 1);\n        while (--i)\n            args[i - 1] = arguments[i];\n        // Let scopeFunc be the last argument and pop it so that args now only contain the table arguments.\n        scopeFunc = args.pop();\n        var tables = flatten(args); // Support using array as middle argument, or a mix of arrays and non-arrays.\n        return [mode, tables, scopeFunc];\n    }\n    this._transaction = function (mode, tables, scopeFunc) {\n        var parentTransaction = PSD.trans;\n        // Check if parent transactions is bound to this db instance, and if caller wants to reuse it\n        if (!parentTransaction || parentTransaction.db !== db || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        var onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', ''); // Ok. Will change arguments[0] as well but we wont touch arguments henceforth.\n        try {\n            //\n            // Get storeNames from arguments. Either through given table instances, or through given table names.\n            //\n            var storeNames = tables.map(function (table) {\n                var storeName = table instanceof Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            //\n            // Resolve mode. Allow shortcuts \"r\" and \"rw\".\n            //\n            if (mode == \"r\" || mode == READONLY)\n                mode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                mode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                // Basic checks\n                if (parentTransaction.mode === READONLY && mode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        // Spawn new transaction instead.\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(function (storeName) {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                // Spawn new transaction instead.\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    // '?' mode should not keep using an inactive transaction.\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n                rejection(e);\n        }\n        // If this is a sub-transaction, lock the parent and then launch the sub-transaction.\n        return (parentTransaction ?\n            parentTransaction._promise(mode, enterTransactionScope, \"lock\") :\n            PSD.trans ?\n                // no parent transaction despite PSD.trans exists. Make sure also\n                // that the zone we create is not a sub-zone of current, because\n                // Promise.follow() should not wait for it if so.\n                usePSD(PSD.transless, function () { return db._whenReady(enterTransactionScope); }) :\n                db._whenReady(enterTransactionScope));\n        function enterTransactionScope() {\n            return Promise.resolve().then(function () {\n                // Keep a pointer to last non-transactional PSD to use if someone calls Dexie.ignoreTransaction().\n                var transless = PSD.transless || PSD;\n                // Our transaction.\n                //return new Promise((resolve, reject) => {\n                var trans = db._createTransaction(mode, storeNames, globalSchema, parentTransaction);\n                // Let the transaction instance be part of a Promise-specific data (PSD) value.\n                var zoneProps = {\n                    trans: trans,\n                    transless: transless\n                };\n                if (parentTransaction) {\n                    // Emulate transaction commit awareness for inner transaction (must 'commit' when the inner transaction has no more operations ongoing)\n                    trans.idbtrans = parentTransaction.idbtrans;\n                }\n                else {\n                    trans.create(); // Create the backend transaction so that complete() or error() will trigger even if no operation is made upon it.\n                }\n                // Support for native async await.\n                if (scopeFunc.constructor === AsyncFunction) {\n                    incrementExpectedAwaits();\n                }\n                var returnValue;\n                var promiseFollowed = Promise.follow(function () {\n                    // Finally, call the scope function with our table and transaction arguments.\n                    returnValue = scopeFunc.call(trans, trans);\n                    if (returnValue) {\n                        if (returnValue.constructor === NativePromise) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                        else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                            // scopeFunc returned an iterator with throw-support. Handle yield as await.\n                            returnValue = awaitIterator(returnValue);\n                        }\n                    }\n                }, zoneProps);\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    // Promise returned. User uses promise-style transactions.\n                    Promise.resolve(returnValue).then(function (x) { return trans.active ?\n                        x // Transaction still active. Continue.\n                        : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n                    // No promise returned. Wait for all outstanding promises before continuing. \n                    : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n                    // sub transactions don't react to idbtrans.oncomplete. We must trigger a completion:\n                    if (parentTransaction)\n                        trans._resolve();\n                    // wait for trans._completion\n                    // (if root transaction, this means 'complete' event. If sub-transaction, we've just fired it ourselves)\n                    return trans._completion.then(function () { return x; });\n                }).catch(function (e) {\n                    trans._reject(e); // Yes, above then-handler were maybe not called because of an unhandled rejection in scopeFunc!\n                    return rejection(e);\n                });\n            });\n        }\n    };\n    this.table = function (tableName) {\n        /// <returns type=\"Table\"></returns>\n        if (!hasOwn(allTables, tableName)) {\n            throw new exceptions.InvalidTable(\"Table \" + tableName + \" does not exist\");\n        }\n        return allTables[tableName];\n    };\n    //\n    //\n    //\n    // Table Class\n    //\n    //\n    //\n    function Table(name, tableSchema, optionalTrans) {\n        /// <param name=\"name\" type=\"String\"></param>\n        this.name = name;\n        this.schema = tableSchema;\n        this._tx = optionalTrans;\n        this.hook = allTables[name] ? allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    }\n    function BulkErrorHandlerCatchAll(errorList, done, supportHooks) {\n        return (supportHooks ? hookedEventRejectHandler : eventRejectHandler)(function (e) {\n            errorList.push(e);\n            done && done();\n        });\n    }\n    function bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook) {\n        // If hasDeleteHook, keysOrTuples must be an array of tuples: [[key1, value2],[key2,value2],...],\n        // else keysOrTuples must be just an array of keys: [key1, key2, ...].\n        return new Promise(function (resolve, reject) {\n            var len = keysOrTuples.length, lastItem = len - 1;\n            if (len === 0)\n                return resolve();\n            if (!hasDeleteHook) {\n                for (var i = 0; i < len; ++i) {\n                    var req = idbstore.delete(keysOrTuples[i]);\n                    req.onerror = eventRejectHandler(reject);\n                    if (i === lastItem)\n                        req.onsuccess = wrap(function () { return resolve(); });\n                }\n            }\n            else {\n                var hookCtx, errorHandler = hookedEventRejectHandler(reject), successHandler = hookedEventSuccessHandler(null);\n                tryCatch(function () {\n                    for (var i = 0; i < len; ++i) {\n                        hookCtx = { onsuccess: null, onerror: null };\n                        var tuple = keysOrTuples[i];\n                        deletingHook.call(hookCtx, tuple[0], tuple[1], trans);\n                        var req = idbstore.delete(tuple[0]);\n                        req._hookCtx = hookCtx;\n                        req.onerror = errorHandler;\n                        if (i === lastItem)\n                            req.onsuccess = hookedEventSuccessHandler(resolve);\n                        else\n                            req.onsuccess = successHandler;\n                    }\n                }, function (err) {\n                    hookCtx.onerror && hookCtx.onerror(err);\n                    throw err;\n                });\n            }\n        });\n    }\n    props(Table.prototype, {\n        //\n        // Table Protected Methods\n        //\n        _trans: function getTransaction(mode, fn, writeLocked) {\n            var trans = this._tx || PSD.trans;\n            return trans && trans.db === db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, fn, writeLocked) :\n                    newScope(function () { return trans._promise(mode, fn, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(mode, [this.name], fn);\n        },\n        _idbstore: function getIDBObjectStore(mode, fn, writeLocked) {\n            var tableName = this.name;\n            function supplyIdbStore(resolve, reject, trans) {\n                if (trans.storeNames.indexOf(tableName) === -1)\n                    throw new exceptions.NotFound(\"Table\" + tableName + \" not part of transaction\");\n                return fn(resolve, reject, trans.idbtrans.objectStore(tableName), trans);\n            }\n            return this._trans(mode, supplyIdbStore, writeLocked);\n        },\n        //\n        // Table Public Methods\n        //\n        get: function (keyOrCrit, cb) {\n            if (keyOrCrit && keyOrCrit.constructor === Object)\n                return this.where(keyOrCrit).first(cb);\n            var self = this;\n            return this._idbstore(READONLY, function (resolve, reject, idbstore) {\n                var req = idbstore.get(keyOrCrit);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(function () {\n                    resolve(self.hook.reading.fire(req.result));\n                }, reject);\n            }).then(cb);\n        },\n        where: function (indexOrCrit) {\n            if (typeof indexOrCrit === 'string')\n                return new WhereClause(this, indexOrCrit);\n            if (isArray(indexOrCrit))\n                return new WhereClause(this, \"[\" + indexOrCrit.join('+') + \"]\");\n            // indexOrCrit is an object map of {[keyPath]:value} \n            var keyPaths = keys(indexOrCrit);\n            if (keyPaths.length === 1)\n                // Only one critera. This was the easy case:\n                return this\n                    .where(keyPaths[0])\n                    .equals(indexOrCrit[keyPaths[0]]);\n            // Multiple criterias.\n            // Let's try finding a compound index that matches all keyPaths in\n            // arbritary order:\n            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n                return ix.compound &&\n                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; }) &&\n                    ix.keyPath.every(function (keyPath) { return keyPaths.indexOf(keyPath) >= 0; });\n            })[0];\n            if (compoundIndex && maxKey !== maxString)\n                // Cool! We found such compound index\n                // and this browser supports compound indexes (maxKey !== maxString)!\n                return this\n                    .where(compoundIndex.name)\n                    .equals(compoundIndex.keyPath.map(function (kp) { return indexOrCrit[kp]; }));\n            if (!compoundIndex)\n                console.warn(\"The query \" + JSON.stringify(indexOrCrit) + \" on \" + this.name + \" would benefit of a \" +\n                    (\"compound index [\" + keyPaths.join('+') + \"]\"));\n            // Ok, now let's fallback to finding at least one matching index\n            // and filter the rest.\n            var idxByName = this.schema.idxByName;\n            var simpleIndex = keyPaths.reduce(function (r, keyPath) { return [\n                r[0] || idxByName[keyPath],\n                r[0] || !idxByName[keyPath] ?\n                    combine(r[1], function (x) { return '' + getByKeyPath(x, keyPath) ==\n                        '' + indexOrCrit[keyPath]; })\n                    : r[1]\n            ]; }, [null, null]);\n            var idx = simpleIndex[0];\n            return idx ?\n                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                    .filter(simpleIndex[1]) :\n                compoundIndex ?\n                    this.filter(simpleIndex[1]) : // Has compound but browser bad. Allow filter.\n                    this.where(keyPaths).equals(''); // No index at all. Fail lazily.\n        },\n        count: function (cb) {\n            return this.toCollection().count(cb);\n        },\n        offset: function (offset) {\n            return this.toCollection().offset(offset);\n        },\n        limit: function (numRows) {\n            return this.toCollection().limit(numRows);\n        },\n        reverse: function () {\n            return this.toCollection().reverse();\n        },\n        filter: function (filterFunction) {\n            return this.toCollection().and(filterFunction);\n        },\n        each: function (fn) {\n            return this.toCollection().each(fn);\n        },\n        toArray: function (cb) {\n            return this.toCollection().toArray(cb);\n        },\n        orderBy: function (index) {\n            return new Collection(new WhereClause(this, isArray(index) ?\n                \"[\" + index.join('+') + \"]\" :\n                index));\n        },\n        toCollection: function () {\n            return new Collection(new WhereClause(this));\n        },\n        mapToClass: function (constructor, structure) {\n            /// <summary>\n            ///     Map table to a javascript constructor function. Objects returned from the database will be instances of this class, making\n            ///     it possible to the instanceOf operator as well as extending the class using constructor.prototype.method = function(){...}.\n            /// </summary>\n            /// <param name=\"constructor\">Constructor function representing the class.</param>\n            /// <param name=\"structure\" optional=\"true\">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also\n            /// know what type each member has. Example: {name: String, emailAddresses: [String], password}</param>\n            this.schema.mappedClass = constructor;\n            var instanceTemplate = Object.create(constructor.prototype);\n            if (structure) {\n                // structure and instanceTemplate is for IDE code competion only while constructor.prototype is for actual inheritance.\n                applyStructure(instanceTemplate, structure);\n            }\n            this.schema.instanceTemplate = instanceTemplate;\n            // Now, subscribe to the when(\"reading\") event to make all objects that come out from this table inherit from given class\n            // no matter which method to use for reading (Table.get() or Table.where(...)... )\n            var readHook = function (obj) {\n                if (!obj)\n                    return obj; // No valid object. (Value is null). Return as is.\n                // Create a new object that derives from constructor:\n                var res = Object.create(constructor.prototype);\n                // Clone members:\n                for (var m in obj)\n                    if (hasOwn(obj, m))\n                        try {\n                            res[m] = obj[m];\n                        }\n                        catch (_) { }\n                return res;\n            };\n            if (this.schema.readHook) {\n                this.hook.reading.unsubscribe(this.schema.readHook);\n            }\n            this.schema.readHook = readHook;\n            this.hook(\"reading\", readHook);\n            return constructor;\n        },\n        defineClass: function (structure) {\n            /// <summary>\n            ///     Define all members of the class that represents the table. This will help code completion of when objects are read from the database\n            ///     as well as making it possible to extend the prototype of the returned constructor function.\n            /// </summary>\n            /// <param name=\"structure\">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also\n            /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>\n            return this.mapToClass(Dexie.defineClass(structure), structure);\n        },\n        bulkDelete: function (keys$$1) {\n            if (this.hook.deleting.fire === nop) {\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\n                    resolve(bulkDelete(idbstore, trans, keys$$1, false, nop));\n                });\n            }\n            else {\n                return this\n                    .where(':id')\n                    .anyOf(keys$$1)\n                    .delete()\n                    .then(function () { }); // Resolve with undefined.\n            }\n        },\n        bulkPut: function (objects, keys$$1) {\n            var _this = this;\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                if (!idbstore.keyPath && !_this.schema.primKey.auto && !keys$$1)\n                    throw new exceptions.InvalidArgument(\"bulkPut() with non-inbound keys requires keys array in second argument\");\n                if (idbstore.keyPath && keys$$1)\n                    throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n                if (keys$$1 && keys$$1.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                if (objects.length === 0)\n                    return resolve(); // Caller provided empty list.\n                var done = function (result) {\n                    if (errorList.length === 0)\n                        resolve(result);\n                    else\n                        reject(new BulkError(_this.name + \".bulkPut(): \" + errorList.length + \" of \" + numObjs + \" operations failed\", errorList));\n                };\n                var req, errorList = [], errorHandler, numObjs = objects.length, table = _this;\n                if (_this.hook.creating.fire === nop && _this.hook.updating.fire === nop) {\n                    //\n                    // Standard Bulk (no 'creating' or 'updating' hooks to care about)\n                    //\n                    errorHandler = BulkErrorHandlerCatchAll(errorList);\n                    for (var i = 0, l = objects.length; i < l; ++i) {\n                        req = keys$$1 ? idbstore.put(objects[i], keys$$1[i]) : idbstore.put(objects[i]);\n                        req.onerror = errorHandler;\n                    }\n                    // Only need to catch success or error on the last operation\n                    // according to the IDB spec.\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);\n                    req.onsuccess = eventSuccessHandler(done);\n                }\n                else {\n                    var effectiveKeys = keys$$1 || idbstore.keyPath && objects.map(function (o) { return getByKeyPath(o, idbstore.keyPath); });\n                    // Generate map of {[key]: object}\n                    var objectLookup = effectiveKeys && arrayToObject(effectiveKeys, function (key, i) { return key != null && [key, objects[i]]; });\n                    var promise = !effectiveKeys ?\n                        // Auto-incremented key-less objects only without any keys argument.\n                        table.bulkAdd(objects) :\n                        // Keys provided. Either as inbound in provided objects, or as a keys argument.\n                        // Begin with updating those that exists in DB:\n                        table.where(':id').anyOf(effectiveKeys.filter(function (key) { return key != null; })).modify(function () {\n                            this.value = objectLookup[this.primKey];\n                            objectLookup[this.primKey] = null; // Mark as \"don't add this\"\n                        }).catch(ModifyError, function (e) {\n                            errorList = e.failures; // No need to concat here. These are the first errors added.\n                        }).then(function () {\n                            // Now, let's examine which items didnt exist so we can add them:\n                            var objsToAdd = [], keysToAdd = keys$$1 && [];\n                            // Iterate backwards. Why? Because if same key was used twice, just add the last one.\n                            for (var i = effectiveKeys.length - 1; i >= 0; --i) {\n                                var key = effectiveKeys[i];\n                                if (key == null || objectLookup[key]) {\n                                    objsToAdd.push(objects[i]);\n                                    keys$$1 && keysToAdd.push(key);\n                                    if (key != null)\n                                        objectLookup[key] = null; // Mark as \"dont add again\"\n                                }\n                            }\n                            // The items are in reverse order so reverse them before adding.\n                            // Could be important in order to get auto-incremented keys the way the caller\n                            // would expect. Could have used unshift instead of push()/reverse(),\n                            // but: http://jsperf.com/unshift-vs-reverse\n                            objsToAdd.reverse();\n                            keys$$1 && keysToAdd.reverse();\n                            return table.bulkAdd(objsToAdd, keysToAdd);\n                        }).then(function (lastAddedKey) {\n                            // Resolve with key of the last object in given arguments to bulkPut():\n                            var lastEffectiveKey = effectiveKeys[effectiveKeys.length - 1]; // Key was provided.\n                            return lastEffectiveKey != null ? lastEffectiveKey : lastAddedKey;\n                        });\n                    promise.then(done).catch(BulkError, function (e) {\n                        // Concat failure from ModifyError and reject using our 'done' method.\n                        errorList = errorList.concat(e.failures);\n                        done();\n                    }).catch(reject);\n                }\n            }, \"locked\"); // If called from transaction scope, lock transaction til all steps are done.\n        },\n        bulkAdd: function (objects, keys$$1) {\n            var self = this, creatingHook = this.hook.creating.fire;\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\n                if (!idbstore.keyPath && !self.schema.primKey.auto && !keys$$1)\n                    throw new exceptions.InvalidArgument(\"bulkAdd() with non-inbound keys requires keys array in second argument\");\n                if (idbstore.keyPath && keys$$1)\n                    throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n                if (keys$$1 && keys$$1.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                if (objects.length === 0)\n                    return resolve(); // Caller provided empty list.\n                function done(result) {\n                    if (errorList.length === 0)\n                        resolve(result);\n                    else\n                        reject(new BulkError(self.name + \".bulkAdd(): \" + errorList.length + \" of \" + numObjs + \" operations failed\", errorList));\n                }\n                var req, errorList = [], errorHandler, successHandler, numObjs = objects.length;\n                if (creatingHook !== nop) {\n                    //\n                    // There are subscribers to hook('creating')\n                    // Must behave as documented.\n                    //\n                    var keyPath = idbstore.keyPath, hookCtx;\n                    errorHandler = BulkErrorHandlerCatchAll(errorList, null, true);\n                    successHandler = hookedEventSuccessHandler(null);\n                    tryCatch(function () {\n                        for (var i = 0, l = objects.length; i < l; ++i) {\n                            hookCtx = { onerror: null, onsuccess: null };\n                            var key = keys$$1 && keys$$1[i];\n                            var obj = objects[i], effectiveKey = keys$$1 ? key : keyPath ? getByKeyPath(obj, keyPath) : undefined, keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans);\n                            if (effectiveKey == null && keyToUse != null) {\n                                if (keyPath) {\n                                    obj = deepClone(obj);\n                                    setByKeyPath(obj, keyPath, keyToUse);\n                                }\n                                else {\n                                    key = keyToUse;\n                                }\n                            }\n                            req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);\n                            req._hookCtx = hookCtx;\n                            if (i < l - 1) {\n                                req.onerror = errorHandler;\n                                if (hookCtx.onsuccess)\n                                    req.onsuccess = successHandler;\n                            }\n                        }\n                    }, function (err) {\n                        hookCtx.onerror && hookCtx.onerror(err);\n                        throw err;\n                    });\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done, true);\n                    req.onsuccess = hookedEventSuccessHandler(done);\n                }\n                else {\n                    //\n                    // Standard Bulk (no 'creating' hook to care about)\n                    //\n                    errorHandler = BulkErrorHandlerCatchAll(errorList);\n                    for (var i = 0, l = objects.length; i < l; ++i) {\n                        req = keys$$1 ? idbstore.add(objects[i], keys$$1[i]) : idbstore.add(objects[i]);\n                        req.onerror = errorHandler;\n                    }\n                    // Only need to catch success or error on the last operation\n                    // according to the IDB spec.\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);\n                    req.onsuccess = eventSuccessHandler(done);\n                }\n            });\n        },\n        add: function (obj, key) {\n            /// <summary>\n            ///   Add an object to the database. In case an object with same primary key already exists, the object will not be added.\n            /// </summary>\n            /// <param name=\"obj\" type=\"Object\">A javascript object to insert</param>\n            /// <param name=\"key\" optional=\"true\">Primary key</param>\n            var creatingHook = this.hook.creating.fire;\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\n                var hookCtx = { onsuccess: null, onerror: null };\n                if (creatingHook !== nop) {\n                    var effectiveKey = (key != null) ? key : (idbstore.keyPath ? getByKeyPath(obj, idbstore.keyPath) : undefined);\n                    var keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans); // Allow subscribers to when(\"creating\") to generate the key.\n                    if (effectiveKey == null && keyToUse != null) {\n                        if (idbstore.keyPath)\n                            setByKeyPath(obj, idbstore.keyPath, keyToUse);\n                        else\n                            key = keyToUse;\n                    }\n                }\n                try {\n                    var req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);\n                    req._hookCtx = hookCtx;\n                    req.onerror = hookedEventRejectHandler(reject);\n                    req.onsuccess = hookedEventSuccessHandler(function (result) {\n                        // TODO: Remove these two lines in next major release (2.0?)\n                        // It's no good practice to have side effects on provided parameters\n                        var keyPath = idbstore.keyPath;\n                        if (keyPath)\n                            setByKeyPath(obj, keyPath, result);\n                        resolve(result);\n                    });\n                }\n                catch (e) {\n                    if (hookCtx.onerror)\n                        hookCtx.onerror(e);\n                    throw e;\n                }\n            });\n        },\n        put: function (obj, key) {\n            var _this = this;\n            /// <summary>\n            ///   Add an object to the database but in case an object with same primary key alread exists, the existing one will get updated.\n            /// </summary>\n            /// <param name=\"obj\" type=\"Object\">A javascript object to insert or update</param>\n            /// <param name=\"key\" optional=\"true\">Primary key</param>\n            var creatingHook = this.hook.creating.fire, updatingHook = this.hook.updating.fire;\n            if (creatingHook !== nop || updatingHook !== nop) {\n                //\n                // People listens to when(\"creating\") or when(\"updating\") events!\n                // We must know whether the put operation results in an CREATE or UPDATE.\n                //\n                var keyPath = this.schema.primKey.keyPath;\n                var effectiveKey = (key !== undefined) ? key : (keyPath && getByKeyPath(obj, keyPath));\n                if (effectiveKey == null)\n                    return this.add(obj);\n                // Since key is optional, make sure we get it from obj if not provided\n                // Primary key exist. Lock transaction and try modifying existing. If nothing modified, call add().\n                // clone obj before this async call. If caller modifies obj the line after put(), the IDB spec requires that it should not affect operation.\n                obj = deepClone(obj);\n                return this._trans(READWRITE, function () {\n                    return _this.where(\":id\").equals(effectiveKey).modify(function () {\n                        // Replace extisting value with our object\n                        // CRUD event firing handled in Collection.modify()\n                        this.value = obj;\n                    }).then(function (count) { return count === 0 ? _this.add(obj, key) : effectiveKey; });\n                }, \"locked\"); // Lock needed because operation is splitted into modify() and add().\n            }\n            else {\n                // Use the standard IDB put() method.\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                    var req = key !== undefined ? idbstore.put(obj, key) : idbstore.put(obj);\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = wrap(function (ev) {\n                        var keyPath = idbstore.keyPath;\n                        if (keyPath)\n                            setByKeyPath(obj, keyPath, ev.target.result);\n                        resolve(req.result);\n                    });\n                });\n            }\n        },\n        'delete': function (key) {\n            /// <param name=\"key\">Primary key of the object to delete</param>\n            if (this.hook.deleting.subscribers.length) {\n                // People listens to when(\"deleting\") event. Must implement delete using Collection.delete() that will\n                // call the CRUD event. Only Collection.delete() will know whether an object was actually deleted.\n                return this.where(\":id\").equals(key).delete();\n            }\n            else {\n                // No one listens. Use standard IDB delete() method.\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                    var req = idbstore.delete(key);\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = wrap(function () {\n                        resolve(req.result);\n                    });\n                });\n            }\n        },\n        clear: function () {\n            if (this.hook.deleting.subscribers.length) {\n                // People listens to when(\"deleting\") event. Must implement delete using Collection.delete() that will\n                // call the CRUD event. Only Collection.delete() will knows which objects that are actually deleted.\n                return this.toCollection().delete();\n            }\n            else {\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                    var req = idbstore.clear();\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = wrap(function () {\n                        resolve(req.result);\n                    });\n                });\n            }\n        },\n        update: function (keyOrObject, modifications) {\n            if (typeof modifications !== 'object' || isArray(modifications))\n                throw new exceptions.InvalidArgument(\"Modifications must be an object.\");\n            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n                // object to modify. Also modify given object with the modifications:\n                keys(modifications).forEach(function (keyPath) {\n                    setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                });\n                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n                if (key === undefined)\n                    return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n                return this.where(\":id\").equals(key).modify(modifications);\n            }\n            else {\n                // key to modify\n                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n            }\n        }\n    });\n    //\n    //\n    //\n    // Transaction Class\n    //\n    //\n    //\n    function Transaction(mode, storeNames, dbschema, parent) {\n        var _this = this;\n        /// <summary>\n        ///    Transaction class. Represents a database transaction. All operations on db goes through a Transaction.\n        /// </summary>\n        /// <param name=\"mode\" type=\"String\">Any of \"readwrite\" or \"readonly\"</param>\n        /// <param name=\"storeNames\" type=\"Array\">Array of table names to operate on</param>\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0; // Just for debugging waitFor()\n        this._completion = new Promise(function (resolve, reject) {\n            _this._resolve = resolve;\n            _this._reject = reject;\n        });\n        this._completion.then(function () {\n            _this.active = false;\n            _this.on.complete.fire();\n        }, function (e) {\n            var wasActive = _this.active;\n            _this.active = false;\n            _this.on.error.fire(e);\n            _this.parent ?\n                _this.parent._reject(e) :\n                wasActive && _this.idbtrans && _this.idbtrans.abort();\n            return rejection(e); // Indicate we actually DO NOT catch this error.\n        });\n    }\n    props(Transaction.prototype, {\n        //\n        // Transaction Protected Methods (not required by API users, but needed internally and eventually by dexie extensions)\n        //\n        _lock: function () {\n            assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.\n            // Temporary set all requests into a pending queue if they are called before database is ready.\n            ++this._reculock; // Recursive read/write lock pattern using PSD (Promise Specific Data) instead of TLS (Thread Local Storage)\n            if (this._reculock === 1 && !PSD.global)\n                PSD.lockOwnerFor = this;\n            return this;\n        },\n        _unlock: function () {\n            assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.\n            if (--this._reculock === 0) {\n                if (!PSD.global)\n                    PSD.lockOwnerFor = null;\n                while (this._blockedFuncs.length > 0 && !this._locked()) {\n                    var fnAndPSD = this._blockedFuncs.shift();\n                    try {\n                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n                    }\n                    catch (e) { }\n                }\n            }\n            return this;\n        },\n        _locked: function () {\n            // Checks if any write-lock is applied on this transaction.\n            // To simplify the Dexie API for extension implementations, we support recursive locks.\n            // This is accomplished by using \"Promise Specific Data\" (PSD).\n            // PSD data is bound to a Promise and any child Promise emitted through then() or resolve( new Promise() ).\n            // PSD is local to code executing on top of the call stacks of any of any code executed by Promise():\n            //         * callback given to the Promise() constructor  (function (resolve, reject){...})\n            //         * callbacks given to then()/catch()/finally() methods (function (value){...})\n            // If creating a new independant Promise instance from within a Promise call stack, the new Promise will derive the PSD from the call stack of the parent Promise.\n            // Derivation is done so that the inner PSD __proto__ points to the outer PSD.\n            // PSD.lockOwnerFor will point to current transaction object if the currently executing PSD scope owns the lock.\n            return this._reculock && PSD.lockOwnerFor !== this;\n        },\n        create: function (idbtrans) {\n            var _this = this;\n            if (!this.mode)\n                return this;\n            assert(!this.idbtrans);\n            if (!idbtrans && !idbdb) {\n                switch (dbOpenError && dbOpenError.name) {\n                    case \"DatabaseClosedError\":\n                        // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\n                        throw new exceptions.DatabaseClosed(dbOpenError);\n                    case \"MissingAPIError\":\n                        // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\n                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                    default:\n                        // Make it clear that the user operation was not what caused the error - the error had occurred earlier on db.open()!\n                        throw new exceptions.OpenFailed(dbOpenError);\n                }\n            }\n            if (!this.active)\n                throw new exceptions.TransactionInactive();\n            assert(this._completion._state === null);\n            idbtrans = this.idbtrans = idbtrans || idbdb.transaction(safariMultiStoreFix(this.storeNames), this.mode);\n            idbtrans.onerror = wrap(function (ev) {\n                preventDefault(ev); // Prohibit default bubbling to window.error\n                _this._reject(idbtrans.error);\n            });\n            idbtrans.onabort = wrap(function (ev) {\n                preventDefault(ev);\n                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n                _this.active = false;\n                _this.on(\"abort\").fire(ev);\n            });\n            idbtrans.oncomplete = wrap(function () {\n                _this.active = false;\n                _this._resolve();\n            });\n            return this;\n        },\n        _promise: function (mode, fn, bWriteLock) {\n            var _this = this;\n            if (mode === READWRITE && this.mode !== READWRITE)\n                return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n            if (!this.active)\n                return rejection(new exceptions.TransactionInactive());\n            if (this._locked()) {\n                return new Promise(function (resolve, reject) {\n                    _this._blockedFuncs.push([function () {\n                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                        }, PSD]);\n                });\n            }\n            else if (bWriteLock) {\n                return newScope(function () {\n                    var p = new Promise(function (resolve, reject) {\n                        _this._lock();\n                        var rv = fn(resolve, reject, _this);\n                        if (rv && rv.then)\n                            rv.then(resolve, reject);\n                    });\n                    p.finally(function () { return _this._unlock(); });\n                    p._lib = true;\n                    return p;\n                });\n            }\n            else {\n                var p = new Promise(function (resolve, reject) {\n                    var rv = fn(resolve, reject, _this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p._lib = true;\n                return p;\n            }\n        },\n        _root: function () {\n            return this.parent ? this.parent._root() : this;\n        },\n        waitFor: function (promise) {\n            // Always operate on the root transaction (in case this is a sub stransaction)\n            var root = this._root();\n            // For stability reasons, convert parameter to promise no matter what type is passed to waitFor().\n            // (We must be able to call .then() on it.)\n            promise = Promise.resolve(promise);\n            if (root._waitingFor) {\n                // Already called waitFor(). Wait for both to complete.\n                root._waitingFor = root._waitingFor.then(function () { return promise; });\n            }\n            else {\n                // We're not in waiting state. Start waiting state.\n                root._waitingFor = promise;\n                root._waitingQueue = [];\n                // Start interacting with indexedDB until promise completes:\n                var store = root.idbtrans.objectStore(root.storeNames[0]);\n                (function spin() {\n                    ++root._spinCount; // For debugging only\n                    while (root._waitingQueue.length)\n                        (root._waitingQueue.shift())();\n                    if (root._waitingFor)\n                        store.get(-Infinity).onsuccess = spin;\n                }());\n            }\n            var currentWaitPromise = root._waitingFor;\n            return new Promise(function (resolve, reject) {\n                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n                    if (root._waitingFor === currentWaitPromise) {\n                        // No one added a wait after us. Safe to stop the spinning.\n                        root._waitingFor = null;\n                    }\n                });\n            });\n        },\n        //\n        // Transaction Public Properties and Methods\n        //\n        abort: function () {\n            this.active && this._reject(new exceptions.Abort());\n            this.active = false;\n        },\n        tables: {\n            get: deprecated(\"Transaction.tables\", function () { return allTables; })\n        },\n        table: function (name) {\n            var table = db.table(name); // Don't check that table is part of transaction. It must fail lazily!\n            return new Table(name, table.schema, this);\n        }\n    });\n    //\n    //\n    //\n    // WhereClause\n    //\n    //\n    //\n    function WhereClause(table, index, orCollection) {\n        /// <param name=\"table\" type=\"Table\"></param>\n        /// <param name=\"index\" type=\"String\" optional=\"true\"></param>\n        /// <param name=\"orCollection\" type=\"Collection\" optional=\"true\"></param>\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n    }\n    props(WhereClause.prototype, function () {\n        // WhereClause private methods\n        function fail(collectionOrWhereClause, err, T) {\n            var collection = collectionOrWhereClause instanceof WhereClause ?\n                new Collection(collectionOrWhereClause) :\n                collectionOrWhereClause;\n            collection._ctx.error = T ? new T(err) : new TypeError(err);\n            return collection;\n        }\n        function emptyCollection(whereClause) {\n            return new Collection(whereClause, function () { return IDBKeyRange.only(\"\"); }).limit(0);\n        }\n        function upperFactory(dir) {\n            return dir === \"next\" ? function (s) { return s.toUpperCase(); } : function (s) { return s.toLowerCase(); };\n        }\n        function lowerFactory(dir) {\n            return dir === \"next\" ? function (s) { return s.toLowerCase(); } : function (s) { return s.toUpperCase(); };\n        }\n        function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n            var length = Math.min(key.length, lowerNeedle.length);\n            var llp = -1;\n            for (var i = 0; i < length; ++i) {\n                var lwrKeyChar = lowerKey[i];\n                if (lwrKeyChar !== lowerNeedle[i]) {\n                    if (cmp(key[i], upperNeedle[i]) < 0)\n                        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n                    if (cmp(key[i], lowerNeedle[i]) < 0)\n                        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n                    if (llp >= 0)\n                        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n                    return null;\n                }\n                if (cmp(key[i], lwrKeyChar) < 0)\n                    llp = i;\n            }\n            if (length < lowerNeedle.length && dir === \"next\")\n                return key + upperNeedle.substr(key.length);\n            if (length < key.length && dir === \"prev\")\n                return key.substr(0, upperNeedle.length);\n            return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n        }\n        function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n            /// <param name=\"needles\" type=\"Array\" elementType=\"String\"></param>\n            var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n            if (!needles.every(function (s) { return typeof s === 'string'; })) {\n                return fail(whereClause, STRING_EXPECTED);\n            }\n            function initDirection(dir) {\n                upper = upperFactory(dir);\n                lower = lowerFactory(dir);\n                compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n                var needleBounds = needles.map(function (needle) {\n                    return { lower: lower(needle), upper: upper(needle) };\n                }).sort(function (a, b) {\n                    return compare(a.lower, b.lower);\n                });\n                upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n                lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n                direction = dir;\n                nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n            }\n            initDirection(\"next\");\n            var c = new Collection(whereClause, function () {\n                return IDBKeyRange.bound(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);\n            });\n            c._ondirectionchange = function (direction) {\n                // This event onlys occur before filter is called the first time.\n                initDirection(direction);\n            };\n            var firstPossibleNeedle = 0;\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                /// <param name=\"cursor\" type=\"IDBCursor\"></param>\n                /// <param name=\"advance\" type=\"Function\"></param>\n                /// <param name=\"resolve\" type=\"Function\"></param>\n                var key = cursor.key;\n                if (typeof key !== 'string')\n                    return false;\n                var lowerKey = lower(key);\n                if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n                    return true;\n                }\n                else {\n                    var lowestPossibleCasing = null;\n                    for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                        if (casing === null && lowestPossibleCasing === null)\n                            firstPossibleNeedle = i + 1;\n                        else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                            lowestPossibleCasing = casing;\n                        }\n                    }\n                    if (lowestPossibleCasing !== null) {\n                        advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n                    }\n                    else {\n                        advance(resolve);\n                    }\n                    return false;\n                }\n            });\n            return c;\n        }\n        //\n        // WhereClause public methods\n        //\n        return {\n            between: function (lower, upper, includeLower, includeUpper) {\n                /// <summary>\n                ///     Filter out records whose where-field lays between given lower and upper values. Applies to Strings, Numbers and Dates.\n                /// </summary>\n                /// <param name=\"lower\"></param>\n                /// <param name=\"upper\"></param>\n                /// <param name=\"includeLower\" optional=\"true\">Whether items that equals lower should be included. Default true.</param>\n                /// <param name=\"includeUpper\" optional=\"true\">Whether items that equals upper should be included. Default false.</param>\n                /// <returns type=\"Collection\"></returns>\n                includeLower = includeLower !== false; // Default to true\n                includeUpper = includeUpper === true; // Default to false\n                try {\n                    if ((cmp(lower, upper) > 0) ||\n                        (cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                        return emptyCollection(this); // Workaround for idiotic W3C Specification that DataError must be thrown if lower > upper. The natural result would be to return an empty collection.\n                    return new Collection(this, function () { return IDBKeyRange.bound(lower, upper, !includeLower, !includeUpper); });\n                }\n                catch (e) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n            },\n            equals: function (value) {\n                return new Collection(this, function () { return IDBKeyRange.only(value); });\n            },\n            above: function (value) {\n                return new Collection(this, function () { return IDBKeyRange.lowerBound(value, true); });\n            },\n            aboveOrEqual: function (value) {\n                return new Collection(this, function () { return IDBKeyRange.lowerBound(value); });\n            },\n            below: function (value) {\n                return new Collection(this, function () { return IDBKeyRange.upperBound(value, true); });\n            },\n            belowOrEqual: function (value) {\n                return new Collection(this, function () { return IDBKeyRange.upperBound(value); });\n            },\n            startsWith: function (str) {\n                /// <param name=\"str\" type=\"String\"></param>\n                if (typeof str !== 'string')\n                    return fail(this, STRING_EXPECTED);\n                return this.between(str, str + maxString, true, true);\n            },\n            startsWithIgnoreCase: function (str) {\n                /// <param name=\"str\" type=\"String\"></param>\n                if (str === \"\")\n                    return this.startsWith(str);\n                return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n            },\n            equalsIgnoreCase: function (str) {\n                /// <param name=\"str\" type=\"String\"></param>\n                return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n            },\n            anyOfIgnoreCase: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                if (set.length === 0)\n                    return emptyCollection(this);\n                return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n            },\n            startsWithAnyOfIgnoreCase: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                if (set.length === 0)\n                    return emptyCollection(this);\n                return addIgnoreCaseAlgorithm(this, function (x, a) {\n                    return a.some(function (n) {\n                        return x.indexOf(n) === 0;\n                    });\n                }, set, maxString);\n            },\n            anyOf: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                var compare = ascending;\n                try {\n                    set.sort(compare);\n                }\n                catch (e) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n                if (set.length === 0)\n                    return emptyCollection(this);\n                var c = new Collection(this, function () { return IDBKeyRange.bound(set[0], set[set.length - 1]); });\n                c._ondirectionchange = function (direction) {\n                    compare = (direction === \"next\" ? ascending : descending);\n                    set.sort(compare);\n                };\n                var i = 0;\n                c._addAlgorithm(function (cursor, advance, resolve) {\n                    var key = cursor.key;\n                    while (compare(key, set[i]) > 0) {\n                        // The cursor has passed beyond this key. Check next.\n                        ++i;\n                        if (i === set.length) {\n                            // There is no next. Stop searching.\n                            advance(resolve);\n                            return false;\n                        }\n                    }\n                    if (compare(key, set[i]) === 0) {\n                        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\n                        return true;\n                    }\n                    else {\n                        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\n                        advance(function () { cursor.continue(set[i]); });\n                        return false;\n                    }\n                });\n                return c;\n            },\n            notEqual: function (value) {\n                return this.inAnyRange([[minKey, value], [value, maxKey]], { includeLowers: false, includeUppers: false });\n            },\n            noneOf: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                if (set.length === 0)\n                    return new Collection(this); // Return entire collection.\n                try {\n                    set.sort(ascending);\n                }\n                catch (e) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n                // Transform [\"a\",\"b\",\"c\"] to a set of ranges for between/above/below: [[minKey,\"a\"], [\"a\",\"b\"], [\"b\",\"c\"], [\"c\",maxKey]]\n                var ranges = set.reduce(function (res, val) { return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]]; }, null);\n                ranges.push([set[set.length - 1], maxKey]);\n                return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n            },\n            /** Filter out values withing given set of ranges.\n            * Example, give children and elders a rebate of 50%:\n            *\n            *   db.friends.where('age').inAnyRange([[0,18],[65,Infinity]]).modify({Rebate: 1/2});\n            *\n            * @param {(string|number|Date|Array)[][]} ranges\n            * @param {{includeLowers: boolean, includeUppers: boolean}} options\n            */\n            inAnyRange: function (ranges, options) {\n                if (ranges.length === 0)\n                    return emptyCollection(this);\n                if (!ranges.every(function (range) { return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0; })) {\n                    return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n                }\n                var includeLowers = !options || options.includeLowers !== false; // Default to true\n                var includeUppers = options && options.includeUppers === true; // Default to false\n                function addRange(ranges, newRange) {\n                    for (var i = 0, l = ranges.length; i < l; ++i) {\n                        var range = ranges[i];\n                        if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                            range[0] = min(range[0], newRange[0]);\n                            range[1] = max(range[1], newRange[1]);\n                            break;\n                        }\n                    }\n                    if (i === l)\n                        ranges.push(newRange);\n                    return ranges;\n                }\n                var sortDirection = ascending;\n                function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n                // Join overlapping ranges\n                var set;\n                try {\n                    set = ranges.reduce(addRange, []);\n                    set.sort(rangeSorter);\n                }\n                catch (ex) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n                var i = 0;\n                var keyIsBeyondCurrentEntry = includeUppers ?\n                    function (key) { return ascending(key, set[i][1]) > 0; } :\n                    function (key) { return ascending(key, set[i][1]) >= 0; };\n                var keyIsBeforeCurrentEntry = includeLowers ?\n                    function (key) { return descending(key, set[i][0]) > 0; } :\n                    function (key) { return descending(key, set[i][0]) >= 0; };\n                function keyWithinCurrentRange(key) {\n                    return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n                }\n                var checkKey = keyIsBeyondCurrentEntry;\n                var c = new Collection(this, function () {\n                    return IDBKeyRange.bound(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);\n                });\n                c._ondirectionchange = function (direction) {\n                    if (direction === \"next\") {\n                        checkKey = keyIsBeyondCurrentEntry;\n                        sortDirection = ascending;\n                    }\n                    else {\n                        checkKey = keyIsBeforeCurrentEntry;\n                        sortDirection = descending;\n                    }\n                    set.sort(rangeSorter);\n                };\n                c._addAlgorithm(function (cursor, advance, resolve) {\n                    var key = cursor.key;\n                    while (checkKey(key)) {\n                        // The cursor has passed beyond this key. Check next.\n                        ++i;\n                        if (i === set.length) {\n                            // There is no next. Stop searching.\n                            advance(resolve);\n                            return false;\n                        }\n                    }\n                    if (keyWithinCurrentRange(key)) {\n                        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\n                        return true;\n                    }\n                    else if (cmp(key, set[i][1]) === 0 || cmp(key, set[i][0]) === 0) {\n                        // includeUpper or includeLower is false so keyWithinCurrentRange() returns false even though we are at range border.\n                        // Continue to next key but don't include this one.\n                        return false;\n                    }\n                    else {\n                        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\n                        advance(function () {\n                            if (sortDirection === ascending)\n                                cursor.continue(set[i][0]);\n                            else\n                                cursor.continue(set[i][1]);\n                        });\n                        return false;\n                    }\n                });\n                return c;\n            },\n            startsWithAnyOf: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                if (!set.every(function (s) { return typeof s === 'string'; })) {\n                    return fail(this, \"startsWithAnyOf() only works with strings\");\n                }\n                if (set.length === 0)\n                    return emptyCollection(this);\n                return this.inAnyRange(set.map(function (str) {\n                    return [str, str + maxString];\n                }));\n            }\n        };\n    });\n    //\n    //\n    //\n    // Collection Class\n    //\n    //\n    //\n    function Collection(whereClause, keyRangeGenerator) {\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"whereClause\" type=\"WhereClause\">Where clause instance</param>\n        /// <param name=\"keyRangeGenerator\" value=\"function(){ return IDBKeyRange.bound(0,1);}\" optional=\"true\"></param>\n        var keyRange = null, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        var whereCtx = whereClause._ctx, table = whereCtx.table;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: table.hook.reading.fire\n        };\n    }\n    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n        return !(ctx.filter || ctx.algorithm || ctx.or) &&\n            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n    }\n    props(Collection.prototype, function () {\n        //\n        // Collection Private Functions\n        //\n        function addFilter(ctx, fn) {\n            ctx.filter = combine(ctx.filter, fn);\n        }\n        function addReplayFilter(ctx, factory, isLimitFilter) {\n            var curr = ctx.replayFilter;\n            ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n            ctx.justLimit = isLimitFilter && !curr;\n        }\n        function addMatchFilter(ctx, fn) {\n            ctx.isMatch = combine(ctx.isMatch, fn);\n        }\n        /** @param ctx {\n         *      isPrimKey: boolean,\n         *      table: Table,\n         *      index: string\n         * }\n         * @param store IDBObjectStore\n         **/\n        function getIndexOrStore(ctx, store) {\n            if (ctx.isPrimKey)\n                return store;\n            var indexSpec = ctx.table.schema.idxByName[ctx.index];\n            if (!indexSpec)\n                throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + store.name + \" is not indexed\");\n            return store.index(indexSpec.name);\n        }\n        /** @param ctx {\n         *      isPrimKey: boolean,\n         *      table: Table,\n         *      index: string,\n         *      keysOnly: boolean,\n         *      range?: IDBKeyRange,\n         *      dir: \"next\" | \"prev\"\n         * }\n         */\n        function openCursor(ctx, store) {\n            var idxOrStore = getIndexOrStore(ctx, store);\n            return ctx.keysOnly && 'openKeyCursor' in idxOrStore ?\n                idxOrStore.openKeyCursor(ctx.range || null, ctx.dir + ctx.unique) :\n                idxOrStore.openCursor(ctx.range || null, ctx.dir + ctx.unique);\n        }\n        function iter(ctx, fn, resolve, reject, idbstore) {\n            var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n            if (!ctx.or) {\n                iterate(openCursor(ctx, idbstore), combine(ctx.algorithm, filter), fn, resolve, reject, !ctx.keysOnly && ctx.valueMapper);\n            }\n            else\n                (function () {\n                    var set = {};\n                    var resolved = 0;\n                    function resolveboth() {\n                        if (++resolved === 2)\n                            resolve(); // Seems like we just support or btwn max 2 expressions, but there are no limit because we do recursion.\n                    }\n                    function union(item, cursor, advance) {\n                        if (!filter || filter(cursor, advance, resolveboth, reject)) {\n                            var primaryKey = cursor.primaryKey;\n                            var key = '' + primaryKey;\n                            if (key === '[object ArrayBuffer]')\n                                key = '' + new Uint8Array(primaryKey);\n                            if (!hasOwn(set, key)) {\n                                set[key] = true;\n                                fn(item, cursor, advance);\n                            }\n                        }\n                    }\n                    ctx.or._iterate(union, resolveboth, reject, idbstore);\n                    iterate(openCursor(ctx, idbstore), ctx.algorithm, union, resolveboth, reject, !ctx.keysOnly && ctx.valueMapper);\n                })();\n        }\n        return {\n            //\n            // Collection Protected Functions\n            //\n            _read: function (fn, cb) {\n                var ctx = this._ctx;\n                return ctx.error ?\n                    ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                    ctx.table._idbstore(READONLY, fn).then(cb);\n            },\n            _write: function (fn) {\n                var ctx = this._ctx;\n                return ctx.error ?\n                    ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                    ctx.table._idbstore(READWRITE, fn, \"locked\"); // When doing write operations on collections, always lock the operation so that upcoming operations gets queued.\n            },\n            _addAlgorithm: function (fn) {\n                var ctx = this._ctx;\n                ctx.algorithm = combine(ctx.algorithm, fn);\n            },\n            _iterate: function (fn, resolve, reject, idbstore) {\n                return iter(this._ctx, fn, resolve, reject, idbstore);\n            },\n            clone: function (props$$1) {\n                var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n                if (props$$1)\n                    extend(ctx, props$$1);\n                rv._ctx = ctx;\n                return rv;\n            },\n            raw: function () {\n                this._ctx.valueMapper = null;\n                return this;\n            },\n            //\n            // Collection Public methods\n            //\n            each: function (fn) {\n                var ctx = this._ctx;\n                return this._read(function (resolve, reject, idbstore) {\n                    iter(ctx, fn, resolve, reject, idbstore);\n                });\n            },\n            count: function (cb) {\n                var ctx = this._ctx;\n                if (isPlainKeyRange(ctx, true)) {\n                    // This is a plain key range. We can use the count() method if the index.\n                    return this._read(function (resolve, reject, idbstore) {\n                        var idx = getIndexOrStore(ctx, idbstore);\n                        var req = (ctx.range ? idx.count(ctx.range) : idx.count());\n                        req.onerror = eventRejectHandler(reject);\n                        req.onsuccess = function (e) {\n                            resolve(Math.min(e.target.result, ctx.limit));\n                        };\n                    }, cb);\n                }\n                else {\n                    // Algorithms, filters or expressions are applied. Need to count manually.\n                    var count = 0;\n                    return this._read(function (resolve, reject, idbstore) {\n                        iter(ctx, function () { ++count; return false; }, function () { resolve(count); }, reject, idbstore);\n                    }, cb);\n                }\n            },\n            sortBy: function (keyPath, cb) {\n                /// <param name=\"keyPath\" type=\"String\"></param>\n                var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n                function getval(obj, i) {\n                    if (i)\n                        return getval(obj[parts[i]], i - 1);\n                    return obj[lastPart];\n                }\n                var order = this._ctx.dir === \"next\" ? 1 : -1;\n                function sorter(a, b) {\n                    var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n                    return aVal < bVal ? -order : aVal > bVal ? order : 0;\n                }\n                return this.toArray(function (a) {\n                    return a.sort(sorter);\n                }).then(cb);\n            },\n            toArray: function (cb) {\n                var ctx = this._ctx;\n                return this._read(function (resolve, reject, idbstore) {\n                    if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                        // Special optimation if we could use IDBObjectStore.getAll() or\n                        // IDBKeyRange.getAll():\n                        var readingHook = ctx.table.hook.reading.fire;\n                        var idxOrStore = getIndexOrStore(ctx, idbstore);\n                        var req = ctx.limit < Infinity ?\n                            idxOrStore.getAll(ctx.range, ctx.limit) :\n                            idxOrStore.getAll(ctx.range);\n                        req.onerror = eventRejectHandler(reject);\n                        req.onsuccess = readingHook === mirror ?\n                            eventSuccessHandler(resolve) :\n                            eventSuccessHandler(function (res) {\n                                try {\n                                    resolve(res.map(readingHook));\n                                }\n                                catch (e) {\n                                    reject(e);\n                                }\n                            });\n                    }\n                    else {\n                        // Getting array through a cursor.\n                        var a = [];\n                        iter(ctx, function (item) { a.push(item); }, function arrayComplete() {\n                            resolve(a);\n                        }, reject, idbstore);\n                    }\n                }, cb);\n            },\n            offset: function (offset) {\n                var ctx = this._ctx;\n                if (offset <= 0)\n                    return this;\n                ctx.offset += offset; // For count()\n                if (isPlainKeyRange(ctx)) {\n                    addReplayFilter(ctx, function () {\n                        var offsetLeft = offset;\n                        return function (cursor, advance) {\n                            if (offsetLeft === 0)\n                                return true;\n                            if (offsetLeft === 1) {\n                                --offsetLeft;\n                                return false;\n                            }\n                            advance(function () {\n                                cursor.advance(offsetLeft);\n                                offsetLeft = 0;\n                            });\n                            return false;\n                        };\n                    });\n                }\n                else {\n                    addReplayFilter(ctx, function () {\n                        var offsetLeft = offset;\n                        return function () { return (--offsetLeft < 0); };\n                    });\n                }\n                return this;\n            },\n            limit: function (numRows) {\n                this._ctx.limit = Math.min(this._ctx.limit, numRows); // For count()\n                addReplayFilter(this._ctx, function () {\n                    var rowsLeft = numRows;\n                    return function (cursor, advance, resolve) {\n                        if (--rowsLeft <= 0)\n                            advance(resolve); // Stop after this item has been included\n                        return rowsLeft >= 0; // If numRows is already below 0, return false because then 0 was passed to numRows initially. Otherwise we wouldnt come here.\n                    };\n                }, true);\n                return this;\n            },\n            until: function (filterFunction, bIncludeStopEntry) {\n                addFilter(this._ctx, function (cursor, advance, resolve) {\n                    if (filterFunction(cursor.value)) {\n                        advance(resolve);\n                        return bIncludeStopEntry;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n                return this;\n            },\n            first: function (cb) {\n                return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n            },\n            last: function (cb) {\n                return this.reverse().first(cb);\n            },\n            filter: function (filterFunction) {\n                /// <param name=\"jsFunctionFilter\" type=\"Function\">function(val){return true/false}</param>\n                addFilter(this._ctx, function (cursor) {\n                    return filterFunction(cursor.value);\n                });\n                // match filters not used in Dexie.js but can be used by 3rd part libraries to test a\n                // collection for a match without querying DB. Used by Dexie.Observable.\n                addMatchFilter(this._ctx, filterFunction);\n                return this;\n            },\n            and: function (filterFunction) {\n                return this.filter(filterFunction);\n            },\n            or: function (indexName) {\n                return new WhereClause(this._ctx.table, indexName, this);\n            },\n            reverse: function () {\n                this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n                if (this._ondirectionchange)\n                    this._ondirectionchange(this._ctx.dir);\n                return this;\n            },\n            desc: function () {\n                return this.reverse();\n            },\n            eachKey: function (cb) {\n                var ctx = this._ctx;\n                ctx.keysOnly = !ctx.isMatch;\n                return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n            },\n            eachUniqueKey: function (cb) {\n                this._ctx.unique = \"unique\";\n                return this.eachKey(cb);\n            },\n            eachPrimaryKey: function (cb) {\n                var ctx = this._ctx;\n                ctx.keysOnly = !ctx.isMatch;\n                return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n            },\n            keys: function (cb) {\n                var ctx = this._ctx;\n                ctx.keysOnly = !ctx.isMatch;\n                var a = [];\n                return this.each(function (item, cursor) {\n                    a.push(cursor.key);\n                }).then(function () {\n                    return a;\n                }).then(cb);\n            },\n            primaryKeys: function (cb) {\n                var ctx = this._ctx;\n                if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                    // Special optimation if we could use IDBObjectStore.getAllKeys() or\n                    // IDBKeyRange.getAllKeys():\n                    return this._read(function (resolve, reject, idbstore) {\n                        var idxOrStore = getIndexOrStore(ctx, idbstore);\n                        var req = ctx.limit < Infinity ?\n                            idxOrStore.getAllKeys(ctx.range, ctx.limit) :\n                            idxOrStore.getAllKeys(ctx.range);\n                        req.onerror = eventRejectHandler(reject);\n                        req.onsuccess = eventSuccessHandler(resolve);\n                    }).then(cb);\n                }\n                ctx.keysOnly = !ctx.isMatch;\n                var a = [];\n                return this.each(function (item, cursor) {\n                    a.push(cursor.primaryKey);\n                }).then(function () {\n                    return a;\n                }).then(cb);\n            },\n            uniqueKeys: function (cb) {\n                this._ctx.unique = \"unique\";\n                return this.keys(cb);\n            },\n            firstKey: function (cb) {\n                return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n            },\n            lastKey: function (cb) {\n                return this.reverse().firstKey(cb);\n            },\n            distinct: function () {\n                var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n                if (!idx || !idx.multi)\n                    return this; // distinct() only makes differencies on multiEntry indexes.\n                var set = {};\n                addFilter(this._ctx, function (cursor) {\n                    var strKey = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string\n                    var found = hasOwn(set, strKey);\n                    set[strKey] = true;\n                    return !found;\n                });\n                return this;\n            },\n            //\n            // Methods that mutate storage\n            //\n            modify: function (changes) {\n                var self = this, ctx = this._ctx, hook = ctx.table.hook, updatingHook = hook.updating.fire, deletingHook = hook.deleting.fire;\n                return this._write(function (resolve, reject, idbstore, trans) {\n                    var modifyer;\n                    if (typeof changes === 'function') {\n                        // Changes is a function that may update, add or delete propterties or even require a deletion the object itself (delete this.item)\n                        if (updatingHook === nop && deletingHook === nop) {\n                            // Noone cares about what is being changed. Just let the modifier function be the given argument as is.\n                            modifyer = changes;\n                        }\n                        else {\n                            // People want to know exactly what is being modified or deleted.\n                            // Let modifyer be a proxy function that finds out what changes the caller is actually doing\n                            // and call the hooks accordingly!\n                            modifyer = function (item) {\n                                var origItem = deepClone(item); // Clone the item first so we can compare laters.\n                                if (changes.call(this, item, this) === false)\n                                    return false; // Call the real modifyer function (If it returns false explicitely, it means it dont want to modify anyting on this object)\n                                if (!hasOwn(this, \"value\")) {\n                                    // The real modifyer function requests a deletion of the object. Inform the deletingHook that a deletion is taking place.\n                                    deletingHook.call(this, this.primKey, item, trans);\n                                }\n                                else {\n                                    // No deletion. Check what was changed\n                                    var objectDiff = getObjectDiff(origItem, this.value);\n                                    var additionalChanges = updatingHook.call(this, objectDiff, this.primKey, origItem, trans);\n                                    if (additionalChanges) {\n                                        // Hook want to apply additional modifications. Make sure to fullfill the will of the hook.\n                                        item = this.value;\n                                        keys(additionalChanges).forEach(function (keyPath) {\n                                            setByKeyPath(item, keyPath, additionalChanges[keyPath]); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath\n                                        });\n                                    }\n                                }\n                            };\n                        }\n                    }\n                    else if (updatingHook === nop) {\n                        // changes is a set of {keyPath: value} and no one is listening to the updating hook.\n                        var keyPaths = keys(changes);\n                        var numKeys = keyPaths.length;\n                        modifyer = function (item) {\n                            var anythingModified = false;\n                            for (var i = 0; i < numKeys; ++i) {\n                                var keyPath = keyPaths[i], val = changes[keyPath];\n                                if (getByKeyPath(item, keyPath) !== val) {\n                                    setByKeyPath(item, keyPath, val); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath\n                                    anythingModified = true;\n                                }\n                            }\n                            return anythingModified;\n                        };\n                    }\n                    else {\n                        // changes is a set of {keyPath: value} and people are listening to the updating hook so we need to call it and\n                        // allow it to add additional modifications to make.\n                        var origChanges = changes;\n                        changes = shallowClone(origChanges); // Let's work with a clone of the changes keyPath/value set so that we can restore it in case a hook extends it.\n                        modifyer = function (item) {\n                            var anythingModified = false;\n                            var additionalChanges = updatingHook.call(this, changes, this.primKey, deepClone(item), trans);\n                            if (additionalChanges)\n                                extend(changes, additionalChanges);\n                            keys(changes).forEach(function (keyPath) {\n                                var val = changes[keyPath];\n                                if (getByKeyPath(item, keyPath) !== val) {\n                                    setByKeyPath(item, keyPath, val);\n                                    anythingModified = true;\n                                }\n                            });\n                            if (additionalChanges)\n                                changes = shallowClone(origChanges); // Restore original changes for next iteration\n                            return anythingModified;\n                        };\n                    }\n                    var count = 0;\n                    var successCount = 0;\n                    var iterationComplete = false;\n                    var failures = [];\n                    var failKeys = [];\n                    var currentKey = null;\n                    function modifyItem(item, cursor) {\n                        currentKey = cursor.primaryKey;\n                        var thisContext = {\n                            primKey: cursor.primaryKey,\n                            value: item,\n                            onsuccess: null,\n                            onerror: null\n                        };\n                        function onerror(e) {\n                            failures.push(e);\n                            failKeys.push(thisContext.primKey);\n                            checkFinished();\n                            return true; // Catch these errors and let a final rejection decide whether or not to abort entire transaction\n                        }\n                        if (modifyer.call(thisContext, item, thisContext) !== false) {\n                            var bDelete = !hasOwn(thisContext, \"value\");\n                            ++count;\n                            tryCatch(function () {\n                                var req = (bDelete ? cursor.delete() : cursor.update(thisContext.value));\n                                req._hookCtx = thisContext;\n                                req.onerror = hookedEventRejectHandler(onerror);\n                                req.onsuccess = hookedEventSuccessHandler(function () {\n                                    ++successCount;\n                                    checkFinished();\n                                });\n                            }, onerror);\n                        }\n                        else if (thisContext.onsuccess) {\n                            // Hook will expect either onerror or onsuccess to always be called!\n                            thisContext.onsuccess(thisContext.value);\n                        }\n                    }\n                    function doReject(e) {\n                        if (e) {\n                            failures.push(e);\n                            failKeys.push(currentKey);\n                        }\n                        return reject(new ModifyError(\"Error modifying one or more objects\", failures, successCount, failKeys));\n                    }\n                    function checkFinished() {\n                        if (iterationComplete && successCount + failures.length === count) {\n                            if (failures.length > 0)\n                                doReject();\n                            else\n                                resolve(successCount);\n                        }\n                    }\n                    self.clone().raw()._iterate(modifyItem, function () {\n                        iterationComplete = true;\n                        checkFinished();\n                    }, doReject, idbstore);\n                });\n            },\n            'delete': function () {\n                var _this = this;\n                var ctx = this._ctx, range = ctx.range, deletingHook = ctx.table.hook.deleting.fire, hasDeleteHook = deletingHook !== nop;\n                if (!hasDeleteHook &&\n                    isPlainKeyRange(ctx) &&\n                    ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || !range)) {\n                    // May use IDBObjectStore.delete(IDBKeyRange) in this case (Issue #208)\n                    // For chromium, this is the way most optimized version.\n                    // For IE/Edge, this could hang the indexedDB engine and make operating system instable\n                    // (https://gist.github.com/dfahlander/5a39328f029de18222cf2125d56c38f7)\n                    return this._write(function (resolve, reject, idbstore) {\n                        // Our API contract is to return a count of deleted items, so we have to count() before delete().\n                        var onerror = eventRejectHandler(reject), countReq = (range ? idbstore.count(range) : idbstore.count());\n                        countReq.onerror = onerror;\n                        countReq.onsuccess = function () {\n                            var count = countReq.result;\n                            tryCatch(function () {\n                                var delReq = (range ? idbstore.delete(range) : idbstore.clear());\n                                delReq.onerror = onerror;\n                                delReq.onsuccess = function () { return resolve(count); };\n                            }, function (err) { return reject(err); });\n                        };\n                    });\n                }\n                // Default version to use when collection is not a vanilla IDBKeyRange on the primary key.\n                // Divide into chunks to not starve RAM.\n                // If has delete hook, we will have to collect not just keys but also objects, so it will use\n                // more memory and need lower chunk size.\n                var CHUNKSIZE = hasDeleteHook ? 2000 : 10000;\n                return this._write(function (resolve, reject, idbstore, trans) {\n                    var totalCount = 0;\n                    // Clone collection and change its table and set a limit of CHUNKSIZE on the cloned Collection instance.\n                    var collection = _this\n                        .clone({\n                        keysOnly: !ctx.isMatch && !hasDeleteHook\n                    }) // load just keys (unless filter() or and() or deleteHook has subscribers)\n                        .distinct() // In case multiEntry is used, never delete same key twice because resulting count\n                        .limit(CHUNKSIZE)\n                        .raw(); // Don't filter through reading-hooks (like mapped classes etc)\n                    var keysOrTuples = [];\n                    // We're gonna do things on as many chunks that are needed.\n                    // Use recursion of nextChunk function:\n                    var nextChunk = function () { return collection.each(hasDeleteHook ? function (val, cursor) {\n                        // Somebody subscribes to hook('deleting'). Collect all primary keys and their values,\n                        // so that the hook can be called with its values in bulkDelete().\n                        keysOrTuples.push([cursor.primaryKey, cursor.value]);\n                    } : function (val, cursor) {\n                        // No one subscribes to hook('deleting'). Collect only primary keys:\n                        keysOrTuples.push(cursor.primaryKey);\n                    }).then(function () {\n                        // Chromium deletes faster when doing it in sort order.\n                        hasDeleteHook ?\n                            keysOrTuples.sort(function (a, b) { return ascending(a[0], b[0]); }) :\n                            keysOrTuples.sort(ascending);\n                        return bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook);\n                    }).then(function () {\n                        var count = keysOrTuples.length;\n                        totalCount += count;\n                        keysOrTuples = [];\n                        return count < CHUNKSIZE ? totalCount : nextChunk();\n                    }); };\n                    resolve(nextChunk());\n                });\n            }\n        };\n    });\n    //\n    //\n    //\n    // ------------------------- Help functions ---------------------------\n    //\n    //\n    //\n    function lowerVersionFirst(a, b) {\n        return a._cfg.version - b._cfg.version;\n    }\n    function setApiOnPlace(objs, tableNames, dbschema) {\n        tableNames.forEach(function (tableName) {\n            var schema = dbschema[tableName];\n            objs.forEach(function (obj) {\n                if (!(tableName in obj)) {\n                    if (obj === Transaction.prototype || obj instanceof Transaction) {\n                        // obj is a Transaction prototype (or prototype of a subclass to Transaction)\n                        // Make the API a getter that returns this.table(tableName)\n                        setProp(obj, tableName, { get: function () { return this.table(tableName); } });\n                    }\n                    else {\n                        // Table will not be bound to a transaction (will use Dexie.currentTransaction)\n                        obj[tableName] = new Table(tableName, schema);\n                    }\n                }\n            });\n        });\n    }\n    function removeTablesApi(objs) {\n        objs.forEach(function (obj) {\n            for (var key in obj) {\n                if (obj[key] instanceof Table)\n                    delete obj[key];\n            }\n        });\n    }\n    function iterate(req, filter, fn, resolve, reject, valueMapper) {\n        // Apply valueMapper (hook('reading') or mappped class)\n        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n        // Wrap fn with PSD and microtick stuff from Promise.\n        var wrappedFn = wrap(mappedFn, reject);\n        if (!req.onerror)\n            req.onerror = eventRejectHandler(reject);\n        if (filter) {\n            req.onsuccess = trycatcher(function filter_record() {\n                var cursor = req.result;\n                if (cursor) {\n                    var c = function () { cursor.continue(); };\n                    if (filter(cursor, function (advancer) { c = advancer; }, resolve, reject))\n                        wrappedFn(cursor.value, cursor, function (advancer) { c = advancer; });\n                    c();\n                }\n                else {\n                    resolve();\n                }\n            }, reject);\n        }\n        else {\n            req.onsuccess = trycatcher(function filter_record() {\n                var cursor = req.result;\n                if (cursor) {\n                    var c = function () { cursor.continue(); };\n                    wrappedFn(cursor.value, cursor, function (advancer) { c = advancer; });\n                    c();\n                }\n                else {\n                    resolve();\n                }\n            }, reject);\n        }\n    }\n    function parseIndexSyntax(indexes) {\n        /// <param name=\"indexes\" type=\"String\"></param>\n        /// <returns type=\"Array\" elementType=\"IndexSpec\"></returns>\n        var rv = [];\n        indexes.split(',').forEach(function (index) {\n            index = index.trim();\n            var name = index.replace(/([&*]|\\+\\+)/g, \"\"); // Remove \"&\", \"++\" and \"*\"\n            // Let keyPath of \"[a+b]\" be [\"a\",\"b\"]:\n            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n            rv.push(new IndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), /\\./.test(index)));\n        });\n        return rv;\n    }\n    function cmp(key1, key2) {\n        return indexedDB.cmp(key1, key2);\n    }\n    function min(a, b) {\n        return cmp(a, b) < 0 ? a : b;\n    }\n    function max(a, b) {\n        return cmp(a, b) > 0 ? a : b;\n    }\n    function ascending(a, b) {\n        return indexedDB.cmp(a, b);\n    }\n    function descending(a, b) {\n        return indexedDB.cmp(b, a);\n    }\n    function simpleCompare(a, b) {\n        return a < b ? -1 : a === b ? 0 : 1;\n    }\n    function simpleCompareReverse(a, b) {\n        return a > b ? -1 : a === b ? 0 : 1;\n    }\n    function combine(filter1, filter2) {\n        return filter1 ?\n            filter2 ?\n                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n                filter1 :\n            filter2;\n    }\n    function readGlobalSchema() {\n        db.verno = idbdb.version / 10;\n        db._dbSchema = globalSchema = {};\n        dbStoreNames = slice(idbdb.objectStoreNames, 0);\n        if (dbStoreNames.length === 0)\n            return; // Database contains no stores.\n        var trans = idbdb.transaction(safariMultiStoreFix(dbStoreNames), 'readonly');\n        dbStoreNames.forEach(function (storeName) {\n            var store = trans.objectStore(storeName), keyPath = store.keyPath, dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;\n            var primKey = new IndexSpec(keyPath, keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== 'string', dotted);\n            var indexes = [];\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var idbindex = store.index(store.indexNames[j]);\n                keyPath = idbindex.keyPath;\n                dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;\n                var index = new IndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== 'string', dotted);\n                indexes.push(index);\n            }\n            globalSchema[storeName] = new TableSchema(storeName, primKey, indexes, {});\n        });\n        setApiOnPlace([allTables], keys(globalSchema), globalSchema);\n    }\n    function adjustToExistingIndexNames(schema, idbtrans) {\n        /// <summary>\n        /// Issue #30 Problem with existing db - adjust to existing index names when migrating from non-dexie db\n        /// </summary>\n        /// <param name=\"schema\" type=\"Object\">Map between name and TableSchema</param>\n        /// <param name=\"idbtrans\" type=\"IDBTransaction\"></param>\n        var storeNames = idbtrans.db.objectStoreNames;\n        for (var i = 0; i < storeNames.length; ++i) {\n            var storeName = storeNames[i];\n            var store = idbtrans.objectStore(storeName);\n            hasGetAll = 'getAll' in store;\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var indexName = store.indexNames[j];\n                var keyPath = store.index(indexName).keyPath;\n                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n                if (schema[storeName]) {\n                    var indexSpec = schema[storeName].idxByName[dexieName];\n                    if (indexSpec)\n                        indexSpec.name = indexName;\n                }\n            }\n        }\n        // Bug with getAll() on Safari ver<604 on Workers only, see discussion following PR #579\n        if (/Safari/.test(navigator.userAgent) &&\n            !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n            [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n            hasGetAll = false;\n        }\n    }\n    function fireOnBlocked(ev) {\n        db.on(\"blocked\").fire(ev);\n        // Workaround (not fully*) for missing \"versionchange\" event in IE,Edge and Safari:\n        connections\n            .filter(function (c) { return c.name === db.name && c !== db && !c._vcFired; })\n            .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n    }\n    extend(this, {\n        Collection: Collection,\n        Table: Table,\n        Transaction: Transaction,\n        Version: Version,\n        WhereClause: WhereClause\n    });\n    init();\n    addons.forEach(function (fn) {\n        fn(db);\n    });\n}\nfunction parseType(type) {\n    if (typeof type === 'function') {\n        return new type();\n    }\n    else if (isArray(type)) {\n        return [parseType(type[0])];\n    }\n    else if (type && typeof type === 'object') {\n        var rv = {};\n        applyStructure(rv, type);\n        return rv;\n    }\n    else {\n        return type;\n    }\n}\nfunction applyStructure(obj, structure) {\n    keys(structure).forEach(function (member) {\n        var value = parseType(structure[member]);\n        obj[member] = value;\n    });\n    return obj;\n}\nfunction hookedEventSuccessHandler(resolve) {\n    // wrap() is needed when calling hooks because the rare scenario of:\n    //  * hook does a db operation that fails immediately (IDB throws exception)\n    //    For calling db operations on correct transaction, wrap makes sure to set PSD correctly.\n    //    wrap() will also execute in a virtual tick.\n    //  * If not wrapped in a virtual tick, direct exception will launch a new physical tick.\n    //  * If this was the last event in the bulk, the promise will resolve after a physical tick\n    //    and the transaction will have committed already.\n    // If no hook, the virtual tick will be executed in the reject()/resolve of the final promise,\n    // because it is always marked with _lib = true when created using Transaction._promise().\n    return wrap(function (event) {\n        var req = event.target, ctx = req._hookCtx, // Contains the hook error handler. Put here instead of closure to boost performance.\n        result = ctx.value || req.result, // Pass the object value on updates. The result from IDB is the primary key.\n        hookSuccessHandler = ctx && ctx.onsuccess;\n        hookSuccessHandler && hookSuccessHandler(result);\n        resolve && resolve(result);\n    }, resolve);\n}\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction eventSuccessHandler(resolve) {\n    return wrap(function (event) {\n        resolve(event.target.result);\n    });\n}\nfunction hookedEventRejectHandler(reject) {\n    return wrap(function (event) {\n        // See comment on hookedEventSuccessHandler() why wrap() is needed only when supporting hooks.\n        var req = event.target, err = req.error, ctx = req._hookCtx, // Contains the hook error handler. Put here instead of closure to boost performance.\n        hookErrorHandler = ctx && ctx.onerror;\n        hookErrorHandler && hookErrorHandler(err);\n        preventDefault(event);\n        reject(err);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\nfunction awaitIterator(iterator) {\n    var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return function (val) {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n//\n// IndexSpec struct\n//\nfunction IndexSpec(name, keyPath, unique, multi, auto, compound, dotted) {\n    /// <param name=\"name\" type=\"String\"></param>\n    /// <param name=\"keyPath\" type=\"String\"></param>\n    /// <param name=\"unique\" type=\"Boolean\"></param>\n    /// <param name=\"multi\" type=\"Boolean\"></param>\n    /// <param name=\"auto\" type=\"Boolean\"></param>\n    /// <param name=\"compound\" type=\"Boolean\"></param>\n    /// <param name=\"dotted\" type=\"Boolean\"></param>\n    this.name = name;\n    this.keyPath = keyPath;\n    this.unique = unique;\n    this.multi = multi;\n    this.auto = auto;\n    this.compound = compound;\n    this.dotted = dotted;\n    var keyPathSrc = typeof keyPath === 'string' ? keyPath : keyPath && ('[' + [].join.call(keyPath, '+') + ']');\n    this.src = (unique ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + keyPathSrc;\n}\n//\n// TableSchema struct\n//\nfunction TableSchema(name, primKey, indexes, instanceTemplate) {\n    /// <param name=\"name\" type=\"String\"></param>\n    /// <param name=\"primKey\" type=\"IndexSpec\"></param>\n    /// <param name=\"indexes\" type=\"Array\" elementType=\"IndexSpec\"></param>\n    /// <param name=\"instanceTemplate\" type=\"Object\"></param>\n    this.name = name;\n    this.primKey = primKey || new IndexSpec();\n    this.indexes = indexes || [new IndexSpec()];\n    this.instanceTemplate = instanceTemplate;\n    this.mappedClass = null;\n    this.idxByName = arrayToObject(indexes, function (index) { return [index.name, index]; });\n}\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nfunction getNativeGetDatabaseNamesFn(indexedDB) {\n    var fn = indexedDB && (indexedDB.getDatabaseNames || indexedDB.webkitGetDatabaseNames);\n    return fn && fn.bind(indexedDB);\n}\n// Export Error classes\nprops(Dexie, fullNameExceptions); // Dexie.XXXError = class XXXError {...};\n//\n// Static methods and properties\n// \nprops(Dexie, {\n    //\n    // Static delete() method.\n    //\n    delete: function (databaseName) {\n        var db = new Dexie(databaseName), promise = db.delete();\n        promise.onblocked = function (fn) {\n            db.on(\"blocked\", fn);\n            return this;\n        };\n        return promise;\n    },\n    //\n    // Static exists() method.\n    //\n    exists: function (name) {\n        return new Dexie(name).open().then(function (db) {\n            db.close();\n            return true;\n        }).catch(Dexie.NoSuchDatabaseError, function () { return false; });\n    },\n    //\n    // Static method for retrieving a list of all existing databases at current host.\n    //\n    getDatabaseNames: function (cb) {\n        var getDatabaseNames = getNativeGetDatabaseNamesFn(Dexie.dependencies.indexedDB);\n        return getDatabaseNames ? new Promise(function (resolve, reject) {\n            var req = getDatabaseNames();\n            req.onsuccess = function (event) {\n                resolve(slice(event.target.result, 0)); // Converst DOMStringList to Array<String>\n            };\n            req.onerror = eventRejectHandler(reject);\n        }).then(cb) : dbNamesDB.dbnames.toCollection().primaryKeys(cb);\n    },\n    defineClass: function () {\n        // Default constructor able to copy given properties into this object.\n        function Class(properties) {\n            /// <param name=\"properties\" type=\"Object\" optional=\"true\">Properties to initialize object with.\n            /// </param>\n            if (properties)\n                extend(this, properties);\n        }\n        return Class;\n    },\n    applyStructure: applyStructure,\n    ignoreTransaction: function (scopeFunc) {\n        // In case caller is within a transaction but needs to create a separate transaction.\n        // Example of usage:\n        //\n        // Let's say we have a logger function in our app. Other application-logic should be unaware of the\n        // logger function and not need to include the 'logentries' table in all transaction it performs.\n        // The logging should always be done in a separate transaction and not be dependant on the current\n        // running transaction context. Then you could use Dexie.ignoreTransaction() to run code that starts a new transaction.\n        //\n        //     Dexie.ignoreTransaction(function() {\n        //         db.logentries.add(newLogEntry);\n        //     });\n        //\n        // Unless using Dexie.ignoreTransaction(), the above example would try to reuse the current transaction\n        // in current Promise-scope.\n        //\n        // An alternative to Dexie.ignoreTransaction() would be setImmediate() or setTimeout(). The reason we still provide an\n        // API for this because\n        //  1) The intention of writing the statement could be unclear if using setImmediate() or setTimeout().\n        //  2) setTimeout() would wait unnescessary until firing. This is however not the case with setImmediate().\n        //  3) setImmediate() is not supported in the ES standard.\n        //  4) You might want to keep other PSD state that was set in a parent PSD, such as PSD.letThrough.\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) : // Use the closest parent that was non-transactional.\n            scopeFunc(); // No need to change scope because there is no ongoing transaction.\n    },\n    vip: function (fn) {\n        // To be used by subscribers to the on('ready') event.\n        // This will let caller through to access DB even when it is blocked while the db.ready() subscribers are firing.\n        // This would have worked automatically if we were certain that the Provider was using Dexie.Promise for all asyncronic operations. The promise PSD\n        // from the provider.connect() call would then be derived all the way to when provider would call localDatabase.applyChanges(). But since\n        // the provider more likely is using non-promise async APIs or other thenable implementations, we cannot assume that.\n        // Note that this method is only useful for on('ready') subscribers that is returning a Promise from the event. If not using vip()\n        // the database could deadlock since it wont open until the returned Promise is resolved, and any non-VIPed operation started by\n        // the caller will not resolve until database is opened.\n        return newScope(function () {\n            PSD.letThrough = true; // Make sure we are let through if still blocking db due to onready is firing.\n            return fn();\n        });\n    },\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return Promise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return Promise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    // Dexie.currentTransaction property\n    currentTransaction: {\n        get: function () { return PSD.trans || null; }\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        // If a function is provided, invoke it and pass the returning value to Transaction.waitFor()\n        var promise = Promise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction)\n            .timeout(optionalTimeout || 60000); // Default the timeout to one minute. Caller may specify Infinity if required.       \n        // Run given promise on current transaction. If no current transaction, just return a Dexie promise based\n        // on given value.\n        return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n    },\n    // Export our Promise implementation since it can be handy as a standalone Promise implementation\n    Promise: Promise,\n    // Dexie.debug proptery:\n    // Dexie.debug = false\n    // Dexie.debug = true\n    // Dexie.debug = \"dexie\" - don't hide dexie's stack frames.\n    debug: {\n        get: function () { return debug; },\n        set: function (value) {\n            setDebug(value, value === 'dexie' ? function () { return true; } : dexieStackFrameFilter);\n        }\n    },\n    // Export our derive/extend/override methodology\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    // Export our Events() function - can be handy as a toolkit\n    Events: Events,\n    // Utilities\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    asap: asap,\n    maxKey: maxKey,\n    minKey: minKey,\n    // Addon registry\n    addons: [],\n    // Global DB connection list\n    connections: connections,\n    MultiModifyError: exceptions.Modify,\n    errnames: errnames,\n    // Export other static classes\n    IndexSpec: IndexSpec,\n    TableSchema: TableSchema,\n    //\n    // Dependencies\n    //\n    // These will automatically work in browsers with indexedDB support, or where an indexedDB polyfill has been included.\n    //\n    // In node.js, however, these properties must be set \"manually\" before instansiating a new Dexie().\n    // For node.js, you need to require indexeddb-js or similar and then set these deps.\n    //\n    dependencies: (function () {\n        try {\n            return {\n                // Required:\n                indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n                IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n            };\n        }\n        catch (e) {\n            return {\n                indexedDB: null,\n                IDBKeyRange: null\n            };\n        }\n    })(),\n    // API Version Number: Type Number, make sure to always set a version number that can be comparable correctly. Example: 0.9, 0.91, 0.92, 1.0, 1.01, 1.1, 1.2, 1.21, etc.\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(function (n) { return parseInt(n); })\n        .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }),\n    // https://github.com/dfahlander/Dexie.js/issues/186\n    // typescript compiler tsc in mode ts-->es5 & commonJS, will expect require() to return\n    // x.default. Workaround: Set Dexie.default = Dexie.\n    default: Dexie,\n    // Make it possible to import {Dexie} (non-default import)\n    // Reason 1: May switch to that in future.\n    // Reason 2: We declare it both default and named exported in d.ts to make it possible\n    // to let addons extend the Dexie interface with Typescript 2.1 (works only when explicitely\n    // exporting the symbol, not just default exporting)\n    Dexie: Dexie\n});\n// Map DOMErrors and DOMExceptions to corresponding Dexie errors. May change in Dexie v2.0.\nPromise.rejectionMapper = mapError;\n// Initialize dbNamesDB (won't ever be opened on chromium browsers')\ndbNamesDB = new Dexie('__dbnames');\ndbNamesDB.version(1).stores({ dbnames: 'name' });\n(function () {\n    // Migrate from Dexie 1.x database names stored in localStorage:\n    var DBNAMES = 'Dexie.DatabaseNames';\n    try {\n        if (typeof localStorage !== undefined && _global.document !== undefined) {\n            // Have localStorage and is not executing in a worker. Lets migrate from Dexie 1.x.\n            JSON.parse(localStorage.getItem(DBNAMES) || \"[]\")\n                .forEach(function (name) { return dbNamesDB.dbnames.put({ name: name }).catch(nop); });\n            localStorage.removeItem(DBNAMES);\n        }\n    }\n    catch (_e) { }\n})();\n\nreturn Dexie;\n\n})));\n//# sourceMappingURL=dexie.js.map\n","import { CacheModel } from \"./cache.models\";\r\n\r\nexport interface ICacheConfigService {\r\n    enableLogs: boolean;\r\n    models: CacheModel[];\r\n    prefix: string;\r\n}\r\n\r\nexport class CacheConfigService implements ICacheConfigService {\r\n    constructor(\r\n        public enableLogs: boolean,\r\n        public models: CacheModel[],\r\n        public prefix: string\r\n    ) { }\r\n}\r\n\r\nexport interface ICacheConfigProvider {\r\n    enableLogs: boolean;\r\n    models: CacheModel[];\r\n    prefix: string;\r\n}\r\n\r\nclass CacheConfigProvider implements ICacheConfigProvider, ng.IServiceProvider {\r\n\r\n    private _service: CacheConfigService;\r\n\r\n    enableLogs: boolean = false;\r\n    models: CacheModel[] = [];\r\n    prefix: string = 'PipCache';\r\n\r\n    constructor() {\r\n        \"ngInject\";\r\n    }\r\n\r\n    public $get() {\r\n        \"ngInject\";\r\n\r\n        if (this._service == null) {\r\n            this._service = new CacheConfigService(\r\n                this.enableLogs,\r\n                this.models,\r\n                this.prefix\r\n            );\r\n        }\r\n\r\n        return this._service;\r\n    }\r\n\r\n}\r\n\r\nangular\r\n    .module(\"pipCache\")\r\n    .provider('pipCacheConfig', CacheConfigProvider);","import { ICacheService } from \"./cache.service\";\r\nimport { CacheCollectionParams } from \"./cache.models\";\r\n\r\nfunction configureInterceptor(\r\n    $httpProvider: ng.IHttpProvider\r\n) {\r\n    \"ngInject\";\r\n\r\n    $httpProvider.interceptors.push(function ($q: ng.IQService, pipCache: ICacheService) {\r\n        const getDefaultParams = function (params: any): CacheCollectionParams {\r\n            const ret: CacheCollectionParams = {};\r\n            if (params) {\r\n                if (params.hasOwnProperty('offset')) { ret.offset = parseInt(params.offset, 10); }\r\n                if (params.hasOwnProperty('limit')) { ret.limit = parseInt(params.limit, 10); }\r\n            }\r\n            return ret;\r\n        };\r\n        return {\r\n            request: (config: ng.IRequestConfig) => {\r\n                for (const model of pipCache.models) {\r\n                    for (const ik of Object.keys(model.interceptors)) {\r\n                        const interceptor = model.interceptors[ik];\r\n                        const match = interceptor.match.exec(config.url);\r\n                        if (match) {\r\n                            switch (config.method) {\r\n                                case 'GET':\r\n                                    switch (ik) {\r\n                                        case 'item':\r\n                                            const { groups } = match;\r\n                                            return pipCache.getItem(model.name, interceptor.getKey(groups), interceptor.options)\r\n                                                .then(item => {\r\n                                                    if (!item) {\r\n                                                        (config as any).onResponse = (body) => {\r\n                                                            pipCache.setItem(model.name, body, interceptor.options);\r\n                                                        };\r\n                                                        return config;\r\n                                                    } else {\r\n                                                        config.timeout = $q.defer().promise;\r\n                                                        return $q.reject({ cachedData: item });\r\n                                                    }\r\n                                                });\r\n                                        case 'collection':\r\n                                            const params = interceptor.getParams ? interceptor.getParams(config.params) : getDefaultParams(config.params);\r\n                                            return pipCache.getItems(model.name, params, interceptor.options)\r\n                                                .then(items => {\r\n                                                    if (!items) {\r\n                                                        (config as any).onResponse = (body) => {\r\n                                                            const its = interceptor.responseModify\r\n                                                                ? interceptor.responseModify.responseToItems(body) : body;\r\n                                                            pipCache.setItems(model.name, its,\r\n                                                                { params, options: interceptor.options });\r\n                                                        };\r\n                                                        return config;\r\n                                                    } else {\r\n                                                        config.timeout = $q.defer().promise;\r\n                                                        const resp = interceptor.responseModify\r\n                                                            ? interceptor.responseModify.itemsToResponse(items) : items;\r\n                                                        return $q.reject({ cachedData: resp });\r\n                                                    }\r\n                                                });\r\n                                        default:\r\n                                            console.error(`Unknown type of interceptor (${ik})`);\r\n                                            break;\r\n                                    }\r\n                                case 'POST':\r\n                                case 'PUT':\r\n                                    switch (ik) {\r\n                                        case 'item':\r\n                                        case 'collection':\r\n                                            (config as any).onResponse = (body) => {\r\n                                                pipCache.setItem(model.name, body, { removeTotal: config.method === 'POST' });\r\n                                            };\r\n                                            break;\r\n                                        default:\r\n                                            break;\r\n                                    }\r\n                                case 'DELETE':\r\n                                    switch (ik) {\r\n                                        case 'item':\r\n                                            const { groups } = match;\r\n                                            (config as any).onResponse = (body) => {\r\n                                                pipCache.deleteItems(model.name, [interceptor.getKey(groups)]);\r\n                                            };\r\n                                            break;\r\n                                        default:\r\n                                            break;\r\n                                    }\r\n                                default:\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return config;\r\n            },\r\n            response: <T>(response: ng.IHttpPromiseCallbackArg<T>) => {\r\n                if (response.config.hasOwnProperty('onResponse') && typeof (response.config as any).onResponse === 'function') {\r\n                    (response.config as any).onResponse(response.data);\r\n                }\r\n                return response;\r\n            },\r\n            responseError: function (rejection) {\r\n                if (rejection && rejection.cachedData) {\r\n                    return $q.resolve({ data: rejection.cachedData });\r\n                }\r\n                return $q.reject(rejection);\r\n            }\r\n        } as ng.IHttpInterceptor;\r\n    });\r\n}\r\n\r\nangular\r\n    .module('pipCache')\r\n    .config(configureInterceptor);","export class CacheCollectionParams {\r\n    offset?: number;\r\n    limit?: number;\r\n}\r\n\r\nexport class CacheInterceptorOptions {\r\n    maxAge?: number;\r\n}\r\n\r\nexport class CacheModel {\r\n    name: string;\r\n    options: {\r\n        maxAge: number;\r\n        key?: string;\r\n    };\r\n    interceptors: {\r\n        item?: {\r\n            match: RegExp;\r\n            options?: CacheInterceptorOptions;\r\n            getKey: (groups: any) => any;\r\n        };\r\n        collection?: {\r\n            match: RegExp;\r\n            options?: CacheInterceptorOptions;\r\n            responseModify?: {\r\n                responseToItems: (resp: any) => any[];\r\n                itemsToResponse: (items: any[]) => any;\r\n            }\r\n            getParams?: (params: any) => CacheCollectionParams;\r\n        };\r\n    };\r\n}\r\n","import { CacheInterceptorOptions, CacheCollectionParams, CacheModel } from './cache.models';\r\nimport { ICacheConfigProvider } from './cache-config.service';\r\nimport * as Dexie from 'dexie';\r\n\r\nexport interface ICacheService {\r\n    models: CacheModel[];\r\n    getItem(modelName: string, key: any, options?: CacheInterceptorOptions): Promise<any>;\r\n    getItems(modelName: string, params?: CacheCollectionParams, options?: CacheInterceptorOptions): Promise<any[]>;\r\n    setItem(modelName: string, item: any, options?: { removeTotal?: boolean }): Promise<any>;\r\n    setItems(modelName: string, items: any[], payload?: {\r\n        params?: CacheCollectionParams, options?: CacheInterceptorOptions\r\n    }): Promise<any[]>\r\n    deleteItems(modelName: string, keys: any[]): Promise<any>;\r\n    clear(model?: string | string[]): Promise<any>;\r\n}\r\n\r\nexport class CacheService implements ICacheService {\r\n\r\n    private openedDbs = new Map<string, Dexie.Dexie>();\r\n\r\n    constructor(private config: ICacheConfigProvider) { }\r\n\r\n    private getDbName(modelName: string): string {\r\n        if (!modelName) { throw new Error('Model name should be defined'); }\r\n        return this.config.prefix + modelName.charAt(0).toUpperCase() + modelName.slice(1);\r\n    }\r\n\r\n    private getDb(model: CacheModel): Dexie.Dexie {\r\n        if (!model || !model.name) { throw new Error('Model should be defined'); }\r\n        const dbName = this.getDbName(model.name);\r\n        if (this.openedDbs.has(dbName)) { return this.openedDbs.get(dbName); }\r\n        const db = new Dexie.Dexie(dbName);\r\n        const modelKey = model.options.key || 'id';\r\n        db.version(1).stores({\r\n            items: modelKey,\r\n            lastRead: '',\r\n            indexes: 'idx,' + modelKey,\r\n            meta: ''\r\n        });\r\n        this.openedDbs.set(dbName, db);\r\n        return db;\r\n    }\r\n\r\n    private getModel(modelName: string): CacheModel {\r\n        return this.models.find(m => m.name === modelName);\r\n    }\r\n\r\n    public get models(): CacheModel[] { return this.config.models || []; }\r\n\r\n    async getItem(modelName: string, key: any, options?: CacheInterceptorOptions): Promise<any> {\r\n        const model = this.getModel(modelName);\r\n        const db = this.getDb(model);\r\n        const [expire, item] = await Promise.all([\r\n            db.table('lastRead').get(key),\r\n            db.table('items').get(key)\r\n        ]);\r\n        const maxAge = options && options.maxAge || model.options.maxAge;\r\n        const expired = expire + maxAge <= new Date().valueOf();\r\n        if (this.config.enableLogs) {\r\n            console.groupCollapsed('[PipCache] GET single item #' + key);\r\n            console.log('Item: ', item);\r\n            console.log('Expired: ', expired);\r\n            console.log('Expired at: ', new Date(expire));\r\n            console.groupEnd();\r\n        }\r\n        return expired ? null : item;\r\n    }\r\n    async getItems(modelName: string, params?: CacheCollectionParams, options?: CacheInterceptorOptions): Promise<any[]> {\r\n        const model = this.getModel(modelName);\r\n        const db = this.getDb(model);\r\n        const modelKey = model.options.key || 'id';\r\n        // get indexes of items we should receive\r\n        const totalDetails: { total: number, lastRead: number } = await db.table('meta').get('total');\r\n        const maxAge = options && options.maxAge || model.options.maxAge;\r\n        const total = totalDetails && (totalDetails.lastRead + maxAge >= new Date().valueOf())\r\n            ? totalDetails.total : undefined;\r\n        if (this.config.enableLogs) {\r\n            console.groupCollapsed('[PipCache] GET collection of items');\r\n            console.log('Params: ', params);\r\n        }\r\n        if (params && Object.keys(params).length) {\r\n            // If we have some limitations we have to get ids of items and then items\r\n            const offset = params.hasOwnProperty('offset') ? params.offset : 0;\r\n            const limit = params.hasOwnProperty('limit') ? params.limit : undefined;\r\n            if (limit !== undefined) {\r\n                // This is the only case where we don't need to know about total items count\r\n                const indexes = await db.table('indexes').where('idx').between(offset, offset + limit, true, false).toArray();\r\n                if (indexes.length !== limit && (total === undefined || indexes.length !== total - offset)) {\r\n                    if (this.config.enableLogs) {\r\n                        console.log('There\\'s not enough information about indexes');\r\n                        console.groupEnd();\r\n                    }\r\n                    return null;\r\n                } else {\r\n                    const ids = indexes.map(idx => idx.id);\r\n                    const [items, reads] = await Promise.all([\r\n                        db.table('items').where(modelKey).anyOf(ids).toArray(),\r\n                        db.table('lastRead').where('').anyOf(ids).toArray()\r\n                    ]);\r\n                    if (!items || items.length !== indexes.length || !reads || reads.length !== indexes.length) {\r\n                        if (this.config.enableLogs) {\r\n                            console.warn('Not all items presented in cache');\r\n                            console.groupEnd();\r\n                        }\r\n                        return null;\r\n                    }\r\n                    if (Math.min(...reads) + maxAge <= new Date().valueOf()) {\r\n                        if (this.config.enableLogs) {\r\n                            console.log('Items was expired');\r\n                            console.groupEnd();\r\n                        }\r\n                        return null;\r\n                    }\r\n                    if (this.config.enableLogs) {\r\n                        console.log('Items: ', items);\r\n                        console.groupEnd();\r\n                    }\r\n                    return items;\r\n                }\r\n            } else if (total !== undefined) {\r\n                // In this case we should check is total count of items presented\r\n                const indexes = await db.table('indexes').where('idx').aboveOrEqual(offset).toArray();\r\n                if (indexes.length !== limit || indexes.length !== total - offset) {\r\n                    if (this.config.enableLogs) {\r\n                        console.log('Not all items presented in cache');\r\n                        console.groupEnd();\r\n                    }\r\n                    return null;\r\n                }\r\n                const ids = indexes.map(idx => idx.id);\r\n                const [items, reads] = await Promise.all([\r\n                    db.table('items').where(modelKey).anyOf(ids).toArray(),\r\n                    db.table('lastRead').where(modelKey).anyOf(ids).toArray()\r\n                ]);\r\n                if (!items || items.length !== indexes.length || !reads || reads.length !== indexes.length) {\r\n                    if (this.config.enableLogs) {\r\n                        console.log('Not all items presented in cache');\r\n                        console.groupEnd();\r\n                    }\r\n                    return null;\r\n                }\r\n                if (Math.min(...reads) + maxAge >= new Date().valueOf()) {\r\n                    if (this.config.enableLogs) {\r\n                        console.log('Items was expired');\r\n                        console.groupEnd();\r\n                    }\r\n                    return null;\r\n                }\r\n                if (this.config.enableLogs) {\r\n                    console.log('Items: ', items);\r\n                    console.groupEnd();\r\n                }\r\n                return items;\r\n            }\r\n        } else if (total !== undefined) {\r\n            // If there is no limitations we have to return all items if they're all presented\r\n            const [items, reads] = await Promise.all([\r\n                db.table('items').toArray(),\r\n                db.table('lastRead').toArray()\r\n            ]);\r\n            if (!items || items.length !== total || !reads || reads.length !== total) {\r\n                if (this.config.enableLogs) {\r\n                    console.log('Not all items presented in cache');\r\n                    console.groupEnd();\r\n                }\r\n                return null;\r\n            }\r\n            if (Math.min(...reads) + maxAge <= new Date().valueOf()) {\r\n                if (this.config.enableLogs) {\r\n                    console.log('Items was expired');\r\n                    console.groupEnd();\r\n                }\r\n                return null;\r\n            }\r\n            if (this.config.enableLogs) {\r\n                console.log('Items: ', items);\r\n                console.groupEnd();\r\n            }\r\n            return items;\r\n        } else {\r\n            if (this.config.enableLogs) {\r\n                console.log('We want to return all items, but we don\\'t know how many they are');\r\n                console.groupEnd();\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    async setItem(modelName: string, item: any, options?: { removeTotal?: boolean; }): Promise<any> {\r\n        const model = this.getModel(modelName);\r\n        const db = this.getDb(model);\r\n        const [expire, it] = await Promise.all([\r\n            db.table('lastRead').put(new Date().valueOf(), item[model.options.key]),\r\n            db.table('items').put(item)\r\n        ]);\r\n        if (options) {\r\n            if (options.removeTotal) {\r\n                await db.table('meta').delete('total');\r\n            }\r\n        }\r\n        if (this.config.enableLogs) {\r\n            console.groupCollapsed('[PipCache] SET single item #' + item[model.options.key]);\r\n            console.log('Item: ', it);\r\n            console.log('Readed at: ', new Date());\r\n            console.groupEnd();\r\n        }\r\n        return it;\r\n    }\r\n    async setItems(modelName: string, items: any[], payload?:\r\n        { params?: CacheCollectionParams; options?: CacheInterceptorOptions; }): Promise<any[]> {\r\n        const model = this.getModel(modelName);\r\n        const modelKey = model.options.key || 'id';\r\n        const db = this.getDb(model);\r\n        const lr = new Date().valueOf();\r\n        const offset = payload && payload.params && payload.params.offset || 0;\r\n        const ids = items.map(it => it[modelKey]);\r\n        const indexes = ids.map((id, idx) => ({ id, idx: idx + offset }));\r\n        const promises = [\r\n            db.table('lastRead').bulkPut(new Array(items.length).fill(lr), ids),\r\n            db.table('items').bulkPut(items),\r\n            db.table('indexes').bulkPut(indexes)\r\n        ];\r\n        let total;\r\n        if ((payload && payload.params && payload.params.limit && items && items.length < payload.params.limit)\r\n            || (!payload || !payload.params || !Object.keys(payload.params).length)) {\r\n            total = (payload.params.offset || 0) + items.length;\r\n            promises.push(db.table('meta').put({ lastRead: new Date().valueOf(), total }, 'total'));\r\n        }\r\n        return Promise.all(promises).then(([args]) => {\r\n            if (this.config.enableLogs) {\r\n                console.groupCollapsed('[PipCache] SET collection of items');\r\n                console.log('Params: ', payload.params);\r\n                console.log('Items: ', items);\r\n                console.log('Last read at: ', new Date());\r\n                if (args && args.length === 2) {\r\n                    console.log('New total: ', total);\r\n                }\r\n                console.groupEnd();\r\n            }\r\n            return items;\r\n        });\r\n    }\r\n    async deleteItems(modelName: string, keys: any[]): Promise<any> {\r\n        const model = this.getModel(modelName);\r\n        const db = this.getDb(model);\r\n        const modelKey = model.options.key || 'id';\r\n        return Promise.all([\r\n            db.table('lastRead').bulkDelete(keys),\r\n            db.table('items').bulkDelete(keys),\r\n            db.table('indexes').where(modelKey).anyOf(keys).delete(),\r\n            db.table('meta').delete('total')\r\n        ]).then(() => {\r\n            if (this.config.enableLogs) {\r\n                console.groupCollapsed('[PipCache] DELETE');\r\n                console.log('Keys: ', keys);\r\n                console.groupEnd();\r\n            }\r\n        });\r\n    }\r\n    async clear(model?: string | string[]): Promise<any> {\r\n        return new Promise(resolve => {\r\n            const dbs: string[] = [];\r\n            if (model) {\r\n                Array.isArray(model)\r\n                    ? dbs.push(...model.map(m => this.getDbName(m)))\r\n                    : dbs.push(this.getDbName(model));\r\n                resolve(dbs);\r\n            } else {\r\n                resolve(Dexie.Dexie.getDatabaseNames());\r\n            }\r\n        }).then((names: string[]) => {\r\n            const dbs = names.filter(name => name.startsWith(this.config.prefix));\r\n            if (this.config.enableLogs) {\r\n                console.log('databases to delete: ', names);\r\n            }\r\n            const promises = [];\r\n            for (const name of dbs) {\r\n                try {\r\n                    const db = this.openedDbs.has(name) ? this.openedDbs.get(name) : new Dexie.Dexie(name);\r\n                    promises.push(db.table('items').clear());\r\n                    promises.push(db.table('meta').clear());\r\n                    promises.push(db.table('lastRead').clear());\r\n                    promises.push(db.table('indexes').clear());\r\n                } catch (err) {\r\n                    if (this.config.enableLogs) {\r\n                        console.warn('Error opening database ' + name);\r\n                    }\r\n                }\r\n            }\r\n            return Promise.all(promises);\r\n        }).then(res => {\r\n            if (this.config.enableLogs) {\r\n                console.log('%c%s', 'color: blue; font: 1.2rem Impact;', '[PipCache] CLEAR');\r\n                if (model) { console.log('Model(s): ', model); } else { console.log('all models'); }\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n\r\n}\r\n\r\nexport interface ICacheProvider {\r\n    models: CacheModel[];\r\n    registerModel(model: CacheModel): boolean;\r\n}\r\n\r\nclass CacheProvider implements ICacheProvider {\r\n\r\n    private _service: ICacheService;\r\n\r\n    constructor(private pipCacheConfigProvider: ICacheConfigProvider) {\r\n        \"ngInject\";\r\n    }\r\n\r\n    public get models(): CacheModel[] { return this.pipCacheConfigProvider.models; }\r\n\r\n    public registerModel(model: CacheModel) {\r\n        if (!model) { return false; }\r\n        const res = this.models.find(m => m.name === model.name);\r\n        if (res) { return false; }\r\n        this.models.push(model);\r\n        return true;\r\n    }\r\n\r\n    public $get() {\r\n        \"ngInject\";\r\n\r\n        if (this._service == null) {\r\n            this._service = new CacheService(this.pipCacheConfigProvider);\r\n        }\r\n\r\n        return this._service;\r\n    }\r\n\r\n}\r\n\r\nangular\r\n    .module(\"pipCache\")\r\n    .provider('pipCache', CacheProvider);","angular.module('pipCache', []);\r\n\r\nimport './cache-config.service';\r\nimport './cache.service';\r\nimport './cache.interceptor';\r\n\r\nexport * from './cache.models';\r\nexport * from './cache-config.service';\r\nexport * from './cache.service';\r\n","﻿import './cache/index';\r\n\r\nexport * from './cache/index';\r\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvZGlzdC9kZXhpZS5qcyIsInNyYy9jYWNoZS9jYWNoZS1jb25maWcuc2VydmljZS50cyIsInNyYy9jYWNoZS9jYWNoZS5pbnRlcmNlcHRvci50cyIsInNyYy9jYWNoZS9jYWNoZS5tb2RlbHMudHMiLCJzcmMvY2FjaGUvY2FjaGUuc2VydmljZS50cyIsInNyYy9jYWNoZS9pbmRleC50cyIsInNyYy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixNQUFNLENBQUMsSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSw0QkFBSSxHQUFYO1FBQ0ksVUFBVSxDQUFDO1FBRVgsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDbEUsQ0FBQztRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFTCxvQkFBQztBQUFELENBNUJBLEFBNEJDLElBQUE7QUFFRCxPQUFPO0tBQ0YsTUFBTSxDQUFDLFVBQVUsQ0FBQztLQUNsQixRQUFRLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDOzs7Ozs7O0FDalZ6QyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUUvQixrQ0FBZ0M7QUFDaEMsMkJBQXlCO0FBQ3pCLCtCQUE2QjtBQUU3QixvQ0FBK0I7QUFDL0IsNENBQXVDO0FBQ3ZDLHFDQUFnQzs7Ozs7OztBQ1IvQix5QkFBdUI7QUFFeEIsbUNBQThCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gKiBEZXhpZS5qcyAtIGEgbWluaW1hbGlzdGljIHdyYXBwZXIgZm9yIEluZGV4ZWREQlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCeSBEYXZpZCBGYWhsYW5kZXIsIGRhdmlkLmZhaGxhbmRlckBnbWFpbC5jb21cbiAqXG4gKiBWZXJzaW9uIDIuMC40LCBGcmkgTWF5IDI1IDIwMThcbiAqXG4gKiBodHRwOi8vZGV4aWUub3JnXG4gKlxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuICovXG4gXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRGV4aWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgX2dsb2JhbCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcbiAgICAgICAgZ2xvYmFsO1xuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufVxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9oYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcbiAgICByZXR1cm4gX2hhc093bi5jYWxsKG9iaiwgcHJvcCk7XG59XG5mdW5jdGlvbiBwcm9wcyhwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc2V0UHJvcChwcm90bywga2V5LCBleHRlbnNpb25ba2V5XSk7XG4gICAgfSk7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5mdW5jdGlvbiBzZXRQcm9wKG9iaiwgcHJvcCwgZnVuY3Rpb25PckdldFNldCwgb3B0aW9ucykge1xuICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgZ2V0OiBmdW5jdGlvbk9yR2V0U2V0LmdldCwgc2V0OiBmdW5jdGlvbk9yR2V0U2V0LnNldCwgY29uZmlndXJhYmxlOiB0cnVlIH0gOlxuICAgICAgICB7IHZhbHVlOiBmdW5jdGlvbk9yR2V0U2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZShDaGlsZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGZ1bmN0aW9uIChQYXJlbnQpIHtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBzZXRQcm9wKENoaWxkLnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4dGVuZDogcHJvcHMuYmluZChudWxsLCBDaGlsZC5wcm90b3R5cGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgIHZhciBwZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApLCBwcm90bztcbiAgICByZXR1cm4gcGQgfHwgKHByb3RvID0gZ2V0UHJvdG8ob2JqKSkgJiYgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbn1cbnZhciBfc2xpY2UgPSBbXS5zbGljZTtcbmZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJncywgc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZShvcmlnRnVuYywgb3ZlcnJpZGVkRmFjdG9yeSkge1xuICAgIHJldHVybiBvdmVycmlkZWRGYWN0b3J5KG9yaWdGdW5jKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChiKSB7XG4gICAgaWYgKCFiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xufVxuZnVuY3Rpb24gYXNhcChmbikge1xuICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSlcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICBlbHNlXG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG4vKiogR2VuZXJhdGUgYW4gb2JqZWN0IChoYXNoIG1hcCkgYmFzZWQgb24gZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0gZXh0cmFjdG9yIEZ1bmN0aW9uIHRha2luZyBhbiBhcnJheSBpdGVtIGFuZCBpdHMgaW5kZXggYW5kIHJldHVybmluZyBhbiBhcnJheSBvZiAyIGl0ZW1zIChba2V5LCB2YWx1ZV0pIHRvXG4gKiAgICAgICAgaW5zdGVydCBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdCBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheS4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZVxuICogICAgICAgIGN1cnJlbnQgaXRlbSB3b250IGFmZmVjdCB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnJheSwgZXh0cmFjdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtLCBpKSB7XG4gICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgIGlmIChuYW1lQW5kVmFsdWUpXG4gICAgICAgICAgICByZXN1bHRbbmFtZUFuZFZhbHVlWzBdXSA9IG5hbWVBbmRWYWx1ZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiB0cnljYXRjaGVyKGZuLCByZWplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvbmVycm9yLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICBvbmVycm9yICYmIG9uZXJyb3IoZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREIvI3N0ZXBzLWZvci1leHRyYWN0aW5nLWEta2V5LWZyb20tYS12YWx1ZS11c2luZy1hLWtleS1wYXRoXG4gICAgaWYgKGhhc093bihvYmosIGtleVBhdGgpKVxuICAgICAgICByZXR1cm4gb2JqW2tleVBhdGhdOyAvLyBUaGlzIGxpbmUgaXMgbW92ZWQgZnJvbSBsYXN0IHRvIGZpcnN0IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZS5cbiAgICBpZiAoIWtleVBhdGgpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgcmV0dXJuIGlubmVyT2JqID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEtleVBhdGggPSBrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0tleVBhdGggPSBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdLZXlQYXRoID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9ialtjdXJyZW50S2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lck9iailcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSAob2JqW2N1cnJlbnRLZXlQYXRoXSA9IHt9KTtcbiAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaW5uZXJPYmosIHJlbWFpbmluZ0tleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbiAoa3ApIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtwLCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgICB2YXIgcnYgPSB7fTtcbiAgICBmb3IgKHZhciBtIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG4gICAgICAgICAgICBydlttXSA9IG9ialttXTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxudmFyIGNvbmNhdCA9IFtdLmNvbmNhdDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xufVxuLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtXG52YXIgaW50cmluc2ljVHlwZXMgPSBcIkJvb2xlYW4sU3RyaW5nLERhdGUsUmVnRXhwLEJsb2IsRmlsZSxGaWxlTGlzdCxBcnJheUJ1ZmZlcixEYXRhVmlldyxVaW50OENsYW1wZWRBcnJheSxJbWFnZURhdGEsTWFwLFNldFwiXG4gICAgLnNwbGl0KCcsJykuY29uY2F0KGZsYXR0ZW4oWzgsIDE2LCAzMiwgNjRdLm1hcChmdW5jdGlvbiAobnVtKSB7IHJldHVybiBbXCJJbnRcIiwgXCJVaW50XCIsIFwiRmxvYXRcIl0ubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICsgbnVtICsgXCJBcnJheVwiOyB9KTsgfSkpKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIF9nbG9iYWxbdF07IH0pLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2dsb2JhbFt0XTsgfSk7XG5mdW5jdGlvbiBkZWVwQ2xvbmUoYW55KSB7XG4gICAgaWYgKCFhbnkgfHwgdHlwZW9mIGFueSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBhbnk7XG4gICAgdmFyIHJ2O1xuICAgIGlmIChpc0FycmF5KGFueSkpIHtcbiAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbnkubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBydi5wdXNoKGRlZXBDbG9uZShhbnlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5pbmRleE9mKGFueS5jb25zdHJ1Y3RvcikgPj0gMCkge1xuICAgICAgICBydiA9IGFueTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJ2ID0gYW55LmNvbnN0cnVjdG9yID8gT2JqZWN0LmNyZWF0ZShhbnkuY29uc3RydWN0b3IucHJvdG90eXBlKSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFueSkge1xuICAgICAgICAgICAgaWYgKGhhc093bihhbnksIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBkZWVwQ2xvbmUoYW55W3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBnZXRPYmplY3REaWZmKGEsIGIsIHJ2LCBwcmZ4KSB7XG4gICAgLy8gQ29tcGFyZXMgb2JqZWN0cyBhIGFuZCBiIGFuZCBwcm9kdWNlcyBhIGRpZmYgb2JqZWN0LlxuICAgIHJ2ID0gcnYgfHwge307XG4gICAgcHJmeCA9IHByZnggfHwgJyc7XG4gICAga2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICghaGFzT3duKGIsIHByb3ApKVxuICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gdW5kZWZpbmVkOyAvLyBQcm9wZXJ0eSByZW1vdmVkXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFwID0gYVtwcm9wXSwgYnAgPSBiW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJwID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIGFwICYmIGJwICYmXG4gICAgICAgICAgICAgICAgLy8gTm93IGNvbXBhcmUgY29uc3RydWN0b3JzIGFyZSBzYW1lIChub3QgZXF1YWwgYmVjYXVzZSB3b250IHdvcmsgaW4gU2FmYXJpKVxuICAgICAgICAgICAgICAgICgnJyArIGFwLmNvbnN0cnVjdG9yKSA9PT0gKCcnICsgYnAuY29uc3RydWN0b3IpKVxuICAgICAgICAgICAgICAgIC8vIFNhbWUgdHlwZSBvZiBvYmplY3QgYnV0IGl0cyBwcm9wZXJ0aWVzIG1heSBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgXCIuXCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByaW1pdGl2ZSB2YWx1ZSBjaGFuZ2VkXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBrZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGFkZGVkXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnY7XG59XG4vLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBpdGVyYWJsZSBvciBhcnJheS1saWtlLCByZXR1cm4gaXQgYXMgYW4gYXJyYXlcbnZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBnZXRJdGVyYXRvck9mID0gaXRlcmF0b3JTeW1ib2wgPyBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBpO1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgKGkgPSB4W2l0ZXJhdG9yU3ltYm9sXSkgJiYgaS5hcHBseSh4KTtcbn0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xudmFyIE5PX0NIQVJfQVJSQVkgPSB7fTtcbi8vIFRha2VzIG9uZSBvciBzZXZlcmFsIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBhcnJheSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIGNyaXRlcmFzOlxuLy8gKiBJZiBzZXZlcmFsIGFyZ3VtZW50cyBwcm92aWRlZCwgcmV0dXJuIGFyZ3VtZW50cyBjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgaW4gYSB3YXkgdGhhdFxuLy8gICBzdGlsbCBhbGxvd3MgamF2YXNjcmlwdCBlbmdpbmUgdG8gb3B0aW1pemUgdGhlIGNvZGUuXG4vLyAqIElmIHNpbmdsZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgcmV0dXJuIGEgY2xvbmUgb2YgaXQuXG4vLyAqIElmIHRoaXMtcG9pbnRlciBlcXVhbHMgTk9fQ0hBUl9BUlJBWSwgZG9uJ3QgYWNjZXB0IHN0cmluZ3MgYXMgdmFsaWQgaXRlcmFibGVzIGFzIGEgc3BlY2lhbFxuLy8gICBjYXNlIHRvIHRoZSB0d28gYnVsbGV0cyBiZWxvdy5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGl0ZXJhYmxlLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheS5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFycmF5LWxpa2UgKGhhcyBsZW5ndGggb2YgdHlwZSBudW1iZXIpLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5LlxuZnVuY3Rpb24gZ2V0QXJyYXlPZihhcnJheUxpa2UpIHtcbiAgICB2YXIgaSwgYSwgeCwgaXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXlMaWtlKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMgPT09IE5PX0NIQVJfQVJSQVkgJiYgdHlwZW9mIGFycmF5TGlrZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKVxuICAgICAgICAgICAgICAgIGEucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIGFbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgfVxuICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgYVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gYTtcbn1cblxuLy8gQnkgZGVmYXVsdCwgZGVidWcgd2lsbCBiZSB0cnVlIG9ubHkgaWYgcGxhdGZvcm0gaXMgYSB3ZWIgcGxhdGZvcm0gYW5kIGl0cyBwYWdlIGlzIHNlcnZlZCBmcm9tIGxvY2FsaG9zdC5cbi8vIFdoZW4gZGVidWcgPSB0cnVlLCBlcnJvcidzIHN0YWNrcyB3aWxsIGNvbnRhaW4gYXN5bmNyb25pYyBsb25nIHN0YWNrcy5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBCeSBkZWZhdWx0LCB1c2UgZGVidWcgbW9kZSBpZiBzZXJ2ZWQgZnJvbSBsb2NhbGhvc3QuXG4gICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuICAgIGRlYnVnID0gdmFsdWU7XG4gICAgbGlicmFyeUZpbHRlciA9IGZpbHRlcjtcbn1cbnZhciBsaWJyYXJ5RmlsdGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbnZhciBORUVEU19USFJPV19GT1JfU1RBQ0sgPSAhbmV3IEVycm9yKFwiXCIpLnN0YWNrO1xuZnVuY3Rpb24gZ2V0RXJyb3JXaXRoU3RhY2soKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKE5FRURTX1RIUk9XX0ZPUl9TVEFDSylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIERvaW5nIHNvbWV0aGluZyBuYXVnaHR5IGluIHN0cmljdCBtb2RlIGhlcmUgdG8gdHJpZ2dlciBhIHNwZWNpZmljIGVycm9yXG4gICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSBleHBsaWNpdGVseSBpZ25vcmVkIGluIGRlYnVnZ2VyJ3MgZXhjZXB0aW9uIHNldHRpbmdzLlxuICAgICAgICAgICAgLy8gSWYgd2UnZCBqdXN0IHRocm93IG5ldyBFcnJvcigpIGhlcmUsIElFJ3MgZGVidWdnZXIncyBleGNlcHRpb24gc2V0dGluZ3NcbiAgICAgICAgICAgIC8vIHdpbGwganVzdCBjb25zaWRlciBpdCBhcyBcImV4Y2VwdGlvbiB0aHJvd24gYnkgamF2YXNjcmlwdCBjb2RlXCIgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyB5b3Ugd291bGRuJ3Qgd2FudCBpdCB0byBpZ25vcmUuXG4gICAgICAgICAgICBnZXRFcnJvcldpdGhTdGFjay5hcmd1bWVudHM7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gRmFsbGJhY2sgaWYgYWJvdmUgbGluZSBkb24ndCB0aHJvdy5cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiBwcmV0dHlTdGFjayhleGNlcHRpb24sIG51bUlnbm9yZWRGcmFtZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBleGNlcHRpb24uc3RhY2s7XG4gICAgaWYgKCFzdGFjaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgbnVtSWdub3JlZEZyYW1lcyA9IChudW1JZ25vcmVkRnJhbWVzIHx8IDApO1xuICAgIGlmIChzdGFjay5pbmRleE9mKGV4Y2VwdGlvbi5uYW1lKSA9PT0gMClcbiAgICAgICAgbnVtSWdub3JlZEZyYW1lcyArPSAoZXhjZXB0aW9uLm5hbWUgKyBleGNlcHRpb24ubWVzc2FnZSkuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICByZXR1cm4gc3RhY2suc3BsaXQoJ1xcbicpXG4gICAgICAgIC5zbGljZShudW1JZ25vcmVkRnJhbWVzKVxuICAgICAgICAuZmlsdGVyKGxpYnJhcnlGaWx0ZXIpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7IHJldHVybiBcIlxcblwiICsgZnJhbWU7IH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQod2hhdCwgZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLndhcm4od2hhdCArIFwiIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlci9EZXhpZS5qcy93aWtpL0RlcHJlY2F0aW9ucy4gXCIgKyBwcmV0dHlTdGFjayhnZXRFcnJvcldpdGhTdGFjaygpLCAxKSk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbnZhciBkZXhpZUVycm9yTmFtZXMgPSBbXG4gICAgJ01vZGlmeScsXG4gICAgJ0J1bGsnLFxuICAgICdPcGVuRmFpbGVkJyxcbiAgICAnVmVyc2lvbkNoYW5nZScsXG4gICAgJ1NjaGVtYScsXG4gICAgJ1VwZ3JhZGUnLFxuICAgICdJbnZhbGlkVGFibGUnLFxuICAgICdNaXNzaW5nQVBJJyxcbiAgICAnTm9TdWNoRGF0YWJhc2UnLFxuICAgICdJbnZhbGlkQXJndW1lbnQnLFxuICAgICdTdWJUcmFuc2FjdGlvbicsXG4gICAgJ1Vuc3VwcG9ydGVkJyxcbiAgICAnSW50ZXJuYWwnLFxuICAgICdEYXRhYmFzZUNsb3NlZCcsXG4gICAgJ1ByZW1hdHVyZUNvbW1pdCcsXG4gICAgJ0ZvcmVpZ25Bd2FpdCdcbl07XG52YXIgaWRiRG9tRXJyb3JOYW1lcyA9IFtcbiAgICAnVW5rbm93bicsXG4gICAgJ0NvbnN0cmFpbnQnLFxuICAgICdEYXRhJyxcbiAgICAnVHJhbnNhY3Rpb25JbmFjdGl2ZScsXG4gICAgJ1JlYWRPbmx5JyxcbiAgICAnVmVyc2lvbicsXG4gICAgJ05vdEZvdW5kJyxcbiAgICAnSW52YWxpZFN0YXRlJyxcbiAgICAnSW52YWxpZEFjY2VzcycsXG4gICAgJ0Fib3J0JyxcbiAgICAnVGltZW91dCcsXG4gICAgJ1F1b3RhRXhjZWVkZWQnLFxuICAgICdTeW50YXgnLFxuICAgICdEYXRhQ2xvbmUnXG5dO1xudmFyIGVycm9yTGlzdCA9IGRleGllRXJyb3JOYW1lcy5jb25jYXQoaWRiRG9tRXJyb3JOYW1lcyk7XG52YXIgZGVmYXVsdFRleHRzID0ge1xuICAgIFZlcnNpb25DaGFuZ2VkOiBcIkRhdGFiYXNlIHZlcnNpb24gY2hhbmdlZCBieSBvdGhlciBkYXRhYmFzZSBjb25uZWN0aW9uXCIsXG4gICAgRGF0YWJhc2VDbG9zZWQ6IFwiRGF0YWJhc2UgaGFzIGJlZW4gY2xvc2VkXCIsXG4gICAgQWJvcnQ6IFwiVHJhbnNhY3Rpb24gYWJvcnRlZFwiLFxuICAgIFRyYW5zYWN0aW9uSW5hY3RpdmU6IFwiVHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgY29tcGxldGVkIG9yIGZhaWxlZFwiXG59O1xuLy9cbi8vIERleGllRXJyb3IgLSBiYXNlIGNsYXNzIG9mIGFsbCBvdXQgZXhjZXB0aW9ucy5cbi8vXG5mdW5jdGlvbiBEZXhpZUVycm9yKG5hbWUsIG1zZykge1xuICAgIC8vIFJlYXNvbiB3ZSBkb24ndCB1c2UgRVM2IGNsYXNzZXMgaXMgYmVjYXVzZTpcbiAgICAvLyAxLiBJdCBibG9hdHMgdHJhbnNwaWxlZCBjb2RlIGFuZCBpbmNyZWFzZXMgc2l6ZSBvZiBtaW5pZmllZCBjb2RlLlxuICAgIC8vIDIuIEl0IGRvZXNuJ3QgZ2l2ZSB1cyBtdWNoIGluIHRoaXMgY2FzZS5cbiAgICAvLyAzLiBJdCB3b3VsZCByZXF1aXJlIHN1YiBjbGFzc2VzIHRvIGNhbGwgc3VwZXIoKSwgd2hpY2hcbiAgICAvLyAgICBpcyBub3QgbmVlZGVkIHdoZW4gZGVyaXZpbmcgZnJvbSBFcnJvci5cbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbn1cbmRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEVycm9yKS5leHRlbmQoe1xuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX3N0YWNrID0gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgcHJldHR5U3RhY2sodGhpcy5fZSwgMikpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlOyB9XG59KTtcbmZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpIHtcbiAgICByZXR1cm4gbXNnICsgXCIuIEVycm9yczogXCIgKyBmYWlsdXJlc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYsIGksIHMpIHsgcmV0dXJuIHMuaW5kZXhPZih2KSA9PT0gaTsgfSkgLy8gT25seSB1bmlxdWUgZXJyb3Igc3RyaW5nc1xuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vL1xuLy8gTW9kaWZ5RXJyb3IgLSB0aHJvd24gaW4gQ29sbGVjdGlvbi5tb2RpZnkoKVxuLy8gU3BlY2lmaWMgY29uc3RydWN0b3IgYmVjYXVzZSBpdCBjb250YWlucyBtZW1iZXJzIGZhaWx1cmVzIGFuZCBmYWlsZWRLZXlzLlxuLy9cbmZ1bmN0aW9uIE1vZGlmeUVycm9yKG1zZywgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICB0aGlzLmZhaWxlZEtleXMgPSBmYWlsZWRLZXlzO1xuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gc3VjY2Vzc0NvdW50O1xufVxuZGVyaXZlKE1vZGlmeUVycm9yKS5mcm9tKERleGllRXJyb3IpO1xuZnVuY3Rpb24gQnVsa0Vycm9yKG1zZywgZmFpbHVyZXMpIHtcbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJ1bGtFcnJvclwiO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcbn1cbmRlcml2ZShCdWxrRXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG4vL1xuLy9cbi8vIER5bmFtaWNhbGx5IGdlbmVyYXRlIGVycm9yIG5hbWVzIGFuZCBleGNlcHRpb24gY2xhc3NlcyBiYXNlZFxuLy8gb24gdGhlIG5hbWVzIGluIGVycm9yTGlzdC5cbi8vXG4vL1xuLy8gTWFwIG9mIHtFcnJvck5hbWUgLT4gRXJyb3JOYW1lICsgXCJFcnJvclwifVxudmFyIGVycm5hbWVzID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7IHJldHVybiAob2JqW25hbWVdID0gbmFtZSArIFwiRXJyb3JcIiwgb2JqKTsgfSwge30pO1xuLy8gTmVlZCBhbiBhbGlhcyBmb3IgRGV4aWVFcnJvciBiZWNhdXNlIHdlJ3JlIGdvbm5hIGNyZWF0ZSBzdWJjbGFzc2VzIHdpdGggdGhlIHNhbWUgbmFtZS5cbnZhciBCYXNlRXhjZXB0aW9uID0gRGV4aWVFcnJvcjtcbi8vIE1hcCBvZiB7RXJyb3JOYW1lIC0+IGV4Y2VwdGlvbiBjb25zdHJ1Y3Rvcn1cbnZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgLy8gTGV0IHRoZSBuYW1lIGJlIFwiRGV4aWVFcnJvclwiIGJlY2F1c2UgdGhpcyBuYW1lIG1heVxuICAgIC8vIGJlIHNob3duIGluIGNhbGwgc3RhY2sgYW5kIHdoZW4gZGVidWdnaW5nLiBEZXhpZUVycm9yIGlzXG4gICAgLy8gdGhlIG1vc3QgdHJ1ZSBuYW1lIGJlY2F1c2UgaXQgZGVyaXZlcyBmcm9tIERleGllRXJyb3IsXG4gICAgLy8gYW5kIHdlIGNhbm5vdCBjaGFuZ2UgRnVuY3Rpb24ubmFtZSBwcm9ncmFtYXRpY2FsbHkgd2l0aG91dFxuICAgIC8vIGR5bmFtaWNhbGx5IGNyZWF0ZSBhIEZ1bmN0aW9uIG9iamVjdCwgd2hpY2ggd291bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vICdldmFsLWV2aWwnLlxuICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG4gICAgZnVuY3Rpb24gRGV4aWVFcnJvcihtc2dPcklubmVyLCBpbm5lcikge1xuICAgICAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZnVsbE5hbWU7XG4gICAgICAgIGlmICghbXNnT3JJbm5lcikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZGVmYXVsdFRleHRzW25hbWVdIHx8IGZ1bGxOYW1lO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2dPcklubmVyO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2dPcklubmVyLm5hbWUgKyBcIiBcIiArIG1zZ09ySW5uZXIubWVzc2FnZTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuICAgIG9ialtuYW1lXSA9IERleGllRXJyb3I7XG4gICAgcmV0dXJuIG9iajtcbn0sIHt9KTtcbi8vIFVzZSBFQ01BU0NSSVBUIHN0YW5kYXJkIGV4Y2VwdGlvbnMgd2hlcmUgYXBwbGljYWJsZTpcbmV4Y2VwdGlvbnMuU3ludGF4ID0gU3ludGF4RXJyb3I7XG5leGNlcHRpb25zLlR5cGUgPSBUeXBlRXJyb3I7XG5leGNlcHRpb25zLlJhbmdlID0gUmFuZ2VFcnJvcjtcbnZhciBleGNlcHRpb25NYXAgPSBpZGJEb21FcnJvck5hbWVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZnVuY3Rpb24gbWFwRXJyb3IoZG9tRXJyb3IsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWRvbUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgRGV4aWVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yIHx8ICFkb21FcnJvci5uYW1lIHx8ICFleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0pXG4gICAgICAgIHJldHVybiBkb21FcnJvcjtcbiAgICB2YXIgcnYgPSBuZXcgZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKG1lc3NhZ2UgfHwgZG9tRXJyb3IubWVzc2FnZSwgZG9tRXJyb3IpO1xuICAgIGlmIChcInN0YWNrXCIgaW4gZG9tRXJyb3IpIHtcbiAgICAgICAgLy8gRGVyaXZlIHN0YWNrIGZyb20gaW5uZXIgZXhjZXB0aW9uIGlmIGl0IGhhcyBhIHN0YWNrXG4gICAgICAgIHNldFByb3AocnYsIFwic3RhY2tcIiwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbnZhciBmdWxsTmFtZUV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICBpZiAoW1wiU3ludGF4XCIsIFwiVHlwZVwiLCBcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuTW9kaWZ5RXJyb3IgPSBNb2RpZnlFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5EZXhpZUVycm9yID0gRGV4aWVFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5CdWxrRXJyb3IgPSBCdWxrRXJyb3I7XG5cbmZ1bmN0aW9uIG5vcCgpIHsgfVxuZnVuY3Rpb24gbWlycm9yKHZhbCkgeyByZXR1cm4gdmFsOyB9XG5mdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICAvLyBFbmFibGVzIGNoYWluZWQgZXZlbnRzIHRoYXQgdGFrZXMgT05FIGFyZ3VtZW50IGFuZCByZXR1cm5zIGl0IHRvIHRoZSBuZXh0IGZ1bmN0aW9uIGluIGNoYWluLlxuICAgIC8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIGluIHRoZSBob29rKFwicmVhZGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgLy8gRW5hYmxlcyBjaGFpbmVkIGV2ZW50cyB0aGF0IHRha2VzIHNldmVyYWwgYXJndW1lbnRzIGFuZCBtYXkgbW9kaWZ5IGZpcnN0IGFyZ3VtZW50IGJ5IG1ha2luZyBhIG1vZGlmaWNhdGlvbiBhbmQgdGhlbiByZXR1cm5pbmcgdGhlIHNhbWUgaW5zdGFuY2UuXG4gICAgLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgaW4gdGhlIGhvb2soXCJjcmVhdGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSByZXM7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7IC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uZXJyb3JcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMyICE9PSB1bmRlZmluZWQgPyByZXMyIDogcmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBob29rRGVsZXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7IC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uZXJyb3JcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgIH07XG59XG5mdW5jdGlvbiBob29rVXBkYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucykge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZXh0ZW5kKG1vZGlmaWNhdGlvbnMsIHJlcyk7IC8vIElmIGYxIHJldHVybnMgbmV3IG1vZGlmaWNhdGlvbnMsIGV4dGVuZCBjYWxsZXIncyBtb2RpZmljYXRpb25zIHdpdGggdGhlIHJlc3VsdCBiZWZvcmUgY2FsbGluZyBuZXh0IGluIGNoYWluLlxuICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsIC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uc3VjY2Vzc1xuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yOyAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgKHJlczIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlczIpIDpcbiAgICAgICAgICAgIChleHRlbmQocmVzLCByZXMyKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcywgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGl6LCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNyBEYXZpZCBGYWhsYW5kZXJcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG4vL1xuLy8gUHJvbWlzZSBhbmQgWm9uZSAoUFNEKSBmb3IgRGV4aWUgbGlicmFyeVxuLy9cbi8vIEkgc3RhcnRlZCBvdXQgd3JpdGluZyB0aGlzIFByb21pc2UgY2xhc3MgYnkgY29weWluZyBwcm9taXNlLWxpZ2h0IChodHRwczovL2dpdGh1Yi5jb20vdGF5bG9yaGFrZXMvcHJvbWlzZS1saWdodCkgYnlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YXlsb3JoYWtlcyAtIGFuIEErIGFuZCBFQ01BU0NSSVBUIDYgY29tcGxpYW50IFByb21pc2UgaW1wbGVtZW50YXRpb24uXG4vL1xuLy8gSW4gcHJldmlvdXMgdmVyc2lvbnMgdGhpcyB3YXMgZml4ZWQgYnkgbm90IGNhbGxpbmcgc2V0VGltZW91dCB3aGVuIGtub3dpbmcgdGhhdCB0aGUgcmVzb2x2ZSgpIG9yIHJlamVjdCgpIGNhbWUgZnJvbSBhbm90aGVyXG4vLyB0aWNrLiBJbiBEZXhpZSB2MS40LjAsIEkndmUgcmV3cml0dGVuIHRoZSBQcm9taXNlIGNsYXNzIGVudGlyZWx5LiBKdXN0IHNvbWUgZnJhZ21lbnRzIG9mIHByb21pc2UtbGlnaHQgaXMgbGVmdC4gSSB1c2Vcbi8vIGFub3RoZXIgc3RyYXRlZ3kgbm93IHRoYXQgc2ltcGxpZmllcyBldmVyeXRoaW5nIGEgbG90OiB0byBhbHdheXMgZXhlY3V0ZSBjYWxsYmFja3MgaW4gYSBuZXcgbWljcm8tdGFzaywgYnV0IGhhdmUgYW4gb3duIG1pY3JvLXRhc2tcbi8vIGVuZ2luZSB0aGF0IGlzIGluZGV4ZWREQiBjb21wbGlhbnQgYWNyb3NzIGFsbCBicm93c2Vycy5cbi8vIFByb21pc2UgY2xhc3MgaGFzIGFsc28gYmVlbiBvcHRpbWl6ZWQgYSBsb3Qgd2l0aCBpbnNwaXJhdGlvbiBmcm9tIGJsdWViaXJkIC0gdG8gYXZvaWQgY2xvc3VyZXMgYXMgbXVjaCBhcyBwb3NzaWJsZS5cbi8vIEFsc28gd2l0aCBpbnNwaXJhdGlvbiBmcm9tIGJsdWViaXJkLCBhc3luY3JvbmljIHN0YWNrcyBpbiBkZWJ1ZyBtb2RlLlxuLy9cbi8vIFNwZWNpZmljIG5vbi1zdGFuZGFyZCBmZWF0dXJlcyBvZiB0aGlzIFByb21pc2UgY2xhc3M6XG4vLyAqIEN1c3RvbSB6b25lIHN1cHBvcnQgKGEuay5hLiBQU0QpIHdpdGggYWJpbGl0eSB0byBrZWVwIHpvbmVzIGFsc28gd2hlbiB1c2luZyBuYXRpdmUgcHJvbWlzZXMgYXMgd2VsbCBhc1xuLy8gICBuYXRpdmUgYXN5bmMgLyBhd2FpdC5cbi8vICogUHJvbWlzZS5mb2xsb3coKSBtZXRob2QgYnVpbHQgdXBvbiB0aGUgY3VzdG9tIHpvbmUgZW5naW5lLCB0aGF0IGFsbG93cyB1c2VyIHRvIHRyYWNrIGFsbCBwcm9taXNlcyBjcmVhdGVkIGZyb20gY3VycmVudCBzdGFjayBmcmFtZVxuLy8gICBhbmQgYmVsb3cgKyBhbGwgcHJvbWlzZXMgdGhhdCB0aG9zZSBwcm9taXNlcyBjcmVhdGVzIG9yIGF3YWl0cy5cbi8vICogRGV0ZWN0IGFueSB1bmhhbmRsZWQgcHJvbWlzZSBpbiBhIFBTRC1zY29wZSAoUFNELm9udW5oYW5kbGVkKS4gXG4vL1xuLy8gRGF2aWQgRmFobGFuZGVyLCBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlclxuLy9cbi8vIEp1c3QgYSBwb2ludGVyIHRoYXQgb25seSB0aGlzIG1vZHVsZSBrbm93cyBhYm91dC5cbi8vIFVzZWQgaW4gUHJvbWlzZSBjb25zdHJ1Y3RvciB0byBlbXVsYXRlIGEgcHJpdmF0ZSBjb25zdHJ1Y3Rvci5cbnZhciBJTlRFUk5BTCA9IHt9O1xuLy8gQXN5bmMgc3RhY2tzIChsb25nIHN0YWNrcykgbXVzdCBub3QgZ3JvdyBpbmZpbml0ZWx5LlxudmFyIExPTkdfU1RBQ0tTX0NMSVBfTElNSVQgPSAxMDA7XG52YXIgTUFYX0xPTkdfU1RBQ0tTID0gMjA7XG52YXIgWk9ORV9FQ0hPX0xJTUlUID0gNztcbnZhciBuYXRpdmVQcm9taXNlSW5zdGFuY2VBbmRQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQmUgYWJsZSB0byBwYXRjaCBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJsZXQgRj1hc3luYyAoKT0+e30scD1GKCk7cmV0dXJuIFtwLE9iamVjdC5nZXRQcm90b3R5cGVPZihwKSxQcm9taXNlLnJlc29sdmUoKSxGLmNvbnN0cnVjdG9yXTtcIikoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIFAgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgICAgIHJldHVybiBQID9cbiAgICAgICAgICAgIFtQLnJlc29sdmUoKSwgUC5wcm90b3R5cGUsIFAucmVzb2x2ZSgpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICB9XG59KSgpO1xudmFyIHJlc29sdmVkTmF0aXZlUHJvbWlzZSA9IG5hdGl2ZVByb21pc2VJbnN0YW5jZUFuZFByb3RvWzBdO1xudmFyIG5hdGl2ZVByb21pc2VQcm90byA9IG5hdGl2ZVByb21pc2VJbnN0YW5jZUFuZFByb3RvWzFdO1xudmFyIHJlc29sdmVkR2xvYmFsUHJvbWlzZSA9IG5hdGl2ZVByb21pc2VJbnN0YW5jZUFuZFByb3RvWzJdO1xudmFyIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xudmFyIE5hdGl2ZVByb21pc2UgPSByZXNvbHZlZE5hdGl2ZVByb21pc2UgJiYgcmVzb2x2ZWROYXRpdmVQcm9taXNlLmNvbnN0cnVjdG9yO1xudmFyIEFzeW5jRnVuY3Rpb24gPSBuYXRpdmVQcm9taXNlSW5zdGFuY2VBbmRQcm90b1szXTtcbnZhciBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcbnZhciBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSBmYWxzZTtcbi8qIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHVzZWQgb25seSBmb3IgdGhlIHZlcnkgZmlyc3QgcHJvbWlzZSBpbiBhIHByb21pc2UgY2hhaW4uXG4gICBBcyBzb29uIGFzIHRoZW4gcHJvbWlzZSBpcyByZXNvbHZlZCBvciByZWplY3RlZCwgYWxsIG5leHQgdGFza3Mgd2lsbCBiZSBleGVjdXRlZCBpbiBtaWNybyB0aWNrc1xuICAgZW11bGF0ZWQgaW4gdGhpcyBtb2R1bGUuIEZvciBpbmRleGVkREIgY29tcGF0aWJpbGl0eSwgdGhpcyBtZWFucyB0aGF0IGV2ZXJ5IG1ldGhvZCBuZWVkcyB0b1xuICAgZXhlY3V0ZSBhdCBsZWFzdCBvbmUgcHJvbWlzZSBiZWZvcmUgZG9pbmcgYW4gaW5kZXhlZERCIG9wZXJhdGlvbi4gRGV4aWUgd2lsbCBhbHdheXMgY2FsbFxuICAgZGIucmVhZHkoKS50aGVuKCkgZm9yIGV2ZXJ5IG9wZXJhdGlvbiB0byBtYWtlIHN1cmUgdGhlIGluZGV4ZWREQiBldmVudCBpcyBzdGFydGVkIGluIGFuXG4gICBpbmRleGVkREItY29tcGF0aWJsZSBlbXVsYXRlZCBtaWNybyB0YXNrIGxvb3AuXG4qL1xudmFyIHNjaGVkdWxlUGh5c2ljYWxUaWNrID0gcmVzb2x2ZWRHbG9iYWxQcm9taXNlID9cbiAgICBmdW5jdGlvbiAoKSB7IHJlc29sdmVkR2xvYmFsUHJvbWlzZS50aGVuKHBoeXNpY2FsVGljayk7IH1cbiAgICA6XG4gICAgICAgIF9nbG9iYWwuc2V0SW1tZWRpYXRlID9cbiAgICAgICAgICAgIC8vIHNldEltbWVkaWF0ZSBzdXBwb3J0ZWQuIFRob3NlIG1vZGVybiBwbGF0Zm9ybXMgYWxzbyBzdXBwb3J0cyBGdW5jdGlvbi5iaW5kKCkuXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUuYmluZChudWxsLCBwaHlzaWNhbFRpY2spIDpcbiAgICAgICAgICAgIF9nbG9iYWwuTXV0YXRpb25PYnNlcnZlciA/XG4gICAgICAgICAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAobmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxUaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KSkub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgnaScsICcxJyk7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3Igc2V0SW1tZWRpYXRlIG9yIE11dGF0aW9uT2JzZXJ2ZXIuIE5vIHdvcnJ5LCBzZXRUaW1lb3V0IGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAgICAgLy8gb25jZSB0aW1lLiBFdmVyeSB0aWNrIHRoYXQgZm9sbG93cyB3aWxsIGJlIG91ciBlbXVsYXRlZCBtaWNybyB0aWNrLlxuICAgICAgICAgICAgICAgIC8vIENvdWxkIGhhdmUgdXNlcyBzZXRUaW1lb3V0LmJpbmQobnVsbCwgMCwgcGh5c2ljYWxUaWNrKSBpZiBpdCB3YXNudCBmb3IgdGhhdCBGRjEzIGFuZCBiZWxvdyBoYXMgYSBidWcgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KHBoeXNpY2FsVGljaywgMCk7IH07XG4vLyBDb25maWd1cmFibGUgdGhyb3VnaCBQcm9taXNlLnNjaGVkdWxlci5cbi8vIERvbid0IGV4cG9ydCBiZWNhdXNlIGl0IHdvdWxkIGJlIHVuc2FmZSB0byBsZXQgdW5rbm93blxuLy8gY29kZSBjYWxsIGl0IHVubGVzcyB0aGV5IGRvIHRyeS4uY2F0Y2ggd2l0aGluIHRoZWlyIGNhbGxiYWNrLlxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgcmV0cmlldmVkIHRocm91Z2ggZ2V0dGVyIG9mIFByb21pc2Uuc2NoZWR1bGVyIHRob3VnaCxcbi8vIGJ1dCB1c2VycyBtdXN0IG5vdCBkbyBQcm9taXNlLnNjaGVkdWxlciA9IG15RnVuY1RoYXRUaHJvd3NFeGNlcHRpb25cbnZhciBhc2FwJDEgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICBtaWNyb3RpY2tRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnc10pO1xuICAgIGlmIChuZWVkc05ld1BoeXNpY2FsVGljaykge1xuICAgICAgICBzY2hlZHVsZVBoeXNpY2FsVGljaygpO1xuICAgICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgIH1cbn07XG52YXIgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbnZhciBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWU7XG52YXIgdW5oYW5kbGVkRXJyb3JzID0gW107XG52YXIgcmVqZWN0aW5nRXJyb3JzID0gW107XG52YXIgY3VycmVudEZ1bGZpbGxlciA9IG51bGw7XG52YXIgcmVqZWN0aW9uTWFwcGVyID0gbWlycm9yOyAvLyBSZW1vdmUgaW4gbmV4dCBtYWpvciB3aGVuIHJlbW92aW5nIGVycm9yIG1hcHBpbmcgb2YgRE9NRXJyb3JzIGFuZCBET01FeGNlcHRpb25zXG52YXIgZ2xvYmFsUFNEID0ge1xuICAgIGlkOiAnZ2xvYmFsJyxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgcmVmOiAwLFxuICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgIG9udW5oYW5kbGVkOiBnbG9iYWxFcnJvcixcbiAgICBwZ3A6IGZhbHNlLFxuICAgIGVudjoge30sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmhhbmRsZWRzLmZvckVhY2goZnVuY3Rpb24gKHVoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdsb2JhbEVycm9yKHVoWzBdLCB1aFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgUFNEID0gZ2xvYmFsUFNEO1xudmFyIG1pY3JvdGlja1F1ZXVlID0gW107IC8vIENhbGxiYWNrcyB0byBjYWxsIGluIHRoaXMgb3IgbmV4dCBwaHlzaWNhbCB0aWNrLlxudmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDsgLy8gTnVtYmVyIG9mIGxpc3RlbmVyLWNhbGxzIGxlZnQgdG8gZG8gaW4gdGhpcyBwaHlzaWNhbCB0aWNrLlxudmFyIHRpY2tGaW5hbGl6ZXJzID0gW107IC8vIEZpbmFsaXplcnMgdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGFzeW5jIGNhbGxzIHNjaGVkdWxlZCB3aXRoaW4gY3VycmVudCBwaHlzaWNhbCB0aWNrLlxuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMub251bmNhdGNoZWQgPSBub3A7IC8vIERlcHJlY2F0ZSBpbiBuZXh0IG1ham9yLiBOb3QgbmVlZGVkLiBCZXR0ZXIgdG8gdXNlIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgIC8vIEEgbGlicmFyeSBtYXkgc2V0IGBwcm9taXNlLl9saWIgPSB0cnVlO2AgYWZ0ZXIgcHJvbWlzZSBpcyBjcmVhdGVkIHRvIG1ha2UgcmVzb2x2ZSgpIG9yIHJlamVjdCgpXG4gICAgLy8gZXhlY3V0ZSB0aGUgbWljcm90YXNrIGVuZ2luZSBpbXBsaWNpdGVseSB3aXRoaW4gdGhlIGNhbGwgdG8gcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFRvIHJlbWFpbiBBKyBjb21wbGlhbnQsIGEgbGlicmFyeSBtdXN0IG9ubHkgc2V0IGBfbGliPXRydWVgIGlmIGl0IGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgc3RhY2tcbiAgICAvLyBvbmx5IGNvbnRhaW5zIGxpYnJhcnkgY29kZSB3aGVuIGNhbGxpbmcgcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFJVTEUgT0YgVEhVTUI6IE9OTFkgc2V0IF9saWIgPSB0cnVlIGZvciBwcm9taXNlcyBleHBsaWNpdGVseSByZXNvbHZpbmcvcmVqZWN0aW5nIGRpcmVjdGx5IGZyb21cbiAgICAvLyBnbG9iYWwgc2NvcGUgKGV2ZW50IGhhbmRsZXIsIHRpbWVyIGV0YykhXG4gICAgdGhpcy5fbGliID0gZmFsc2U7XG4gICAgLy8gQ3VycmVudCBhc3luYyBzY29wZVxuICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgdGhpcy5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbnVtUHJldiA9IDA7IC8vIE51bWJlciBvZiBwcmV2aW91cyBwcm9taXNlcyAoZm9yIGxvbmcgc3RhY2tzKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChmbiAhPT0gSU5URVJOQUwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yIChJTlRFUk5BTCwgc3RhdGUsIHZhbHVlKS5cbiAgICAgICAgLy8gVXNlZCBpbnRlcm5hbGx5IGJ5IFByb21pc2UucmVzb2x2ZSgpIGFuZCBQcm9taXNlLnJlamVjdCgpLlxuICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpOyAvLyBNYXAgZXJyb3IsIHNldCBzdGFjayBhbmQgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcigpLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gbnVsbDsgLy8gbnVsbCAoPXBlbmRpbmcpLCBmYWxzZSAoPXJlamVjdGVkKSBvciB0cnVlICg9cmVzb2x2ZWQpXG4gICAgdGhpcy5fdmFsdWUgPSBudWxsOyAvLyBlcnJvciBvciByZXN1bHRcbiAgICArK3BzZC5yZWY7IC8vIFJlZmNvdW50aW5nIGN1cnJlbnQgc2NvcGVcbiAgICBleGVjdXRlUHJvbWlzZVRhc2sodGhpcywgZm4pO1xufVxuLy8gUHJlcGFyZSBhIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcHV0IG9udG8gUHJvbWlzZS5wcm90b3R5cGUudGhlblxudmFyIHRoZW5Qcm9wID0ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHNkID0gUFNELCBtaWNyb1Rhc2tJZCA9IHRvdGFsRWNob2VzO1xuICAgICAgICBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KVxuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICB2YXIgcnYgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihfdGhpcywgbmV3IExpc3RlbmVyKG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25GdWxmaWxsZWQsIHBzZCwgcG9zc2libGVBd2FpdCksIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgcHNkLCBwb3NzaWJsZUF3YWl0KSwgcmVzb2x2ZSwgcmVqZWN0LCBwc2QpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVidWcgJiYgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICB0aGVuLnByb3RvdHlwZSA9IElOVEVSTkFMOyAvLyBGb3IgaWRlbXBvdGVuc2UsIHNlZSBzZXR0ZXIgYmVsb3cuXG4gICAgICAgIHJldHVybiB0aGVuO1xuICAgIH0sXG4gICAgLy8gQmUgaWRlbXBvdGVudCBhbmQgYWxsb3cgYW5vdGhlciBmcmFtZXdvcmsgKHN1Y2ggYXMgem9uZS5qcyBvciBhbm90aGVyIGluc3RhbmNlIG9mIGEgRGV4aWUuUHJvbWlzZSBtb2R1bGUpIHRvIHJlcGxhY2UgUHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIC8vIGFuZCB3aGVuIHRoYXQgZnJhbWV3b3JrIHdhbnRzIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnR5LCB3ZSBtdXN0IGlkZW50aWZ5IHRoYXQgYW5kIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgdGhlblByb3AgOiAvLyBSZXN0b3JlIHRvIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gR2V0dGVyIHJldHVybmluZyBwcm92aWRlZCB2YWx1ZSAoYmVoYXZlcyBsaWtlIHZhbHVlIGlzIGp1c3QgY2hhbmdlZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0IC8vIEtlZXAgYSBzZXR0ZXIgdGhhdCBpcyBwcmVwYXJlZCB0byByZXN0b3JlIG9yaWdpbmFsLlxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbnByb3BzKFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgdGhlbjogdGhlblByb3AsXG4gICAgX3RoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAvLyBBIGxpdHRsZSB0aW5pZXIgdmVyc2lvbiBvZiB0aGVuKCkgdGhhdCBkb24ndCBoYXZlIHRvIGNyZWF0ZSBhIHJlc3VsdGluZyBwcm9taXNlLlxuICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHRoaXMsIG5ldyBMaXN0ZW5lcihudWxsLCBudWxsLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgUFNEKSk7XG4gICAgfSxcbiAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAvLyBGaXJzdCBhcmd1bWVudCBpcyB0aGUgRXJyb3IgdHlwZSB0byBjYXRjaFxuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBieSBpdHMgY29uc3RydWN0b3IgdHlwZSAoc2ltaWxhciB0byBqYXZhIC8gYysrIC8gYyMpXG4gICAgICAgICAgICAvLyBTYW1wbGU6IHByb21pc2UuY2F0Y2goVHlwZUVycm9yLCBmdW5jdGlvbiAoZSkgeyAuLi4gfSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIDogdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgYnkgdGhlIGVycm9yLm5hbWUgcHJvcGVydHkuIE1ha2VzIHNlbnNlIGZvciBpbmRleGVkREIgd2hlcmUgZXJyb3IgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBET01FcnJvciBidXQgd2hlcmUgZS5uYW1lIHRlbGxzIHRoZSBhY3R1YWwgZXJyb3IgdHlwZS5cbiAgICAgICAgICAgICAgICAvLyBTYW1wbGU6IHByb21pc2UuY2F0Y2goJ0NvbnN0cmFpbnRFcnJvcicsIGZ1bmN0aW9uIChlKSB7IC4uLiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBvbkZpbmFsbHkoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tzID0gZ2V0U3RhY2sodGhpcywgW10sIE1BWF9MT05HX1NUQUNLUyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gc3RhY2tzLmpvaW4oXCJcXG5Gcm9tIHByZXZpb3VzOiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IHN0YWNrOyAvLyBTdGFjayBtYXkgYmUgdXBkYXRlZCBvbiByZWplY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuVGltZW91dChtc2cpKTsgfSwgbXMpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuICAgICAgICAgICAgfSkgOiB0aGlzO1xuICAgIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICBzZXRQcm9wKFByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdQcm9taXNlJyk7XG4vLyBOb3cgdGhhdCBQcm9taXNlLnByb3RvdHlwZSBpcyBkZWZpbmVkLCB3ZSBoYXZlIGFsbCBpdCB0YWtlcyB0byBzZXQgZ2xvYmFsUFNELmVudi5cbi8vIEVudmlyb25tZW50IGdsb2JhbHMgc25hcHNob3R0ZWQgb24gbGVhdmluZyBnbG9iYWwgem9uZVxuZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5mdW5jdGlvbiBMaXN0ZW5lcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0LCB6b25lKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgdGhpcy5wc2QgPSB6b25lO1xufVxuLy8gUHJvbWlzZSBTdGF0aWMgUHJvcGVydGllc1xucHJvcHMoUHJvbWlzZSwge1xuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpIC8vIFN1cHBvcnRzIGl0ZXJhYmxlcywgaW1wbGljaXQgYXJndW1lbnRzIGFuZCBhcnJheS1saWtlLlxuICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpOyAvLyBIYW5kbGUgcGFyYWxsZWxsIGFzeW5jL2F3YWl0cyBcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSwgaSkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgcnYgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCwgdHJ1ZSwgdmFsdWUpO1xuICAgICAgICBsaW5rVG9QcmV2aW91c1Byb21pc2UocnYsIGN1cnJlbnRGdWxmaWxsZXIpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfSxcbiAgICByZWplY3Q6IFByb21pc2VSZWplY3QsXG4gICAgcmFjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBQU0Q6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQU0Q7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBQU0QgPSB2YWx1ZTsgfVxuICAgIH0sXG4gICAgLy90b3RhbEVjaG9lczoge2dldDogKCk9PnRvdGFsRWNob2VzfSxcbiAgICAvL3Rhc2s6IHtnZXQ6ICgpPT50YXNrfSxcbiAgICBuZXdQU0Q6IG5ld1Njb3BlLFxuICAgIHVzZVBTRDogdXNlUFNELFxuICAgIHNjaGVkdWxlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzYXAkMTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgYXNhcCQxID0gdmFsdWU7IH1cbiAgICB9LFxuICAgIHJlamVjdGlvbk1hcHBlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdGlvbk1hcHBlcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmVqZWN0aW9uTWFwcGVyID0gdmFsdWU7IH0gLy8gTWFwIHJlamVjdCBmYWlsdXJlc1xuICAgIH0sXG4gICAgZm9sbG93OiBmdW5jdGlvbiAoZm4sIHpvbmVQcm9wcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICAgICAgICAgIHBzZC51bmhhbmRsZWRzID0gW107IC8vIEZvciB1bmhhbmRsZWQgc3RhbmRhcmQtIG9yIDNyZCBwYXJ0eSBQcm9taXNlcy4gQ2hlY2tlZCBhdCBwc2QuZmluYWxpemUoKVxuICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDsgLy8gVHJpZ2dlcmVkIGRpcmVjdGx5IG9uIHVuaGFuZGxlZCBwcm9taXNlcyBvZiB0aGlzIGxpYnJhcnkuXG4gICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmhhbmRsZWQgc3RhbmRhcmQgb3IgM3JkIHBhcnQgcHJvbWlzZXMgYXJlIHB1dCBpbiBQU0QudW5oYW5kbGVkcyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbWluZWQgdXBvbiBzY29wZSBjb21wbGV0aW9uIHdoaWxlIHVuaGFuZGxlZCByZWplY3Rpb25zIGluIHRoaXMgUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHRyaWdnZXIgZGlyZWN0bHkgdGhyb3VnaCBwc2Qub251bmhhbmRsZWRcbiAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmhhbmRsZWRzLmxlbmd0aCA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdChfdGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbipcbiogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuKi9cbmZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCBmbikge1xuICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICB0cnkge1xuICAgICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgc2V0dGxlZFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcm9taXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH0sIGhhbmRsZVJlamVjdGlvbi5iaW5kKG51bGwsIHByb21pc2UpKTsgLy8gSWYgRnVuY3Rpb24uYmluZCBpcyBub3Qgc3VwcG9ydGVkLiBFeGNlcHRpb24gaXMgaGFuZGxlZCBpbiBjYXRjaCBiZWxvd1xuICAgIH1cbiAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmVqZWN0aW5nRXJyb3JzLnB1c2gocmVhc29uKTtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgIHJlYXNvbiA9IHJlamVjdGlvbk1hcHBlcihyZWFzb24pO1xuICAgIHByb21pc2UuX3N0YXRlID0gZmFsc2U7XG4gICAgcHJvbWlzZS5fdmFsdWUgPSByZWFzb247XG4gICAgZGVidWcgJiYgcmVhc29uICE9PSBudWxsICYmIHR5cGVvZiByZWFzb24gPT09ICdvYmplY3QnICYmICFyZWFzb24uX3Byb21pc2UgJiYgdHJ5Q2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3JpZ1Byb3AgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocmVhc29uLCBcInN0YWNrXCIpO1xuICAgICAgICByZWFzb24uX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICBzZXRQcm9wKHJlYXNvbiwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AgJiYgKG9yaWdQcm9wLmdldCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC5nZXQuYXBwbHkocmVhc29uKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC52YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBBZGQgdGhlIGZhaWx1cmUgdG8gYSBsaXN0IG9mIHBvc3NpYmx5IHVuY2F1Z2h0IGVycm9yc1xuICAgIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSk7XG4gICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKSB7XG4gICAgLy9kZWJ1ZyAmJiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSk7XG4gICAgdmFyIGxpc3RlbmVycyA9IHByb21pc2UuX2xpc3RlbmVycztcbiAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAtLXBzZC5yZWYgfHwgcHNkLmZpbmFsaXplKCk7IC8vIGlmIHBzZC5yZWYgcmVhY2hlcyB6ZXJvLCBjYWxsIHBzZC5maW5hbGl6ZSgpO1xuICAgIGlmIChudW1TY2hlZHVsZWRDYWxscyA9PT0gMCkge1xuICAgICAgICAvLyBJZiBudW1TY2hlZHVsZWRDYWxscyBpcyAwLCBpdCBtZWFucyB0aGF0IG91ciBzdGFjayBpcyBub3QgaW4gYSBjYWxsYmFjayBvZiBhIHNjaGVkdWxlZCBjYWxsLFxuICAgICAgICAvLyBhbmQgdGhhdCBubyBkZWZlcnJlZHMgd2hlcmUgbGlzdGVuaW5nIHRvIHRoaXMgcmVqZWN0aW9uIG9yIHN1Y2Nlc3MuXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIGEgcmlzayB0aGF0IG91ciBzdGFjayBjYW4gY29udGFpbiBhcHBsaWNhdGlvbiBjb2RlIHRoYXQgbWF5XG4gICAgICAgIC8vIGRvIHN0dWZmIGFmdGVyIHRoaXMgY29kZSBpcyBmaW5pc2hlZCB0aGF0IG1heSBnZW5lcmF0ZSBuZXcgY2FsbHMsIHdlIGNhbm5vdFxuICAgICAgICAvLyBjYWxsIGZpbmFsaXplcnMgaGVyZS5cbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7IC8vIFdpbGwgZGV0ZWN0IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIExpc3RlbmVyIGRvZXNudCBoYXZlIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBiZWluZyB0cmlnZ2VyZWQgKG9uRnVsZmlsbGVkIG9yIG9uUmVqZWN0KSBzbyBsZXRzIGZvcndhcmQgdGhlIGV2ZW50IHRvIGFueSBldmVudHVhbCBsaXN0ZW5lcnMgb24gdGhlIFByb21pc2UgaW5zdGFuY2UgcmV0dXJuZWQgYnkgdGhlbigpIG9yIGNhdGNoKClcbiAgICAgICAgcmV0dXJuIChwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLnJlc29sdmUgOiBsaXN0ZW5lci5yZWplY3QpKHByb21pc2UuX3ZhbHVlKTtcbiAgICB9XG4gICAgKytsaXN0ZW5lci5wc2QucmVmO1xuICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgYXNhcCQxKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xufVxuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGNiLCBwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFNldCBzdGF0aWMgdmFyaWFibGUgY3VycmVudEZ1bGZpbGxlciB0byB0aGUgcHJvbWlzZSB0aGF0IGlzIGJlaW5nIGZ1bGxmaWxsZWQsXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgY29ubmVjdCB0aGUgY2hhaW4gb2YgcHJvbWlzZXMgKGZvciBsb25nIHN0YWNrcyBzdXBwb3J0KVxuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gcHJvbWlzZTtcbiAgICAgICAgLy8gQ2FsbCBjYWxsYmFjayBhbmQgcmVzb2x2ZSBvdXIgbGlzdGVuZXIgd2l0aCBpdCdzIHJldHVybiB2YWx1ZS5cbiAgICAgICAgdmFyIHJldCwgdmFsdWUgPSBwcm9taXNlLl92YWx1ZTtcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlKSB7XG4gICAgICAgICAgICAvLyBjYiBpcyBvblJlc29sdmVkXG4gICAgICAgICAgICByZXQgPSBjYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjYiBpcyBvblJlamVjdGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0aW5nRXJyb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZWplY3RpbmdFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHJldCA9IGNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWplY3RpbmdFcnJvcnMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTsgLy8gQ2FsbGJhY2sgZGlkbnQgZG8gUHJvbWlzZS5yZWplY3QoZXJyKSBub3IgcmVqZWN0KGVycikgb250byBhbm90aGVyIHByb21pc2UuXG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIGluIGNhbGxiYWNrLiBSZWplY3Qgb3VyIGxpc3RlbmVyLlxuICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICAvLyBSZXN0b3JlIGVudiBhbmQgY3VycmVudEZ1bGZpbGxlci5cbiAgICAgICAgY3VycmVudEZ1bGZpbGxlciA9IG51bGw7XG4gICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgLS1saXN0ZW5lci5wc2QucmVmIHx8IGxpc3RlbmVyLnBzZC5maW5hbGl6ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFN0YWNrKHByb21pc2UsIHN0YWNrcywgbGltaXQpIHtcbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gbGltaXQpXG4gICAgICAgIHJldHVybiBzdGFja3M7XG4gICAgdmFyIHN0YWNrID0gXCJcIjtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBmYWlsdXJlID0gcHJvbWlzZS5fdmFsdWUsIGVycm9yTmFtZSwgbWVzc2FnZTtcbiAgICAgICAgaWYgKGZhaWx1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JOYW1lID0gZmFpbHVyZS5uYW1lIHx8IFwiRXJyb3JcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmYWlsdXJlLm1lc3NhZ2UgfHwgZmFpbHVyZTtcbiAgICAgICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2soZmFpbHVyZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlOyAvLyBJZiBlcnJvciBpcyB1bmRlZmluZWQgb3IgbnVsbCwgc2hvdyB0aGF0LlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnB1c2goZXJyb3JOYW1lICsgKG1lc3NhZ2UgPyBcIjogXCIgKyBtZXNzYWdlIDogXCJcIikgKyBzdGFjayk7XG4gICAgfVxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBzdGFjayA9IHByZXR0eVN0YWNrKHByb21pc2UuX3N0YWNrSG9sZGVyLCAyKTtcbiAgICAgICAgaWYgKHN0YWNrICYmIHN0YWNrcy5pbmRleE9mKHN0YWNrKSA9PT0gLTEpXG4gICAgICAgICAgICBzdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgIGlmIChwcm9taXNlLl9wcmV2KVxuICAgICAgICAgICAgZ2V0U3RhY2socHJvbWlzZS5fcHJldiwgc3RhY2tzLCBsaW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSwgcHJldikge1xuICAgIC8vIFN1cHBvcnQgbG9uZyBzdGFja3MgYnkgbGlua2luZyB0byBwcmV2aW91cyBjb21wbGV0ZWQgcHJvbWlzZS5cbiAgICB2YXIgbnVtUHJldiA9IHByZXYgPyBwcmV2Ll9udW1QcmV2ICsgMSA6IDA7XG4gICAgaWYgKG51bVByZXYgPCBMT05HX1NUQUNLU19DTElQX0xJTUlUKSB7XG4gICAgICAgIHByb21pc2UuX3ByZXYgPSBwcmV2O1xuICAgICAgICBwcm9taXNlLl9udW1QcmV2ID0gbnVtUHJldjtcbiAgICB9XG59XG4vKiBUaGUgY2FsbGJhY2sgdG8gc2NoZWR1bGUgd2l0aCBzZXRJbW1lZGlhdGUoKSBvciBzZXRUaW1lb3V0KCkuXG4gICBJdCBydW5zIGEgdmlydHVhbCBtaWNyb3RpY2sgYW5kIGV4ZWN1dGVzIGFueSBjYWxsYmFjayByZWdpc3RlcmVkIGluIG1pY3JvdGlja1F1ZXVlLlxuICovXG5mdW5jdGlvbiBwaHlzaWNhbFRpY2soKSB7XG4gICAgYmVnaW5NaWNyb1RpY2tTY29wZSgpICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7XG59XG5mdW5jdGlvbiBiZWdpbk1pY3JvVGlja1Njb3BlKCkge1xuICAgIHZhciB3YXNSb290RXhlYyA9IGlzT3V0c2lkZU1pY3JvVGljaztcbiAgICBpc091dHNpZGVNaWNyb1RpY2sgPSBmYWxzZTtcbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgIHJldHVybiB3YXNSb290RXhlYztcbn1cbi8qIEV4ZWN1dGVzIG1pY3JvLXRpY2tzIHdpdGhvdXQgZG9pbmcgdHJ5Li5jYXRjaC5cbiAgIFRoaXMgY2FuIGJlIHBvc3NpYmxlIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBpbnRlcm5hbGx5IGFuZFxuICAgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGFyZSBleGNlcHRpb24tc2FmZSAodGhleSBkbyB0cnkuLmNhdGNoXG4gICBpbnRlcm5hbGx5IGJlZm9yZSBjYWxsaW5nIGFueSBleHRlcm5hbCBtZXRob2QpLiBJZiByZWdpc3RlcmluZ1xuICAgZnVuY3Rpb25zIGluIHRoZSBtaWNyb3RpY2tRdWV1ZSB0aGF0IGFyZSBub3QgZXhjZXB0aW9uLXNhZmUsIHRoaXNcbiAgIHdvdWxkIGRlc3Ryb3kgdGhlIGZyYW1ld29yayBhbmQgbWFrZSBpdCBpbnN0YWJsZS4gU28gd2UgZG9uJ3QgZXhwb3J0XG4gICBvdXIgYXNhcCBtZXRob2QuXG4qL1xuZnVuY3Rpb24gZW5kTWljcm9UaWNrU2NvcGUoKSB7XG4gICAgdmFyIGNhbGxiYWNrcywgaSwgbDtcbiAgICBkbyB7XG4gICAgICAgIHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MgPSBtaWNyb3RpY2tRdWV1ZTtcbiAgICAgICAgICAgIG1pY3JvdGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICBsID0gY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBpdGVtWzBdLmFwcGx5KG51bGwsIGl0ZW1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCk7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWU7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXTtcbiAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC5fUFNELm9udW5oYW5kbGVkLmNhbGwobnVsbCwgcC5fdmFsdWUsIHApO1xuICAgIH0pO1xuICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7IC8vIENsb25lIGZpcnN0IGJlY2F1c2UgZmluYWxpemVyIG1heSByZW1vdmUgaXRzZWxmIGZyb20gbGlzdC5cbiAgICB2YXIgaSA9IGZpbmFsaXplcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpKVxuICAgICAgICBmaW5hbGl6ZXJzWy0taV0oKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZm4pIHtcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuICAgIH1cbiAgICB0aWNrRmluYWxpemVycy5wdXNoKGZpbmFsaXplcik7XG4gICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICBhc2FwJDEoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKSB7XG4gICAgLy8gT25seSBhZGQgdG8gdW5oYW5kbGVkRXJyb3JzIGlmIG5vdCBhbHJlYWR5IHRoZXJlLiBUaGUgZmlyc3Qgb25lIHRvIGFkZCB0byB0aGlzIGxpc3RcbiAgICAvLyB3aWxsIGJlIHVwb24gdGhlIGZpcnN0IHJlamVjdGlvbiBzbyB0aGF0IHRoZSByb290IGNhdXNlIChmaXJzdCBwcm9taXNlIGluIHRoZVxuICAgIC8vIHJlamVjdGlvbiBjaGFpbikgaXMgdGhlIG9uZSBsaXN0ZWQuXG4gICAgaWYgKCF1bmhhbmRsZWRFcnJvcnMuc29tZShmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlOyB9KSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5mdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuICAgIC8vIENhbGxlZCB3aGVuIGEgcmVqZWN0IGhhbmRsZWQgaXMgYWN0dWFsbHkgYmVpbmcgY2FsbGVkLlxuICAgIC8vIFNlYXJjaCBpbiB1bmhhbmRsZWRFcnJvcnMgZm9yIGFueSBwcm9taXNlIHdob3MgX3ZhbHVlIGlzIHRoaXMgcHJvbWlzZV92YWx1ZSAobGlzdFxuICAgIC8vIGNvbnRhaW5zIG9ubHkgcmVqZWN0ZWQgcHJvbWlzZXMsIGFuZCBvbmx5IG9uZSBpdGVtIHBlciBlcnJvcilcbiAgICB2YXIgaSA9IHVuaGFuZGxlZEVycm9ycy5sZW5ndGg7XG4gICAgd2hpbGUgKGkpXG4gICAgICAgIGlmICh1bmhhbmRsZWRFcnJvcnNbLS1pXS5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIHByb21pc2UgdGhhdCBmYWlsZWQgd2l0aCB0aGlzIHNhbWUgZXJyb3Igb2JqZWN0IHBvaW50ZXIsXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhhdCBzaW5jZSB0aGVyZSBpcyBhIGxpc3RlbmVyIHRoYXQgYWN0dWFsbHkgdGFrZXMgY2FyZSBvZiBpdC5cbiAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbn1cbmZ1bmN0aW9uIFByb21pc2VSZWplY3QocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKElOVEVSTkFMLCBmYWxzZSwgcmVhc29uKTtcbn1cbmZ1bmN0aW9uIHdyYXAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLCBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpXG4gICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vL1xuLy8gdmFyaWFibGVzIHVzZWQgZm9yIG5hdGl2ZSBhd2FpdCBzdXBwb3J0XG4vL1xudmFyIHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMCB9OyAvLyBUaGUgb25nb2luZyBtYWNyby10YXNrIHdoZW4gdXNpbmcgem9uZS1lY2hvaW5nLlxudmFyIHRhc2tDb3VudGVyID0gMDsgLy8gSUQgY291bnRlciBmb3IgbWFjcm8gdGFza3MuXG52YXIgem9uZVN0YWNrID0gW107IC8vIFN0YWNrIG9mIGxlZnQgem9uZXMgdG8gcmVzdG9yZSBhc3luY2hyb25pY2FsbHkuXG52YXIgem9uZUVjaG9lcyA9IDA7IC8vIHpvbmVFY2hvZXMgaXMgYSBtdXN0IGluIG9yZGVyIHRvIHBlcnNpc3Qgem9uZXMgYmV0d2VlbiBuYXRpdmUgYXdhaXQgZXhwcmVzc2lvbnMuXG52YXIgdG90YWxFY2hvZXMgPSAwOyAvLyBJRCBjb3VudGVyIGZvciBtaWNyby10YXNrcy4gVXNlZCB0byBkZXRlY3QgcG9zc2libGUgbmF0aXZlIGF3YWl0IGluIG91ciBQcm9taXNlLnByb3RvdHlwZS50aGVuLlxudmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXdTY29wZShmbiwgcHJvcHMkJDEsIGExLCBhMikge1xuICAgIHZhciBwYXJlbnQgPSBQU0QsIHBzZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuICAgIHBzZC5yZWYgPSAwO1xuICAgIHBzZC5nbG9iYWwgPSBmYWxzZTtcbiAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcbiAgICAvLyBQcmVwYXJlIGZvciBwcm9taXNlIHBhdGNoaW5nIChkb25lIGluIHVzZVBTRCk6XG4gICAgdmFyIGdsb2JhbEVudiA9IGdsb2JhbFBTRC5lbnY7XG4gICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IHsgdmFsdWU6IFByb21pc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgYWxsOiBQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogUHJvbWlzZS5yYWNlLFxuICAgICAgICByZXNvbHZlOiBQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4oZ2xvYmFsRW52Lm50aGVuLCBwc2QpLFxuICAgICAgICBndGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuKGdsb2JhbEVudi5ndGhlbiwgcHNkKSAvLyBnbG9iYWwgdGhlblxuICAgIH0gOiB7fTtcbiAgICBpZiAocHJvcHMkJDEpXG4gICAgICAgIGV4dGVuZChwc2QsIHByb3BzJCQxKTtcbiAgICAvLyB1bmhhbmRsZWRzIGFuZCBvbnVuaGFuZGxlZCBzaG91bGQgbm90IGJlIHNwZWNpZmljYWxseSBzZXQgaGVyZS5cbiAgICAvLyBMZWF2ZSB0aGVtIG9uIHBhcmVudCBwcm90b3R5cGUuXG4gICAgLy8gdW5oYW5kbGVkcy5wdXNoKGVycikgd2lsbCBwdXNoIHRvIHBhcmVudCdzIHByb3RvdHlwZVxuICAgIC8vIG9udW5oYW5kbGVkKCkgd2lsbCBjYWxsIHBhcmVudHMgb251bmhhbmRsZWQgKHdpdGggdGhpcyBzY29wZSdzIHRoaXMtcG9pbnRlciB0aG91Z2ghKVxuICAgICsrcGFyZW50LnJlZjtcbiAgICBwc2QuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC0tdGhpcy5wYXJlbnQucmVmIHx8IHRoaXMucGFyZW50LmZpbmFsaXplKCk7XG4gICAgfTtcbiAgICB2YXIgcnYgPSB1c2VQU0QocHNkLCBmbiwgYTEsIGEyKTtcbiAgICBpZiAocHNkLnJlZiA9PT0gMClcbiAgICAgICAgcHNkLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHJ2O1xufVxuLy8gRnVuY3Rpb24gdG8gY2FsbCBpZiBzY29wZUZ1bmMgcmV0dXJucyBOYXRpdmVQcm9taXNlXG4vLyBBbHNvIGZvciBlYWNoIE5hdGl2ZVByb21pc2UgaW4gdGhlIGFyZ3VtZW50cyB0byBQcm9taXNlLmFsbCgpXG5mdW5jdGlvbiBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suaWQpXG4gICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICsrdGFzay5hd2FpdHM7XG4gICAgdGFzay5lY2hvZXMgKz0gWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0YXNrLmlkO1xufVxuLy8gRnVuY3Rpb24gdG8gY2FsbCB3aGVuICd0aGVuJyBjYWxscyBiYWNrIG9uIGEgbmF0aXZlIHByb21pc2Ugd2hlcmUgb25Bd2FpdEV4cGVjdGVkKCkgaGFkIGJlZW4gY2FsbGVkLlxuLy8gQWxzbyBjYWxsIHRoaXMgd2hlbiBhIG5hdGl2ZSBhd2FpdCBjYWxscyB0aGVuIG1ldGhvZCBvbiBhIHByb21pc2UuIEluIHRoYXQgY2FzZSwgZG9uJ3Qgc3VwcGx5XG4vLyBzb3VyY2VUYXNrSWQgYmVjYXVzZSB3ZSBhbHJlYWR5IGtub3cgaXQgcmVmZXJzIHRvIGN1cnJlbnQgdGFzay5cbmZ1bmN0aW9uIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKHNvdXJjZVRhc2tJZCkge1xuICAgIGlmICghdGFzay5hd2FpdHMgfHwgKHNvdXJjZVRhc2tJZCAmJiBzb3VyY2VUYXNrSWQgIT09IHRhc2suaWQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApXG4gICAgICAgIHRhc2suaWQgPSAwO1xuICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgKiBaT05FX0VDSE9fTElNSVQ7IC8vIFdpbGwgcmVzZXQgZWNob2VzIHRvIDAgaWYgYXdhaXRzIGlzIDAuXG59XG4vLyBDYWxsIGZyb20gUHJvbWlzZS5hbGwoKSBhbmQgUHJvbWlzZS5yYWNlKClcbmZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyhwb3NzaWJsZVByb21pc2UpIHtcbiAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHpvbmVFbnRlckVjaG8odGFyZ2V0Wm9uZSkge1xuICAgICsrdG90YWxFY2hvZXM7XG4gICAgaWYgKCF0YXNrLmVjaG9lcyB8fCAtLXRhc2suZWNob2VzID09PSAwKSB7XG4gICAgICAgIHRhc2suZWNob2VzID0gdGFzay5pZCA9IDA7IC8vIENhbmNlbCB6b25lIGVjaG9pbmcuXG4gICAgfVxuICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG4gICAgc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIHRydWUpO1xufVxuZnVuY3Rpb24gem9uZUxlYXZlRWNobygpIHtcbiAgICB2YXIgem9uZSA9IHpvbmVTdGFja1t6b25lU3RhY2subGVuZ3RoIC0gMV07XG4gICAgem9uZVN0YWNrLnBvcCgpO1xuICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgYkVudGVyaW5nWm9uZSkge1xuICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcbiAgICBpZiAoYkVudGVyaW5nWm9uZSA/IHRhc2suZWNob2VzICYmICghem9uZUVjaG9lcysrIHx8IHRhcmdldFpvbmUgIT09IFBTRCkgOiB6b25lRWNob2VzICYmICghLS16b25lRWNob2VzIHx8IHRhcmdldFpvbmUgIT09IFBTRCkpIHtcbiAgICAgICAgLy8gRW50ZXIgb3IgbGVhdmUgem9uZSBhc3luY2hyb25pY2FsbHkgYXMgd2VsbCwgc28gdGhhdCB0YXNrcyBpbml0aWF0ZWQgZHVyaW5nIGN1cnJlbnQgdGlja1xuICAgICAgICAvLyB3aWxsIGJlIHN1cnJvdW5kZWQgYnkgdGhlIHpvbmUgd2hlbiB0aGV5IGFyZSBpbnZva2VkLlxuICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcbiAgICAgICAgcmV0dXJuO1xuICAgIFBTRCA9IHRhcmdldFpvbmU7IC8vIFRoZSBhY3R1YWwgem9uZSBzd2l0Y2ggb2NjdXJzIGF0IHRoaXMgbGluZS5cbiAgICAvLyBTbmFwc2hvdCBvbiBldmVyeSBsZWF2ZSBmcm9tIGdsb2JhbCB6b25lLlxuICAgIGlmIChjdXJyZW50Wm9uZSA9PT0gZ2xvYmFsUFNEKVxuICAgICAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbiAgICBpZiAocGF0Y2hHbG9iYWxQcm9taXNlKSB7XG4gICAgICAgIC8vIExldCdzIHBhdGNoIHRoZSBnbG9iYWwgYW5kIG5hdGl2ZSBQcm9taXNlcyAobWF5IGJlIHNhbWUgb3IgbWF5IGJlIGRpZmZlcmVudClcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgIC8vIFN3aWNoIGVudmlyb25tZW50cyAobWF5IGJlIFBTRC16b25lIG9yIHRoZSBnbG9iYWwgem9uZS4gQm90aCBhcHBseS4pXG4gICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcbiAgICAgICAgLy8gQ2hhbmdlIFByb21pc2UucHJvdG90eXBlLnRoZW4gZm9yIG5hdGl2ZSBhbmQgZ2xvYmFsIFByb21pc2UgKHRoZXkgTUFZIGRpZmZlciBvbiBwb2x5ZmlsbGVkIGVudmlyb25tZW50cywgYnV0IGJvdGggY2FuIGJlIGFjY2Vzc2VkKVxuICAgICAgICAvLyBNdXN0IGJlIGRvbmUgb24gZWFjaCB6b25lIGNoYW5nZSBiZWNhdXNlIHRoZSBwYXRjaGVkIG1ldGhvZCBjb250YWlucyB0YXJnZXRab25lIGluIGl0cyBjbG9zdXJlLlxuICAgICAgICBuYXRpdmVQcm9taXNlUHJvdG8udGhlbiA9IHRhcmdldEVudi5udGhlbjtcbiAgICAgICAgR2xvYmFsUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IHRhcmdldEVudi5ndGhlbjtcbiAgICAgICAgaWYgKGN1cnJlbnRab25lLmdsb2JhbCB8fCB0YXJnZXRab25lLmdsb2JhbCkge1xuICAgICAgICAgICAgLy8gTGVhdmluZyBvciBlbnRlcmluZyBnbG9iYWwgem9uZS4gSXQncyB0aW1lIHRvIHBhdGNoIC8gcmVzdG9yZSBnbG9iYWwgUHJvbWlzZS5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIFByb21pc2UgdG8gd2luZG93LlByb21pc2Ugc28gdGhhdCB0cmFuc2lsZWQgYXN5bmMgZnVuY3Rpb25zIHdpbGwgd29yayBvbiBGaXJlZm94LCBTYWZhcmkgYW5kIElFLCBhcyB3ZWxsIGFzIHdpdGggWm9uZWpzIGFuZCBhbmd1bGFyLlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9nbG9iYWwsICdQcm9taXNlJywgdGFyZ2V0RW52LlByb21pc2VQcm9wKTtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgUHJvbWlzZS5hbGwoKSBldGMgdG8gd29yayBpbmRleGVkREItc2FmZSBhbHNvIHdoZW4gcGVvcGxlIGFyZSBpbmNsdWRpbmcgZXM2LXByb21pc2UgYXMgYSBtb2R1bGUgKHRoZXkgbWlnaHRcbiAgICAgICAgICAgIC8vIG5vdCBiZSBhY2Nlc3NpbmcgZ2xvYmFsLlByb21pc2UgYnV0IGEgbG9jYWwgcmVmZXJlbmNlIHRvIGl0KVxuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGwgPSB0YXJnZXRFbnYuYWxsO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlc29sdmUgPSB0YXJnZXRFbnYucmVzb2x2ZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVqZWN0ID0gdGFyZ2V0RW52LnJlamVjdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNuYXBTaG90KCkge1xuICAgIHZhciBHbG9iYWxQcm9taXNlID0gX2dsb2JhbC5Qcm9taXNlO1xuICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IEdsb2JhbFByb21pc2UsXG4gICAgICAgIFByb21pc2VQcm9wOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9nbG9iYWwsIFwiUHJvbWlzZVwiKSxcbiAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogR2xvYmFsUHJvbWlzZS5yYWNlLFxuICAgICAgICByZXNvbHZlOiBHbG9iYWxQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogR2xvYmFsUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBuYXRpdmVQcm9taXNlUHJvdG8udGhlbixcbiAgICAgICAgZ3RoZW46IEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICB9IDoge307XG59XG5mdW5jdGlvbiB1c2VQU0QocHNkLCBmbiwgYTEsIGEyLCBhMykge1xuICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soam9iKSB7XG4gICAgLy9cbiAgICAvLyBQcmVjb25kaXRpb246IG5hdGl2ZVByb21pc2VUaGVuICE9PSB1bmRlZmluZWRcbiAgICAvL1xuICAgIG5hdGl2ZVByb21pc2VUaGVuLmNhbGwocmVzb2x2ZWROYXRpdmVQcm9taXNlLCBqb2IpO1xufVxuZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpXG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4ob3JpZ1RoZW4sIHpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdUaGVuLmNhbGwodGhpcywgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlc29sdmVkLCB6b25lLCBmYWxzZSksIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgem9uZSwgZmFsc2UpKTtcbiAgICB9O1xufVxudmFyIFVOSEFORExFRFJFSkVDVElPTiA9IFwidW5oYW5kbGVkcmVqZWN0aW9uXCI7XG5mdW5jdGlvbiBnbG9iYWxFcnJvcihlcnIsIHByb21pc2UpIHtcbiAgICB2YXIgcnY7XG4gICAgdHJ5IHtcbiAgICAgICAgcnYgPSBwcm9taXNlLm9udW5jYXRjaGVkKGVycik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICBpZiAocnYgIT09IGZhbHNlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGV2ZW50LCBldmVudERhdGEgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogZXJyIH07XG4gICAgICAgICAgICBpZiAoX2dsb2JhbC5kb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KFVOSEFORExFRFJFSkVDVElPTiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKGV2ZW50LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2dsb2JhbC5DdXN0b21FdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFVOSEFORExFRFJFSkVDVElPTiwgeyBkZXRhaWw6IGV2ZW50RGF0YSB9KTtcbiAgICAgICAgICAgICAgICBleHRlbmQoZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgX2dsb2JhbC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLlByb21pc2VSZWplY3Rpb25FdmVudCAmJiBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAvLyBObyBuYXRpdmUgc3VwcG9ydCBmb3IgUHJvbWlzZVJlamVjdGlvbkV2ZW50IGJ1dCB1c2VyIGhhcyBzZXQgd2luZG93Lm9udW5oYW5kbGVkcmVqZWN0aW9uLiBNYW51YWxseSBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5oYW5kbGVkIHJlamVjdGlvbjogXCIgKyAoZXJyLnN0YWNrIHx8IGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbn1cbnZhciByZWplY3Rpb24gPSBQcm9taXNlLnJlamVjdDtcblxuZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuICAgIHZhciBldnMgPSB7fTtcbiAgICB2YXIgcnYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUuIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYW4ganVzdCB0aGUgc3Vic2NyaWJlciB3YXMgcHJvdmlkZWQsIGZvcndhcmQgdGhlbSBhcyB3ZWxsLlxuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpXG4gICAgICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBpbnRlcmZhY2UgYWxsb3dpbmcgdG8gZmlyZSBvciB1bnN1YnNjcmliZSBmcm9tIGV2ZW50XG4gICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgICBmdW5jdGlvbiBhZGQoZXZlbnROYW1lLCBjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKCFjaGFpbkZ1bmN0aW9uKVxuICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuICAgICAgICBpZiAoIWRlZmF1bHRGdW5jdGlvbilcbiAgICAgICAgICAgIGRlZmF1bHRGdW5jdGlvbiA9IG5vcDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICBmaXJlOiBkZWZhdWx0RnVuY3Rpb24sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjb250ZXh0LnN1YnNjcmliZXJzLnJlZHVjZShjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBldnNbZXZlbnROYW1lXSA9IHJ2W2V2ZW50TmFtZV0gPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQ29uZmlndXJlZEV2ZW50cyhjZmcpIHtcbiAgICAgICAgLy8gZXZlbnRzKHRoaXMsIHtyZWFkaW5nOiBbZnVuY3Rpb25DaGFpbiwgbm9wXX0pO1xuICAgICAgICBrZXlzKGNmZykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGNmZ1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgICBhZGQoZXZlbnROYW1lLCBjZmdbZXZlbnROYW1lXVswXSwgY2ZnW2V2ZW50TmFtZV1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmF0aGVyIHRoYW4gYXBwcm9hY2hpbmcgZXZlbnQgc3Vic2NyaXB0aW9uIHVzaW5nIGEgZnVuY3Rpb25hbCBhcHByb2FjaCwgd2UgaGVyZSBkbyBpdCBpbiBhIGZvci1sb29wIHdoZXJlIHN1YnNjcmliZXIgaXMgZXhlY3V0ZWQgaW4gaXRzIG93biBzdGFja1xuICAgICAgICAgICAgICAgIC8vIGVuYWJsaW5nIHRoYXQgYW55IGV4Y2VwdGlvbiB0aGF0IG9jY3VyIHdvbnQgZGlzdHVyYiB0aGUgaW5pdGlhdG9yIGFuZCBhbHNvIG5vdCBuZXNjZXNzYXJ5IGJlIGNhdGNoZWQgYW5kIGZvcmdvdHRlbi5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGFkZChldmVudE5hbWUsIG1pcnJvciwgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1hemF0aW9uLXNhZmUgY2xvbmluZyBvZiBhcmd1bWVudHMgaW50byBhcmdzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZWFjaCBzdWJzY3JpYmVyOlxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2FwKGZ1bmN0aW9uIGZpcmVFdmVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGV2ZW50IGNvbmZpZ1wiKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKlxuICogRGV4aWUuanMgLSBhIG1pbmltYWxpc3RpYyB3cmFwcGVyIGZvciBJbmRleGVkREJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcgRGF2aWQgRmFobGFuZGVyXG4gKlxuICogVmVyc2lvbiAyLjAuNCwgRnJpIE1heSAyNSAyMDE4XG4gKlxuICogaHR0cDovL2RleGllLm9yZ1xuICpcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqL1xudmFyIERFWElFX1ZFUlNJT04gPSAnMi4wLjQnO1xudmFyIG1heFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUpO1xudmFyIG1heEtleSA9IChmdW5jdGlvbiAoKSB7IHRyeSB7XG4gICAgSURCS2V5UmFuZ2Uub25seShbW11dKTtcbiAgICByZXR1cm4gW1tdXTtcbn1cbmNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG1heFN0cmluZztcbn0gfSkoKTtcbnZhciBtaW5LZXkgPSAtSW5maW5pdHk7XG52YXIgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPSBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcbnZhciBTVFJJTkdfRVhQRUNURUQgPSBcIlN0cmluZyBleHBlY3RlZC5cIjtcbnZhciBjb25uZWN0aW9ucyA9IFtdO1xudmFyIGlzSUVPckVkZ2UgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvKE1TSUV8VHJpZGVudHxFZGdlKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnID0gaXNJRU9yRWRnZTtcbnZhciBoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSA9IGlzSUVPckVkZ2U7XG52YXIgZGV4aWVTdGFja0ZyYW1lRmlsdGVyID0gZnVuY3Rpb24gKGZyYW1lKSB7IHJldHVybiAhLyhkZXhpZVxcLmpzfGRleGllXFwubWluXFwuanMpLy50ZXN0KGZyYW1lKTsgfTtcbnZhciBkYk5hbWVzREI7IC8vIEdsb2JhbCBkYXRhYmFzZSBmb3IgYmFja2luZyBEZXhpZS5nZXREYXRhYmFzZU5hbWVzKCkgb24gYnJvd3NlciB3aXRob3V0IGluZGV4ZWREQi53ZWJraXRHZXREYXRhYmFzZU5hbWVzKCkgXG4vLyBJbml0IGRlYnVnXG5zZXREZWJ1ZyhkZWJ1ZywgZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcbmZ1bmN0aW9uIERleGllKGRiTmFtZSwgb3B0aW9ucykge1xuICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9wdGlvbnNcIiB0eXBlPVwiT2JqZWN0XCIgb3B0aW9uYWw9XCJ0cnVlXCI+U3BlY2lmeSBvbmx5IGlmIHlvdSB3aWNoIHRvIGNvbnRyb2wgd2hpY2ggYWRkb25zIHRoYXQgc2hvdWxkIHJ1biBvbiB0aGlzIGluc3RhbmNlPC9wYXJhbT5cbiAgICB2YXIgZGVwcyA9IERleGllLmRlcGVuZGVuY2llcztcbiAgICB2YXIgb3B0cyA9IGV4dGVuZCh7XG4gICAgICAgIC8vIERlZmF1bHQgT3B0aW9uc1xuICAgICAgICBhZGRvbnM6IERleGllLmFkZG9ucyxcbiAgICAgICAgYXV0b09wZW46IHRydWUsXG4gICAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsXG4gICAgICAgIElEQktleVJhbmdlOiBkZXBzLklEQktleVJhbmdlIC8vIEJhY2tlbmQgSURCS2V5UmFuZ2UgYXBpLiBEZWZhdWx0IHRvIGJyb3dzZXIgZW52LlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHZhciBhZGRvbnMgPSBvcHRzLmFkZG9ucywgYXV0b09wZW4gPSBvcHRzLmF1dG9PcGVuLCBpbmRleGVkREIgPSBvcHRzLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBvcHRzLklEQktleVJhbmdlO1xuICAgIHZhciBnbG9iYWxTY2hlbWEgPSB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuICAgIHZhciB2ZXJzaW9ucyA9IFtdO1xuICAgIHZhciBkYlN0b3JlTmFtZXMgPSBbXTtcbiAgICB2YXIgYWxsVGFibGVzID0ge307XG4gICAgLy8vPHZhciB0eXBlPVwiSURCRGF0YWJhc2VcIiAvPlxuICAgIHZhciBpZGJkYiA9IG51bGw7IC8vIEluc3RhbmNlIG9mIElEQkRhdGFiYXNlXG4gICAgdmFyIGRiT3BlbkVycm9yID0gbnVsbDtcbiAgICB2YXIgaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuICAgIHZhciBvblJlYWR5QmVpbmdGaXJlZCA9IG51bGw7XG4gICAgdmFyIG9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgIHZhciBSRUFET05MWSA9IFwicmVhZG9ubHlcIiwgUkVBRFdSSVRFID0gXCJyZWFkd3JpdGVcIjtcbiAgICB2YXIgZGIgPSB0aGlzO1xuICAgIHZhciBkYlJlYWR5UmVzb2x2ZSwgZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBkYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSksIGNhbmNlbE9wZW4sIG9wZW5DYW5jZWxsZXIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICAgIGNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgfSk7XG4gICAgdmFyIGF1dG9TY2hlbWEgPSB0cnVlO1xuICAgIHZhciBoYXNOYXRpdmVHZXREYXRhYmFzZU5hbWVzID0gISFnZXROYXRpdmVHZXREYXRhYmFzZU5hbWVzRm4oaW5kZXhlZERCKSwgaGFzR2V0QWxsO1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIC8vIERlZmF1bHQgc3Vic2NyaWJlcnMgdG8gXCJ2ZXJzaW9uY2hhbmdlXCIgYW5kIFwiYmxvY2tlZFwiLlxuICAgICAgICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBieSBjdXN0b20gaGFuZGxlcnMuIElmIGN1c3RvbSBoYW5kbGVycyByZXR1cm4gZmFsc2UsIHRoZXNlIGRlZmF1bHRcbiAgICAgICAgLy8gYmVoYXZpb3VycyB3aWxsIGJlIHByZXZlbnRlZC5cbiAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvciBmb3IgdmVyc2lvbmNoYW5nZSBldmVudCBpcyB0byBjbG9zZSBkYXRhYmFzZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIGJ5IGRvaW5nIGRiLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgICAgICAgLy8gTGV0J3Mgbm90IGJsb2NrIHRoZSBvdGhlciB3aW5kb3cgZnJvbSBtYWtpbmcgaXQncyBkZWxldGUoKSBvciBvcGVuKCkgY2FsbC5cbiAgICAgICAgICAgIC8vIE5PVEUhIFRoaXMgZXZlbnQgaXMgbmV2ZXIgZmlyZWQgaW4gSUUsRWRnZSBvciBTYWZhcmkuXG4gICAgICAgICAgICBpZiAoZXYubmV3VmVyc2lvbiA+IDApXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIHVwZ3JhZGUgZGF0YWJhc2UgJ1wiICsgZGIubmFtZSArIFwiJy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gZGVsZXRlIGRhdGFiYXNlICdcIiArIGRiLm5hbWUgKyBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgZGVsZXRlIHJlcXVlc3QuXCIpO1xuICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIEluIG1hbnkgd2ViIGFwcGxpY2F0aW9ucywgaXQgd291bGQgYmUgcmVjb21tZW5kZWQgdG8gZm9yY2Ugd2luZG93LnJlbG9hZCgpXG4gICAgICAgICAgICAvLyB3aGVuIHRoaXMgZXZlbnQgb2NjdXJzLiBUbyBkbyB0aGF0LCBzdWJzY3JpYmUgdG8gdGhlIHZlcnNpb25jaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIC8vIGFuZCBjYWxsIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSkgaWYgZXYubmV3VmVyc2lvbiA+IDAgKG5vdCBhIGRlbGV0aW9uKVxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHlvdXIgY3VycmVudCB3ZWIgYXBwIG9idmlvdXNseSBoYXMgb2xkIHNjaGVtYSBjb2RlIHRoYXQgbmVlZHNcbiAgICAgICAgICAgIC8vIHRvIGJlIHVwZGF0ZWQuIEFub3RoZXIgd2luZG93IGdvdCBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIGFwcCBhbmQgbmVlZHMgdG8gdXBncmFkZSBEQiBidXRcbiAgICAgICAgICAgIC8vIHlvdXIgd2luZG93IGlzIGJsb2NraW5nIGl0IHVubGVzcyB3ZSBjbG9zZSBpdCBoZXJlLlxuICAgICAgICB9KTtcbiAgICAgICAgZGIub24oXCJibG9ja2VkXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRleGllLmRlbGV0ZSgnXCIgKyBkYi5uYW1lICsgXCInKSB3YXMgYmxvY2tlZFwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVcGdyYWRlICdcIiArIGRiLm5hbWUgKyBcIicgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiBcIiArIGV2Lm9sZFZlcnNpb24gLyAxMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFZlcnNpb25pbmcgRnJhbWV3b3JrLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgdGhpcy52ZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVyc2lvbk51bWJlclwiIHR5cGU9XCJOdW1iZXJcIj48L3BhcmFtPlxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIlZlcnNpb25cIj48L3JldHVybnM+XG4gICAgICAgIGlmIChpZGJkYiB8fCBpc0JlaW5nT3BlbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiQ2Fubm90IGFkZCB2ZXJzaW9uIHdoZW4gZGF0YWJhc2UgaXMgb3BlblwiKTtcbiAgICAgICAgdGhpcy52ZXJubyA9IE1hdGgubWF4KHRoaXMudmVybm8sIHZlcnNpb25OdW1iZXIpO1xuICAgICAgICB2YXIgdmVyc2lvbkluc3RhbmNlID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA9PT0gdmVyc2lvbk51bWJlcjsgfSlbMF07XG4gICAgICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICB2ZXJzaW9uSW5zdGFuY2UgPSBuZXcgVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uSW5zdGFuY2UpO1xuICAgICAgICB2ZXJzaW9ucy5zb3J0KGxvd2VyVmVyc2lvbkZpcnN0KTtcbiAgICAgICAgLy8gRGlzYWJsZSBhdXRvc2NoZW1hIG1vZGUsIGFzIGF0IGxlYXN0IG9uZSB2ZXJzaW9uIGlzIHNwZWNpZmllZC5cbiAgICAgICAgYXV0b1NjaGVtYSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2NmZyA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG4gICAgICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBkYnNjaGVtYToge30sXG4gICAgICAgICAgICB0YWJsZXM6IHt9LFxuICAgICAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9yZXMoe30pOyAvLyBEZXJpdmUgZWFybGllciBzY2hlbWFzIGJ5IGRlZmF1bHQuXG4gICAgfVxuICAgIGV4dGVuZChWZXJzaW9uLnByb3RvdHlwZSwge1xuICAgICAgICBzdG9yZXM6IGZ1bmN0aW9uIChzdG9yZXMpIHtcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyAgIERlZmluZXMgdGhlIHNjaGVtYSBmb3IgYSBwYXJ0aWN1bGFyIHZlcnNpb25cbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdG9yZXNcIiB0eXBlPVwiT2JqZWN0XCI+XG4gICAgICAgICAgICAvLy8gRXhhbXBsZTogPGJyLz5cbiAgICAgICAgICAgIC8vLyAgIHt1c2VyczogXCJpZCsrLGZpcnN0LGxhc3QsJmFtcDt1c2VybmFtZSwqZW1haWxcIiwgPGJyLz5cbiAgICAgICAgICAgIC8vLyAgIHBhc3N3b3JkczogXCJpZCsrLCZhbXA7dXNlcm5hbWVcIn08YnIvPlxuICAgICAgICAgICAgLy8vIDxici8+XG4gICAgICAgICAgICAvLy8gU3ludGF4OiB7VGFibGU6IFwiW3ByaW1hcnlLZXldWysrXSxbJmFtcDtdWypdaW5kZXgxLFsmYW1wO11bKl1pbmRleDIsLi4uXCJ9PGJyLz48YnIvPlxuICAgICAgICAgICAgLy8vIFNwZWNpYWwgY2hhcmFjdGVyczo8YnIvPlxuICAgICAgICAgICAgLy8vICBcIiZhbXA7XCIgIG1lYW5zIHVuaXF1ZSBrZXksIDxici8+XG4gICAgICAgICAgICAvLy8gIFwiKlwiICBtZWFucyB2YWx1ZSBpcyBtdWx0aUVudHJ5LCA8YnIvPlxuICAgICAgICAgICAgLy8vICBcIisrXCIgbWVhbnMgYXV0by1pbmNyZW1lbnQgYW5kIG9ubHkgYXBwbGljYWJsZSBmb3IgcHJpbWFyeSBrZXkgPGJyLz5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA9IHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPyBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKSA6IHN0b3JlcztcbiAgICAgICAgICAgIC8vIERlcml2ZSBzdG9yZXMgZnJvbSBlYXJsaWVyIHZlcnNpb25zIGlmIHRoZXkgYXJlIG5vdCBleHBsaWNpdGVseSBzcGVjaWZpZWQgYXMgbnVsbCBvciBhIG5ldyBzeW50YXguXG4gICAgICAgICAgICB2YXIgc3RvcmVzU3BlYyA9IHt9O1xuICAgICAgICAgICAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRic2NoZW1hID0gKHRoaXMuX2NmZy5kYnNjaGVtYSA9IHt9KTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXNTcGVjLCBkYnNjaGVtYSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhdGVzdCBzY2hlbWEgdG8gdGhpcyB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBVcGRhdGUgQVBJXG4gICAgICAgICAgICBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShbYWxsVGFibGVzLCBkYiwgVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7IC8vIEtlZXAgVHJhbnNhY3Rpb24ucHJvdG90eXBlIGV2ZW4gdGhvdWdoIGl0IHNob3VsZCBiZSBkZXByLlxuICAgICAgICAgICAgc2V0QXBpT25QbGFjZShbYWxsVGFibGVzLCBkYiwgVHJhbnNhY3Rpb24ucHJvdG90eXBlLCB0aGlzLl9jZmcudGFibGVzXSwga2V5cyhkYnNjaGVtYSksIGRic2NoZW1hKTtcbiAgICAgICAgICAgIGRiU3RvcmVOYW1lcyA9IGtleXMoZGJzY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZ3JhZGU6IGZ1bmN0aW9uICh1cGdyYWRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSA9IHVwZ3JhZGVGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfcGFyc2VTdG9yZXNTcGVjOiBmdW5jdGlvbiAoc3RvcmVzLCBvdXRTY2hlbWEpIHtcbiAgICAgICAgICAgIGtleXMoc3RvcmVzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlVGVtcGxhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBwYXJzZUluZGV4U3ludGF4KHN0b3Jlc1t0YWJsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm11bHRpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpLXZhbHVlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkua2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbnN0YW5jZVRlbXBsYXRlLCBwcmltS2V5LmtleVBhdGgsIHByaW1LZXkuYXV0byA/IDAgOiBwcmltS2V5LmtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5hdXRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIk9ubHkgcHJpbWFyeSBrZXkgY2FuIGJlIG1hcmtlZCBhcyBhdXRvSW5jcmVtZW50ICgrKylcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkluZGV4IG11c3QgaGF2ZSBhIG5hbWUgYW5kIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaW5zdGFuY2VUZW1wbGF0ZSwgaWR4LmtleVBhdGgsIGlkeC5jb21wb3VuZCA/IGlkeC5rZXlQYXRoLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiOyB9KSA6IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0U2NoZW1hW3RhYmxlTmFtZV0gPSBuZXcgVGFibGVTY2hlbWEodGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzLCBpbnN0YW5jZVRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJ1blVwZ3JhZGVycyhvbGRWZXJzaW9uLCBpZGJ0cmFucywgcmVqZWN0KSB7XG4gICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihSRUFEV1JJVEUsIGRiU3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgICAgICAgdHJhbnMuY3JlYXRlKGlkYnRyYW5zKTtcbiAgICAgICAgdHJhbnMuX2NvbXBsZXRpb24uY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgdmFyIHJlamVjdFRyYW5zYWN0aW9uID0gdHJhbnMuX3JlamVjdC5iaW5kKHRyYW5zKTtcbiAgICAgICAgbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0YWJsZXM6XG4gICAgICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLmZvbGxvdyhmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5vbi5wb3B1bGF0ZS5maXJlKHRyYW5zKTsgfSkuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMob2xkVmVyc2lvbiwgdHJhbnMsIGlkYnRyYW5zKS5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKG9sZFZlcnNpb24sIHRyYW5zLCBpZGJ0cmFucykge1xuICAgICAgICAvLyBVcGdyYWRlIHZlcnNpb24gdG8gdmVyc2lvbiwgc3RlcC1ieS1zdGVwIGZyb20gb2xkZXN0IHRvIG5ld2VzdCB2ZXJzaW9uLlxuICAgICAgICAvLyBFYWNoIHRyYW5zYWN0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIHRhYmxlIHNldCB0aGF0IHdhcyBjdXJyZW50IGluIHRoYXQgdmVyc2lvbiAoYnV0IGFsc28gbm90LXlldC1kZWxldGVkIHRhYmxlcyBmcm9tIGl0cyBwcmV2aW91cyB2ZXJzaW9uKVxuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIG9sZFZlcnNpb25TdHJ1Y3QgPSB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24gKHZlcnNpb24pIHsgcmV0dXJuIHZlcnNpb24uX2NmZy52ZXJzaW9uID09PSBvbGRWZXJzaW9uOyB9KVswXTtcbiAgICAgICAgaWYgKCFvbGRWZXJzaW9uU3RydWN0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIkRleGllIHNwZWNpZmljYXRpb24gb2YgY3VycmVudGx5IGluc3RhbGxlZCBEQiB2ZXJzaW9uIGlzIG1pc3NpbmdcIik7XG4gICAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG9sZFZlcnNpb25TdHJ1Y3QuX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgdmFyIGFueUNvbnRlbnRVcGdyYWRlckhhc1J1biA9IGZhbHNlO1xuICAgICAgICB2YXIgdmVyc1RvUnVuID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb247IH0pO1xuICAgICAgICB2ZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVyc2lvblwiIHR5cGU9XCJWZXJzaW9uXCI+PC9wYXJhbT5cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhvbGRTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgICAgICAgICAgICBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBuZXdTY2hlbWE7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGFibGVzICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkaWZmLmFkZC5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJ0cmFucywgdHVwbGVbMF0sIHR1cGxlWzFdLnByaW1LZXksIHR1cGxlWzFdLmluZGV4ZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0YWJsZXNcbiAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIk5vdCB5ZXQgc3VwcG9ydCBmb3IgY2hhbmdpbmcgcHJpbWFyeSBrZXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShjaGFuZ2UubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgaW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlSW5kZXgoaWR4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgaW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5mb3JFYWNoKGZ1bmN0aW9uIChpZHhOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlSW5kZXgoaWR4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uLl9jZmcuY29udGVudFVwZ3JhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24uX2NmZy5jb250ZW50VXBncmFkZSh0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoaWRidHJhbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFueUNvbnRlbnRVcGdyYWRlckhhc1J1biB8fCAhaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgb2xkIHRhYmxlc1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm93LCBjcmVhdGUgYSBxdWV1ZSBleGVjdXRpb24gZW5naW5lXG4gICAgICAgIGZ1bmN0aW9uIHJ1blF1ZXVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLmxlbmd0aCA/IFByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5RdWV1ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhnbG9iYWxTY2hlbWEsIGlkYnRyYW5zKTsgLy8gQXQgbGFzdCwgbWFrZSBzdXJlIHRvIGNyZWF0ZSBhbnkgbWlzc2luZyB0YWJsZXMuIChOZWVkZWQgYnkgYWRkb25zIHRoYXQgYWRkIHN0b3JlcyB0byBEQiB3aXRob3V0IHNwZWNpZnlpbmcgdmVyc2lvbilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgICAgICBkZWw6IFtdLFxuICAgICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICAgIGNoYW5nZTogW10gLy8gQXJyYXkgb2Yge25hbWU6IHRhYmxlTmFtZSwgcmVjcmVhdGU6IG5ld0RlZmluaXRpb24sIGRlbDogZGVsSW5kZXhOYW1lcywgYWRkOiBuZXdJbmRleERlZnMsIGNoYW5nZTogY2hhbmdlZEluZGV4RGVmc31cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgdGFibGUgaW4gb2xkU2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pXG4gICAgICAgICAgICAgICAgZGlmZi5kZWwucHVzaCh0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh0YWJsZSBpbiBuZXdTY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBvbGREZWYgPSBvbGRTY2hlbWFbdGFibGVdLCBuZXdEZWYgPSBuZXdTY2hlbWFbdGFibGVdO1xuICAgICAgICAgICAgaWYgKCFvbGREZWYpIHtcbiAgICAgICAgICAgICAgICBkaWZmLmFkZC5wdXNoKFt0YWJsZSwgbmV3RGVmXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBuZXdEZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG9sZERlZi5wcmltS2V5LnNyYyAhPT0gbmV3RGVmLnByaW1LZXkuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1hcnkga2V5IGhhcyBjaGFuZ2VkLiBSZW1vdmUgYW5kIHJlLWFkZCB0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnJlY3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FtZSBwcmltYXJ5IGtleS4gSnVzdCBmaW5kIG91dCB3aGF0IGRpZmZlcnM6XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRJbmRleGVzID0gb2xkRGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0luZGV4ZXMgPSBuZXdEZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3SW5kZXhlc1tpZHhOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLnB1c2goaWR4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG5ld0luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRJZHggPSBvbGRJbmRleGVzW2lkeE5hbWVdLCBuZXdJZHggPSBuZXdJbmRleGVzW2lkeE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRJZHguc3JjICE9PSBuZXdJZHguc3JjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZGVsLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmFkZC5sZW5ndGggPiAwIHx8IGNoYW5nZS5jaGFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlkYnRyYW5zXCIgdHlwZT1cIklEQlRyYW5zYWN0aW9uXCI+PC9wYXJhbT5cbiAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVOYW1lLCBwcmltS2V5LmtleVBhdGggPyB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOiB7IGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9KTtcbiAgICAgICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgYWRkSW5kZXgoc3RvcmUsIGlkeCk7IH0pO1xuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuICAgICAgICBrZXlzKG5ld1NjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGFibGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIG5ld1NjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIG5ld1NjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAobmV3U2NoZW1hW3N0b3JlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkSW5kZXgoc3RvcmUsIGlkeCkge1xuICAgICAgICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy9cbiAgICAvLyAgICAgIERleGllIFByb3RlY3RlZCBBUElcbiAgICAvL1xuICAgIC8vXG4gICAgdGhpcy5fYWxsVGFibGVzID0gYWxsVGFibGVzO1xuICAgIHRoaXMuX2NyZWF0ZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgfTtcbiAgICAvKiBHZW5lcmF0ZSBhIHRlbXBvcmFyeSB0cmFuc2FjdGlvbiB3aGVuIGRiIG9wZXJhdGlvbnMgYXJlIGRvbmUgb3V0c2lkZSBhIHRyYW5zYWN0aW9uIHNjb3BlLlxuICAgICovXG4gICAgZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGZuKSB7XG4gICAgICAgIGlmICghb3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2gpKSB7XG4gICAgICAgICAgICBpZiAoIWlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF1dG9PcGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApOyAvLyBPcGVuIGluIGJhY2tncm91bmQuIElmIGlmIGZhaWxzLCBpdCB3aWxsIGJlIGNhdGNoZWQgYnkgdGhlIGZpbmFsIHByb21pc2UgYW55d2F5LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGZuKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhbnMuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgcmVzb2x2aW5nIHZhbHVlIGRpcmVjdGx5LCB3YWl0IHdpdGggcmVzb2x2aW5nIGl0IHVudGlsIHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBkYXRhIHdvdWxkIG5vdCBiZSBpbiB0aGUgREIgaWYgcmVxdWVzdGluZyBpdCBpbiB0aGUgdGhlbigpIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBTcGVjaWZpY2FsbHksIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiB3aWxsIHdvcms6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIGRiLmZyaWVuZHMucHV0KHtuYW1lOiBcIkFybmVcIn0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIGRiLmZyaWVuZHMud2hlcmUoXCJuYW1lXCIpLmVxdWFscyhcIkFybmVcIikuY291bnQoZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgYXNzZXJ0IChjb3VudCA9PT0gMSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdDsgfSk7XG4gICAgICAgICAgICB9KTsgLyouY2F0Y2goZXJyID0+IHsgLy8gRG9uJ3QgZG8gdGhpcyBhcyBvZiBub3cuIElmIHdvdWxkIGFmZmVjdCBidWxrLSBhbmQgbW9kaWZ5IG1ldGhvZHMgaW4gYSB3YXkgdGhhdCBjb3VsZCBiZSBtb3JlIGludHVpdGl2ZS4gQnV0IHdhaXQhIE1heWJlIGNoYW5nZSBpbiBuZXh0IG1ham9yLlxuICAgICAgICAgICAgICAgIHRyYW5zLl9yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG4gICAgICAgICAgICB9KTsqL1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3doZW5SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gb3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoID8gZm4oKSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICghaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghYXV0b09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApOyAvLyBPcGVuIGluIGJhY2tncm91bmQuIElmIGlmIGZhaWxzLCBpdCB3aWxsIGJlIGNhdGNoZWQgYnkgdGhlIGZpbmFsIHByb21pc2UgYW55d2F5LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGJSZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKGZuKTtcbiAgICB9O1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgLy8gICAgICBEZXhpZSBBUElcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICB0aGlzLnZlcm5vID0gMDtcbiAgICB0aGlzLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0JlaW5nT3BlbmVkIHx8IGlkYmRiKVxuICAgICAgICAgICAgcmV0dXJuIGRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZGJPcGVuRXJyb3IgPyByZWplY3Rpb24oZGJPcGVuRXJyb3IpIDogZGI7IH0pO1xuICAgICAgICBkZWJ1ZyAmJiAob3BlbkNhbmNlbGxlci5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpKTsgLy8gTGV0IHN0YWNrcyBwb2ludCB0byB3aGVuIG9wZW4oKSB3YXMgY2FsbGVkIHJhdGhlciB0aGFuIHdoZXJlIG5ldyBEZXhpZSgpIHdhcyBjYWxsZWQuXG4gICAgICAgIGlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICAgICAgICBkYk9wZW5FcnJvciA9IG51bGw7XG4gICAgICAgIG9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAvLyBGdW5jdGlvbiBwb2ludGVycyB0byBjYWxsIHdoZW4gdGhlIGNvcmUgb3BlbmluZyBwcm9jZXNzIGNvbXBsZXRlcy5cbiAgICAgICAgdmFyIHJlc29sdmVEYlJlYWR5ID0gZGJSZWFkeVJlc29sdmUsIFxuICAgICAgICAvLyB1cGdyYWRlVHJhbnNhY3Rpb24gdG8gYWJvcnQgb24gZmFpbHVyZS5cbiAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbb3BlbkNhbmNlbGxlciwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGRiLnZlcm5vIHdpdGggMTAgd2lsbCBiZSBuZWVkZWQgdG8gd29ya2Fyb3VuZCB1cGdyYWRpbmcgYnVnIGluIElFOlxuICAgICAgICAgICAgICAgIC8vIElFIGZhaWxzIHdoZW4gZGVsZXRpbmcgb2JqZWN0U3RvcmUgYWZ0ZXIgcmVhZGluZyBmcm9tIGl0LlxuICAgICAgICAgICAgICAgIC8vIEEgZnV0dXJlIHZlcnNpb24gb2YgRGV4aWUuanMgd2lsbCBzdG9wb3ZlciBhbiBpbnRlcm1lZGlhdGUgdmVyc2lvbiB0byB3b3JrYXJvdW5kIHRoaXMuXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhhdCBwb2ludCwgd2Ugd2FudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlLiBDb3VsZCBoYXZlIGJlZW4gbXVsdGlwbGllZCB3aXRoIDIsIGJ1dCBieSB1c2luZyAxMCwgaXQgaXMgZWFzaWVyIHRvIG1hcCB0aGUgbnVtYmVyIHRvIHRoZSByZWFsIHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgICAgICAgIC8vIElmIG5vIEFQSSwgdGhyb3chXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleGVkREIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoXCJpbmRleGVkREIgQVBJIG5vdCBmb3VuZC4gSWYgdXNpbmcgSUUxMCssIG1ha2Ugc3VyZSB0byBydW4geW91ciBjb2RlIG9uIGEgc2VydmVyIFVSTCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihub3QgbG9jYWxseSkuIElmIHVzaW5nIG9sZCBTYWZhcmkgdmVyc2lvbnMsIG1ha2Ugc3VyZSB0byBpbmNsdWRlIGluZGV4ZWREQiBwb2x5ZmlsbC5cIik7XG4gICAgICAgICAgICAgICAgdmFyIHJlcSA9IGF1dG9TY2hlbWEgPyBpbmRleGVkREIub3BlbihkYk5hbWUpIDogaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBNYXRoLnJvdW5kKGRiLnZlcm5vICogMTApKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShcIkluZGV4ZWREQiBBUEkgbm90IGF2YWlsYWJsZVwiKTsgLy8gTWF5IGhhcHBlbiBpbiBTYWZhcmkgcHJpdmF0ZSBtb2RlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzEzNFxuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHdyYXAoZmlyZU9uQmxvY2tlZCk7XG4gICAgICAgICAgICAgICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHdyYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b1NjaGVtYSAmJiAhZGIuX2FsbG93RW1wdHlEQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVyIGRpZCBub3Qgc3BlY2lmeSBhIHZlcnNpb24gb3Igc2NoZW1hLiBEb2luZyB0aGF0IGlzIG9ubHkgYWNjZXB0YWJsZSBmb3Igb3BlbmluZyBhbHJlYWQgZXhpc3RpbmcgZGF0YWJhc2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb251cGdyYWRlbmVlZGVkIGlzIGNhbGxlZCBpdCBtZWFucyBkYXRhYmFzZSBkaWQgbm90IGV4aXN0LiBSZWplY3QgdGhlIG9wZW4oKSBwcm9taXNlIGFuZCBtYWtlIHN1cmUgdGhhdCB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSBhIG5ldyBkYXRhYmFzZSBieSBhY2NpZGVudCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBwcmV2ZW50RGVmYXVsdDsgLy8gUHJvaGliaXQgb25hYm9ydCBlcnJvciBmcm9tIGZpcmluZyBiZWZvcmUgd2UncmUgZG9uZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpOyAvLyBBYm9ydCB0cmFuc2FjdGlvbiAod291bGQgaG9wZSB0aGF0IHRoaXMgd291bGQgbWFrZSBEQiBkaXNhcHBlYXIgYnV0IGl0IGRvZXNudC4pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBkYXRhYmFzZSBhbmQgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpOyAvLyBUaGUgdXBncmFkZSB0cmFuc2FjdGlvbiBpcyBhdG9taWMsIGFuZCBqYXZhc2NyaXB0IGlzIHNpbmdsZSB0aHJlYWRlZCAtIG1lYW5pbmcgdGhhdCB0aGVyZSBpcyBubyByaXNrIHRoYXQgd2UgZGVsZXRlIHNvbWVvbmUgZWxzZXMgZGF0YWJhc2UgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHJlcS5vbnN1Y2Nlc3MgPSBkZWxyZXEub25lcnJvciA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5Ob1N1Y2hEYXRhYmFzZShcIkRhdGFiYXNlIFwiICsgZGJOYW1lICsgXCIgZG9lc250IGV4aXN0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRWZXIgPSBlLm9sZFZlcnNpb24gPiBNYXRoLnBvdygyLCA2MikgPyAwIDogZS5vbGRWZXJzaW9uOyAvLyBTYWZhcmkgOCBmaXguXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5VcGdyYWRlcnMob2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcmUgb3BlbmluZyBwcm9jZWR1cmUgY29tcGxldGUuIE5vdyBsZXQncyBqdXN0IHJlY29yZCBzb21lIHN0dWZmLlxuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZGJkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpOyAvLyBVc2VkIGZvciBlbXVsYXRpbmcgdmVyc2lvbmNoYW5nZSBldmVudCBvbiBJRS9FZGdlL1NhZmFyaS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9TY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkR2xvYmFsU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhnbG9iYWxTY2hlbWEsIGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyksIFJFQURPTkxZKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBtYXkgYmFpbCBvdXQgaWYgPiAxIHN0b3JlIG5hbWVzLiBIb3dldmVyLCB0aGlzIHNob3VsZG50IGJlIGEgc2hvd3N0b3BwZXIuIElzc3VlICMxMjAuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLl92Y0ZpcmVkID0gdHJ1ZTsgLy8gZGV0ZWN0IGltcGxlbWVudGF0aW9ucyB0aGF0IG5vdCBzdXBwb3J0IHZlcnNpb25jaGFuZ2UgKElFL0VkZ2UvU2FmYXJpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNOYXRpdmVHZXREYXRhYmFzZU5hbWVzICYmIGRiTmFtZSAhPT0gJ19fZGJuYW1lcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiTmFtZXNEQi5kYm5hbWVzLnB1dCh7IG5hbWU6IGRiTmFtZSB9KS5jYXRjaChub3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSldKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEJlZm9yZSBmaW5hbGx5IHJlc29sdmluZyB0aGUgZGJSZWFkeVByb21pc2UgYW5kIHRoaXMgcHJvbWlzZSxcbiAgICAgICAgICAgIC8vIGNhbGwgYW5kIGF3YWl0IGFsbCBvbigncmVhZHknKSBzdWJzY3JpYmVyczpcbiAgICAgICAgICAgIC8vIERleGllLnZpcCgpIG1ha2VzIHN1YnNjcmliZXJzIGFibGUgdG8gdXNlIHRoZSBkYXRhYmFzZSB3aGlsZSBiZWluZyBvcGVuZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbXVzdCBzaW5jZSB0aGVzZSBzdWJzY3JpYmVycyB0YWtlIHBhcnQgb2YgdGhlIG9wZW5pbmcgcHJvY2VkdXJlLlxuICAgICAgICAgICAgb25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoRGV4aWUudmlwKGRiLm9uLnJlYWR5LmZpcmUpKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuICAgICAgICAgICAgICAgIGlmIChvblJlYWR5QmVpbmdGaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgYWRkaXRpb25hbCBzdWJzY3JpYmVycyB0byBkYi5vbigncmVhZHknKSB3ZXJlIGFkZGVkIGR1cmluZyB0aGUgdGltZSBkYi5vbi5yZWFkeS5maXJlIHdhcyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlcnMgPSBvblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuICAgICAgICAgICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKERleGllLnZpcChyZW1haW5kZXJzKSkudGhlbihmaXJlUmVtYWluZGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIGRiLm9wZW4oKSB3aXRoIHRoZSBkYiBpbnN0YW5jZS5cbiAgICAgICAgICAgIGlzQmVpbmdPcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBEaWQgd2UgZmFpbCB3aXRoaW4gb251cGdyYWRlbmVlZGVkPyBNYWtlIHN1cmUgdG8gYWJvcnQgdGhlIHVwZ3JhZGUgdHJhbnNhY3Rpb24gc28gaXQgZG9lc250IGNvbW1pdC5cbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gJiYgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICBpc0JlaW5nT3BlbmVkID0gZmFsc2U7IC8vIFNldCBiZWZvcmUgY2FsbGluZyBkYi5jbG9zZSgpIHNvIHRoYXQgaXQgZG9lc250IHJlamVjdCBvcGVuQ2FuY2VsbGVyIGFnYWluIChsZWFkcyB0byB1bmhhbmRsZWQgcmVqZWN0aW9uIGV2ZW50KS5cbiAgICAgICAgICAgIGRiLmNsb3NlKCk7IC8vIENsb3NlcyBhbmQgcmVzZXRzIGlkYmRiLCByZW1vdmVzIGNvbm5lY3Rpb25zLCByZXNldHMgZGJSZWFkeVByb21pc2UgYW5kIG9wZW5DYW5jZWxsZXIgc28gdGhhdCBhIGxhdGVyIGRiLm9wZW4oKSBpcyBmcmVzaC5cbiAgICAgICAgICAgIC8vIEEgY2FsbCB0byBkYi5jbG9zZSgpIG1heSBoYXZlIG1hZGUgb24tcmVhZHkgc3Vic2NyaWJlcnMgZmFpbC4gVXNlIGRiT3BlbkVycm9yIGlmIHNldCwgc2luY2UgZXJyIGNvdWxkIGJlIGEgZm9sbG93LXVwIGVycm9yIG9uIHRoYXQuXG4gICAgICAgICAgICBkYk9wZW5FcnJvciA9IGVycjsgLy8gUmVjb3JkIHRoZSBlcnJvci4gSXQgd2lsbCBiZSB1c2VkIHRvIHJlamVjdCBmdXJ0aGVyIHByb21pc2VzIG9mIGRiIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGRiT3BlbkVycm9yKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZURiUmVhZHkoKTsgLy8gZGJSZWFkeVByb21pc2UgaXMgcmVzb2x2ZWQgbm8gbWF0dGVyIGlmIG9wZW4oKSByZWplY3RzIG9yIHJlc29sdmVkLiBJdCdzIGp1c3QgdG8gd2FrZSB1cCB3YWl0ZXJzLlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSBjb25uZWN0aW9ucy5pbmRleE9mKGRiKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIGlmIChpZGJkYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZGJkYi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgaWRiZGIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGF1dG9PcGVuID0gZmFsc2U7XG4gICAgICAgIGRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICAgICAgaWYgKGlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICBjYW5jZWxPcGVuKGRiT3BlbkVycm9yKTtcbiAgICAgICAgLy8gUmVzZXQgZGJSZWFkeVByb21pc2UgcHJvbWlzZTpcbiAgICAgICAgZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgb3BlbkNhbmNlbGxlciA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNBcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG5vdCBhbGxvd2VkIGluIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgICAgICAgaWYgKGlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBkYlJlYWR5UHJvbWlzZS50aGVuKGRvRGVsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvRGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkb0RlbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzTmF0aXZlR2V0RGF0YWJhc2VOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGJOYW1lc0RCLmRibmFtZXMuZGVsZXRlKGRiTmFtZSkuY2F0Y2gobm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXEub25ibG9ja2VkID0gZmlyZU9uQmxvY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmJhY2tlbmREQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkYmRiO1xuICAgIH07XG4gICAgdGhpcy5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZGJkYiAhPT0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuaGFzQmVlbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRiT3BlbkVycm9yICYmIChkYk9wZW5FcnJvciBpbnN0YW5jZW9mIGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYXNGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkYk9wZW5FcnJvciAhPT0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuZHluYW1pY2FsbHlPcGVuZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhdXRvU2NoZW1hO1xuICAgIH07XG4gICAgLy9cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgLy9cbiAgICB0aGlzLm5hbWUgPSBkYk5hbWU7XG4gICAgLy8gZGIudGFibGVzIC0gYW4gYXJyYXkgb2YgYWxsIFRhYmxlIGluc3RhbmNlcy5cbiAgICBwcm9wcyh0aGlzLCB7XG4gICAgICAgIHRhYmxlczoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJBcnJheVwiIGVsZW1lbnRUeXBlPVwiVGFibGVcIiAvPlxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzKGFsbFRhYmxlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBhbGxUYWJsZXNbbmFtZV07IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9cbiAgICAvLyBFdmVudHNcbiAgICAvL1xuICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJwb3B1bGF0ZVwiLCBcImJsb2NrZWRcIiwgXCJ2ZXJzaW9uY2hhbmdlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSk7XG4gICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIsIGJTdGlja3kpIHtcbiAgICAgICAgICAgIERleGllLnZpcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEYXRhYmFzZSBhbHJlYWR5IG9wZW4uIENhbGwgc3Vic2NyaWJlciBhc2FwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRiT3BlbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYlN0aWNreTogQWxzbyBzdWJzY3JpYmUgdG8gZnV0dXJlIG9wZW4gc3VjZXNzZXMgKGFmdGVyIGNsb3NlIC8gcmVvcGVuKSBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uUmVhZHlCZWluZ0ZpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRiLm9uKCdyZWFkeScpIHN1YnNjcmliZXJzIGFyZSBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgYW5kIGhhdmUgbm90IHlldCByZXNvbHZlZCBvciByZWplY3RlZFxuICAgICAgICAgICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERhdGFiYXNlIG5vdCB5ZXQgb3Blbi4gU3Vic2NyaWJlIHRvIGl0LlxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGJTdGlja3kgaXMgZmFsc3ksIG1ha2Ugc3VyZSB0byB1bnN1YnNjcmliZSBzdWJzY3JpYmVyIHdoZW4gZmlyZWQgb25jZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vLyA8c3VtbWFyeT5cbiAgICAgICAgLy8vXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1vZGVcIiB0eXBlPVwiU3RyaW5nXCI+XCJyXCIgZm9yIHJlYWRvbmx5LCBvciBcInJ3XCIgZm9yIHJlYWR3cml0ZTwvcGFyYW0+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRhYmxlSW5zdGFuY2VzXCI+VGFibGUgaW5zdGFuY2UsIEFycmF5IG9mIFRhYmxlIGluc3RhbmNlcywgU3RyaW5nIG9yIFN0cmluZyBBcnJheSBvZiBvYmplY3Qgc3RvcmVzIHRvIGluY2x1ZGUgaW4gdGhlIHRyYW5zYWN0aW9uPC9wYXJhbT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NvcGVGdW5jXCIgdHlwZT1cIkZ1bmN0aW9uXCI+RnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoIHRyYW5zYWN0aW9uPC9wYXJhbT5cbiAgICAgICAgdmFyIGFyZ3MgPSBleHRyYWN0VHJhbnNhY3Rpb25BcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuICAgICAgICAvLyBMZXQgdGFibGUgYXJndW1lbnRzIGJlIGFsbCBhcmd1bWVudHMgYmV0d2VlbiBtb2RlIGFuZCBsYXN0IGFyZ3VtZW50LlxuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChpIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIlRvbyBmZXcgYXJndW1lbnRzXCIpO1xuICAgICAgICAvLyBQcmV2ZW50IG9wdGltemF0aW9uIGtpbGxlciAoaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMyLWxlYWtpbmctYXJndW1lbnRzKVxuICAgICAgICAvLyBhbmQgY2xvbmUgYXJndW1lbnRzIGV4Y2VwdCB0aGUgZmlyc3Qgb25lIGludG8gbG9jYWwgdmFyICdhcmdzJy5cbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuICAgICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIC8vIExldCBzY29wZUZ1bmMgYmUgdGhlIGxhc3QgYXJndW1lbnQgYW5kIHBvcCBpdCBzbyB0aGF0IGFyZ3Mgbm93IG9ubHkgY29udGFpbiB0aGUgdGFibGUgYXJndW1lbnRzLlxuICAgICAgICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YXIgdGFibGVzID0gZmxhdHRlbihhcmdzKTsgLy8gU3VwcG9ydCB1c2luZyBhcnJheSBhcyBtaWRkbGUgYXJndW1lbnQsIG9yIGEgbWl4IG9mIGFycmF5cyBhbmQgbm9uLWFycmF5cy5cbiAgICAgICAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHRhYmxlcywgc2NvcGVGdW5jKSB7XG4gICAgICAgIHZhciBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucztcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGFyZW50IHRyYW5zYWN0aW9ucyBpcyBib3VuZCB0byB0aGlzIGRiIGluc3RhbmNlLCBhbmQgaWYgY2FsbGVyIHdhbnRzIHRvIHJldXNlIGl0XG4gICAgICAgIGlmICghcGFyZW50VHJhbnNhY3Rpb24gfHwgcGFyZW50VHJhbnNhY3Rpb24uZGIgIT09IGRiIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSlcbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgICAgIG1vZGUgPSBtb2RlLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnPycsICcnKTsgLy8gT2suIFdpbGwgY2hhbmdlIGFyZ3VtZW50c1swXSBhcyB3ZWxsIGJ1dCB3ZSB3b250IHRvdWNoIGFyZ3VtZW50cyBoZW5jZWZvcnRoLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEdldCBzdG9yZU5hbWVzIGZyb20gYXJndW1lbnRzLiBFaXRoZXIgdGhyb3VnaCBnaXZlbiB0YWJsZSBpbnN0YW5jZXMsIG9yIHRocm91Z2ggZ2l2ZW4gdGFibGUgbmFtZXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSB0YWJsZSBpbnN0YW5jZW9mIFRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVOYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFibGUgYXJndW1lbnQgdG8gRGV4aWUudHJhbnNhY3Rpb24oKS4gT25seSBUYWJsZSBvciBTdHJpbmcgYXJlIGFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFJlc29sdmUgbW9kZS4gQWxsb3cgc2hvcnRjdXRzIFwiclwiIGFuZCBcInJ3XCIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJyXCIgfHwgbW9kZSA9PSBSRUFET05MWSlcbiAgICAgICAgICAgICAgICBtb2RlID0gUkVBRE9OTFk7XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicndcIiB8fCBtb2RlID09IFJFQURXUklURSlcbiAgICAgICAgICAgICAgICBtb2RlID0gUkVBRFdSSVRFO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIEJhc2ljIGNoZWNrc1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbi5tb2RlID09PSBSRUFET05MWSAmJiBtb2RlID09PSBSRUFEV1JJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiQ2Fubm90IGVudGVyIGEgc3ViLXRyYW5zYWN0aW9uIHdpdGggUkVBRFdSSVRFIG1vZGUgd2hlbiBwYXJlbnQgdHJhbnNhY3Rpb24gaXMgUkVBRE9OTFlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uICYmIHBhcmVudFRyYW5zYWN0aW9uLnN0b3JlTmFtZXMuaW5kZXhPZihzdG9yZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJUYWJsZSBcIiArIHN0b3JlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBub3QgaW5jbHVkZWQgaW4gcGFyZW50IHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlICYmIHBhcmVudFRyYW5zYWN0aW9uICYmICFwYXJlbnRUcmFuc2FjdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJz8nIG1vZGUgc2hvdWxkIG5vdCBrZWVwIHVzaW5nIGFuIGluYWN0aXZlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmVqZWN0KGUpOyB9KSA6XG4gICAgICAgICAgICAgICAgcmVqZWN0aW9uKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWItdHJhbnNhY3Rpb24sIGxvY2sgdGhlIHBhcmVudCBhbmQgdGhlbiBsYXVuY2ggdGhlIHN1Yi10cmFuc2FjdGlvbi5cbiAgICAgICAgcmV0dXJuIChwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShtb2RlLCBlbnRlclRyYW5zYWN0aW9uU2NvcGUsIFwibG9ja1wiKSA6XG4gICAgICAgICAgICBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgIC8vIG5vIHBhcmVudCB0cmFuc2FjdGlvbiBkZXNwaXRlIFBTRC50cmFucyBleGlzdHMuIE1ha2Ugc3VyZSBhbHNvXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgem9uZSB3ZSBjcmVhdGUgaXMgbm90IGEgc3ViLXpvbmUgb2YgY3VycmVudCwgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIFByb21pc2UuZm9sbG93KCkgc2hvdWxkIG5vdCB3YWl0IGZvciBpdCBpZiBzby5cbiAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uU2NvcGUpOyB9KSA6XG4gICAgICAgICAgICAgICAgZGIuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uU2NvcGUpKTtcbiAgICAgICAgZnVuY3Rpb24gZW50ZXJUcmFuc2FjdGlvblNjb3BlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgYSBwb2ludGVyIHRvIGxhc3Qgbm9uLXRyYW5zYWN0aW9uYWwgUFNEIHRvIHVzZSBpZiBzb21lb25lIGNhbGxzIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkuXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgICAgICAgICAgICAgIC8vIE91ciB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAvL3JldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIExldCB0aGUgdHJhbnNhY3Rpb24gaW5zdGFuY2UgYmUgcGFydCBvZiBhIFByb21pc2Utc3BlY2lmaWMgZGF0YSAoUFNEKSB2YWx1ZS5cbiAgICAgICAgICAgICAgICB2YXIgem9uZVByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGVzczogdHJhbnNsZXNzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW11bGF0ZSB0cmFuc2FjdGlvbiBjb21taXQgYXdhcmVuZXNzIGZvciBpbm5lciB0cmFuc2FjdGlvbiAobXVzdCAnY29tbWl0JyB3aGVuIHRoZSBpbm5lciB0cmFuc2FjdGlvbiBoYXMgbm8gbW9yZSBvcGVyYXRpb25zIG9uZ29pbmcpXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTsgLy8gQ3JlYXRlIHRoZSBiYWNrZW5kIHRyYW5zYWN0aW9uIHNvIHRoYXQgY29tcGxldGUoKSBvciBlcnJvcigpIHdpbGwgdHJpZ2dlciBldmVuIGlmIG5vIG9wZXJhdGlvbiBpcyBtYWRlIHVwb24gaXQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIG5hdGl2ZSBhc3luYyBhd2FpdC5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jLmNvbnN0cnVjdG9yID09PSBBc3luY0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUZvbGxvd2VkID0gUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBjYWxsIHRoZSBzY29wZSBmdW5jdGlvbiB3aXRoIG91ciB0YWJsZSBhbmQgdHJhbnNhY3Rpb24gYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLmNvbnN0cnVjdG9yID09PSBOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY29wZUZ1bmMgcmV0dXJuZWQgYW4gaXRlcmF0b3Igd2l0aCB0aHJvdy1zdXBwb3J0LiBIYW5kbGUgeWllbGQgYXMgYXdhaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBhd2FpdEl0ZXJhdG9yKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHpvbmVQcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb21pc2UgcmV0dXJuZWQuIFVzZXIgdXNlcyBwcm9taXNlLXN0eWxlIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKS50aGVuKGZ1bmN0aW9uICh4KSB7IHJldHVybiB0cmFucy5hY3RpdmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeCAvLyBUcmFuc2FjdGlvbiBzdGlsbCBhY3RpdmUuIENvbnRpbnVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUHJlbWF0dXJlQ29tbWl0KFwiVHJhbnNhY3Rpb24gY29tbWl0dGVkIHRvbyBlYXJseS4gU2VlIGh0dHA6Ly9iaXQubHkvMmtkY2tNblwiKSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHByb21pc2UgcmV0dXJuZWQuIFdhaXQgZm9yIGFsbCBvdXRzdGFuZGluZyBwcm9taXNlcyBiZWZvcmUgY29udGludWluZy4gXG4gICAgICAgICAgICAgICAgICAgIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVmFsdWU7IH0pKS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YiB0cmFuc2FjdGlvbnMgZG9uJ3QgcmVhY3QgdG8gaWRidHJhbnMub25jb21wbGV0ZS4gV2UgbXVzdCB0cmlnZ2VyIGEgY29tcGxldGlvbjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgdHJhbnMuX2NvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gKGlmIHJvb3QgdHJhbnNhY3Rpb24sIHRoaXMgbWVhbnMgJ2NvbXBsZXRlJyBldmVudC4gSWYgc3ViLXRyYW5zYWN0aW9uLCB3ZSd2ZSBqdXN0IGZpcmVkIGl0IG91cnNlbHZlcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTsgLy8gWWVzLCBhYm92ZSB0aGVuLWhhbmRsZXIgd2VyZSBtYXliZSBub3QgY2FsbGVkIGJlY2F1c2Ugb2YgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpbiBzY29wZUZ1bmMhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50YWJsZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJUYWJsZVwiPjwvcmV0dXJucz5cbiAgICAgICAgaWYgKCFoYXNPd24oYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxUYWJsZXNbdGFibGVOYW1lXTtcbiAgICB9O1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFRhYmxlIENsYXNzXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gVGFibGUobmFtZSwgdGFibGVTY2hlbWEsIG9wdGlvbmFsVHJhbnMpIHtcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibmFtZVwiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuICAgICAgICB0aGlzLl90eCA9IG9wdGlvbmFsVHJhbnM7XG4gICAgICAgIHRoaXMuaG9vayA9IGFsbFRhYmxlc1tuYW1lXSA/IGFsbFRhYmxlc1tuYW1lXS5ob29rIDogRXZlbnRzKG51bGwsIHtcbiAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJyZWFkaW5nXCI6IFtwdXJlRnVuY3Rpb25DaGFpbiwgbWlycm9yXSxcbiAgICAgICAgICAgIFwidXBkYXRpbmdcIjogW2hvb2tVcGRhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJ1bGtFcnJvckhhbmRsZXJDYXRjaEFsbChlcnJvckxpc3QsIGRvbmUsIHN1cHBvcnRIb29rcykge1xuICAgICAgICByZXR1cm4gKHN1cHBvcnRIb29rcyA/IGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlciA6IGV2ZW50UmVqZWN0SGFuZGxlcikoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGVycm9yTGlzdC5wdXNoKGUpO1xuICAgICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWxrRGVsZXRlKGlkYnN0b3JlLCB0cmFucywga2V5c09yVHVwbGVzLCBoYXNEZWxldGVIb29rLCBkZWxldGluZ0hvb2spIHtcbiAgICAgICAgLy8gSWYgaGFzRGVsZXRlSG9vaywga2V5c09yVHVwbGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHVwbGVzOiBbW2tleTEsIHZhbHVlMl0sW2tleTIsdmFsdWUyXSwuLi5dLFxuICAgICAgICAvLyBlbHNlIGtleXNPclR1cGxlcyBtdXN0IGJlIGp1c3QgYW4gYXJyYXkgb2Yga2V5czogW2tleTEsIGtleTIsIC4uLl0uXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgbGVuID0ga2V5c09yVHVwbGVzLmxlbmd0aCwgbGFzdEl0ZW0gPSBsZW4gLSAxO1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKCFoYXNEZWxldGVIb29rKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRic3RvcmUuZGVsZXRlKGtleXNPclR1cGxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsYXN0SXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvb2tDdHgsIGVycm9ySGFuZGxlciA9IGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpLCBzdWNjZXNzSGFuZGxlciA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIobnVsbCk7XG4gICAgICAgICAgICAgICAgdHJ5Q2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rQ3R4ID0geyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IGtleXNPclR1cGxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW5nSG9vay5jYWxsKGhvb2tDdHgsIHR1cGxlWzBdLCB0dXBsZVsxXSwgdHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYnN0b3JlLmRlbGV0ZSh0dXBsZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuX2hvb2tDdHggPSBob29rQ3R4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFzdEl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBob29rQ3R4Lm9uZXJyb3IgJiYgaG9va0N0eC5vbmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzKFRhYmxlLnByb3RvdHlwZSwge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUYWJsZSBQcm90ZWN0ZWQgTWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICBfdHJhbnM6IGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zICYmIHRyYW5zLmRiID09PSBkYiA/XG4gICAgICAgICAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLl9wcm9taXNlKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkgOlxuICAgICAgICAgICAgICAgICAgICBuZXdTY29wZShmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmbiwgd3JpdGVMb2NrZWQpOyB9LCB7IHRyYW5zOiB0cmFucywgdHJhbnNsZXNzOiBQU0QudHJhbnNsZXNzIHx8IFBTRCB9KSA6XG4gICAgICAgICAgICAgICAgdGVtcFRyYW5zYWN0aW9uKG1vZGUsIFt0aGlzLm5hbWVdLCBmbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9pZGJzdG9yZTogZnVuY3Rpb24gZ2V0SURCT2JqZWN0U3RvcmUobW9kZSwgZm4sIHdyaXRlTG9ja2VkKSB7XG4gICAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgZnVuY3Rpb24gc3VwcGx5SWRiU3RvcmUocmVzb2x2ZSwgcmVqZWN0LCB0cmFucykge1xuICAgICAgICAgICAgICAgIGlmICh0cmFucy5zdG9yZU5hbWVzLmluZGV4T2YodGFibGVOYW1lKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGVcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zLmlkYnRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSksIHRyYW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucyhtb2RlLCBzdXBwbHlJZGJTdG9yZSwgd3JpdGVMb2NrZWQpO1xuICAgICAgICB9LFxuICAgICAgICAvL1xuICAgICAgICAvLyBUYWJsZSBQdWJsaWMgTWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXlPckNyaXQsIGNiKSB7XG4gICAgICAgICAgICBpZiAoa2V5T3JDcml0ICYmIGtleU9yQ3JpdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKGtleU9yQ3JpdCkuZmlyc3QoY2IpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkYnN0b3JlKFJFQURPTkxZLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSBpZGJzdG9yZS5nZXQoa2V5T3JDcml0KTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLmhvb2sucmVhZGluZy5maXJlKHJlcS5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgIH0sXG4gICAgICAgIHdoZXJlOiBmdW5jdGlvbiAoaW5kZXhPckNyaXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVDbGF1c2UodGhpcywgaW5kZXhPckNyaXQpO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVDbGF1c2UodGhpcywgXCJbXCIgKyBpbmRleE9yQ3JpdC5qb2luKCcrJykgKyBcIl1cIik7XG4gICAgICAgICAgICAvLyBpbmRleE9yQ3JpdCBpcyBhbiBvYmplY3QgbWFwIG9mIHtba2V5UGF0aF06dmFsdWV9IFxuICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhpbmRleE9yQ3JpdCk7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIC8vIE9ubHkgb25lIGNyaXRlcmEuIFRoaXMgd2FzIHRoZSBlYXN5IGNhc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzWzBdKVxuICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGluZGV4T3JDcml0W2tleVBhdGhzWzBdXSk7XG4gICAgICAgICAgICAvLyBNdWx0aXBsZSBjcml0ZXJpYXMuXG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgZmluZGluZyBhIGNvbXBvdW5kIGluZGV4IHRoYXQgbWF0Y2hlcyBhbGwga2V5UGF0aHMgaW5cbiAgICAgICAgICAgIC8vIGFyYnJpdGFyeSBvcmRlcjpcbiAgICAgICAgICAgIHZhciBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGZ1bmN0aW9uIChpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpeC5jb21wb3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRocy5ldmVyeShmdW5jdGlvbiAoa2V5UGF0aCkgeyByZXR1cm4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDA7IH0pICYmXG4gICAgICAgICAgICAgICAgICAgIGl4LmtleVBhdGguZXZlcnkoZnVuY3Rpb24gKGtleVBhdGgpIHsgcmV0dXJuIGtleVBhdGhzLmluZGV4T2Yoa2V5UGF0aCkgPj0gMDsgfSk7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIGlmIChjb21wb3VuZEluZGV4ICYmIG1heEtleSAhPT0gbWF4U3RyaW5nKVxuICAgICAgICAgICAgICAgIC8vIENvb2whIFdlIGZvdW5kIHN1Y2ggY29tcG91bmQgaW5kZXhcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhpcyBicm93c2VyIHN1cHBvcnRzIGNvbXBvdW5kIGluZGV4ZXMgKG1heEtleSAhPT0gbWF4U3RyaW5nKSFcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUoY29tcG91bmRJbmRleC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGNvbXBvdW5kSW5kZXgua2V5UGF0aC5tYXAoZnVuY3Rpb24gKGtwKSB7IHJldHVybiBpbmRleE9yQ3JpdFtrcF07IH0pKTtcbiAgICAgICAgICAgIGlmICghY29tcG91bmRJbmRleClcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgcXVlcnkgXCIgKyBKU09OLnN0cmluZ2lmeShpbmRleE9yQ3JpdCkgKyBcIiBvbiBcIiArIHRoaXMubmFtZSArIFwiIHdvdWxkIGJlbmVmaXQgb2YgYSBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcImNvbXBvdW5kIGluZGV4IFtcIiArIGtleVBhdGhzLmpvaW4oJysnKSArIFwiXVwiKSk7XG4gICAgICAgICAgICAvLyBPaywgbm93IGxldCdzIGZhbGxiYWNrIHRvIGZpbmRpbmcgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIGluZGV4XG4gICAgICAgICAgICAvLyBhbmQgZmlsdGVyIHRoZSByZXN0LlxuICAgICAgICAgICAgdmFyIGlkeEJ5TmFtZSA9IHRoaXMuc2NoZW1hLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgIHZhciBzaW1wbGVJbmRleCA9IGtleVBhdGhzLnJlZHVjZShmdW5jdGlvbiAociwga2V5UGF0aCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJbMF0gfHwgaWR4QnlOYW1lW2tleVBhdGhdLFxuICAgICAgICAgICAgICAgIHJbMF0gfHwgIWlkeEJ5TmFtZVtrZXlQYXRoXSA/XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmUoclsxXSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuICcnICsgZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpID09XG4gICAgICAgICAgICAgICAgICAgICAgICAnJyArIGluZGV4T3JDcml0W2tleVBhdGhdOyB9KVxuICAgICAgICAgICAgICAgICAgICA6IHJbMV1cbiAgICAgICAgICAgIF07IH0sIFtudWxsLCBudWxsXSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc2ltcGxlSW5kZXhbMF07XG4gICAgICAgICAgICByZXR1cm4gaWR4ID9cbiAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGlkeC5uYW1lKS5lcXVhbHMoaW5kZXhPckNyaXRbaWR4LmtleVBhdGhdKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNpbXBsZUluZGV4WzFdKSA6XG4gICAgICAgICAgICAgICAgY29tcG91bmRJbmRleCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKHNpbXBsZUluZGV4WzFdKSA6IC8vIEhhcyBjb21wb3VuZCBidXQgYnJvd3NlciBiYWQuIEFsbG93IGZpbHRlci5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTsgLy8gTm8gaW5kZXggYXQgYWxsLiBGYWlsIGxhemlseS5cbiAgICAgICAgfSxcbiAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuY291bnQoY2IpO1xuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICBsaW1pdDogZnVuY3Rpb24gKG51bVJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmxpbWl0KG51bVJvd3MpO1xuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5yZXZlcnNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICB9LFxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goZm4pO1xuICAgICAgICB9LFxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkoY2IpO1xuICAgICAgICB9LFxuICAgICAgICBvcmRlckJ5OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbihuZXcgV2hlcmVDbGF1c2UodGhpcywgaXNBcnJheShpbmRleCkgP1xuICAgICAgICAgICAgICAgIFwiW1wiICsgaW5kZXguam9pbignKycpICsgXCJdXCIgOlxuICAgICAgICAgICAgICAgIGluZGV4KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvQ29sbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKG5ldyBXaGVyZUNsYXVzZSh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1hcFRvQ2xhc3M6IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3RydWN0dXJlKSB7XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgICAgICAvLy8gICAgIE1hcCB0YWJsZSB0byBhIGphdmFzY3JpcHQgY29uc3RydWN0b3IgZnVuY3Rpb24uIE9iamVjdHMgcmV0dXJuZWQgZnJvbSB0aGUgZGF0YWJhc2Ugd2lsbCBiZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcywgbWFraW5nXG4gICAgICAgICAgICAvLy8gICAgIGl0IHBvc3NpYmxlIHRvIHRoZSBpbnN0YW5jZU9mIG9wZXJhdG9yIGFzIHdlbGwgYXMgZXh0ZW5kaW5nIHRoZSBjbGFzcyB1c2luZyBjb25zdHJ1Y3Rvci5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24oKXsuLi59LlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnN0cnVjdG9yXCI+Q29uc3RydWN0b3IgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBjbGFzcy48L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RydWN0dXJlXCIgb3B0aW9uYWw9XCJ0cnVlXCI+SGVscHMgSURFIGNvZGUgY29tcGxldGlvbiBieSBrbm93aW5nIHRoZSBtZW1iZXJzIHRoYXQgb2JqZWN0cyBjb250YWluIGFuZCBub3QganVzdCB0aGUgaW5kZXhlcy4gQWxzb1xuICAgICAgICAgICAgLy8vIGtub3cgd2hhdCB0eXBlIGVhY2ggbWVtYmVyIGhhcy4gRXhhbXBsZToge25hbWU6IFN0cmluZywgZW1haWxBZGRyZXNzZXM6IFtTdHJpbmddLCBwYXNzd29yZH08L3BhcmFtPlxuICAgICAgICAgICAgdGhpcy5zY2hlbWEubWFwcGVkQ2xhc3MgPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZVRlbXBsYXRlID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgaWYgKHN0cnVjdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyZSBhbmQgaW5zdGFuY2VUZW1wbGF0ZSBpcyBmb3IgSURFIGNvZGUgY29tcGV0aW9uIG9ubHkgd2hpbGUgY29uc3RydWN0b3IucHJvdG90eXBlIGlzIGZvciBhY3R1YWwgaW5oZXJpdGFuY2UuXG4gICAgICAgICAgICAgICAgYXBwbHlTdHJ1Y3R1cmUoaW5zdGFuY2VUZW1wbGF0ZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NoZW1hLmluc3RhbmNlVGVtcGxhdGUgPSBpbnN0YW5jZVRlbXBsYXRlO1xuICAgICAgICAgICAgLy8gTm93LCBzdWJzY3JpYmUgdG8gdGhlIHdoZW4oXCJyZWFkaW5nXCIpIGV2ZW50IHRvIG1ha2UgYWxsIG9iamVjdHMgdGhhdCBjb21lIG91dCBmcm9tIHRoaXMgdGFibGUgaW5oZXJpdCBmcm9tIGdpdmVuIGNsYXNzXG4gICAgICAgICAgICAvLyBubyBtYXR0ZXIgd2hpY2ggbWV0aG9kIHRvIHVzZSBmb3IgcmVhZGluZyAoVGFibGUuZ2V0KCkgb3IgVGFibGUud2hlcmUoLi4uKS4uLiApXG4gICAgICAgICAgICB2YXIgcmVhZEhvb2sgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7IC8vIE5vIHZhbGlkIG9iamVjdC4gKFZhbHVlIGlzIG51bGwpLiBSZXR1cm4gYXMgaXMuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0aGF0IGRlcml2ZXMgZnJvbSBjb25zdHJ1Y3RvcjpcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIC8vIENsb25lIG1lbWJlcnM6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW21dID0gb2JqW21dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NoZW1hLnJlYWRIb29rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEucmVhZEhvb2sgPSByZWFkSG9vaztcbiAgICAgICAgICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVDbGFzczogZnVuY3Rpb24gKHN0cnVjdHVyZSkge1xuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxuICAgICAgICAgICAgLy8vICAgICBEZWZpbmUgYWxsIG1lbWJlcnMgb2YgdGhlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyB0aGUgdGFibGUuIFRoaXMgd2lsbCBoZWxwIGNvZGUgY29tcGxldGlvbiBvZiB3aGVuIG9iamVjdHMgYXJlIHJlYWQgZnJvbSB0aGUgZGF0YWJhc2VcbiAgICAgICAgICAgIC8vLyAgICAgYXMgd2VsbCBhcyBtYWtpbmcgaXQgcG9zc2libGUgdG8gZXh0ZW5kIHRoZSBwcm90b3R5cGUgb2YgdGhlIHJldHVybmVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0cnVjdHVyZVwiPkhlbHBzIElERSBjb2RlIGNvbXBsZXRpb24gYnkga25vd2luZyB0aGUgbWVtYmVycyB0aGF0IG9iamVjdHMgY29udGFpbiBhbmQgbm90IGp1c3QgdGhlIGluZGV4ZXMuIEFsc29cbiAgICAgICAgICAgIC8vLyBrbm93IHdoYXQgdHlwZSBlYWNoIG1lbWJlciBoYXMuIEV4YW1wbGU6IHtuYW1lOiBTdHJpbmcsIGVtYWlsQWRkcmVzc2VzOiBbU3RyaW5nXSwgcHJvcGVydGllczoge3Nob2VTaXplOiBOdW1iZXJ9fTwvcGFyYW0+XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKERleGllLmRlZmluZUNsYXNzKHN0cnVjdHVyZSksIHN0cnVjdHVyZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1bGtEZWxldGU6IGZ1bmN0aW9uIChrZXlzJCQxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ob29rLmRlbGV0aW5nLmZpcmUgPT09IG5vcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZGJzdG9yZShSRUFEV1JJVEUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlLCB0cmFucykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJ1bGtEZWxldGUoaWRic3RvcmUsIHRyYW5zLCBrZXlzJCQxLCBmYWxzZSwgbm9wKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUoJzppZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hbnlPZihrZXlzJCQxKVxuICAgICAgICAgICAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyB9KTsgLy8gUmVzb2x2ZSB3aXRoIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnVsa1B1dDogZnVuY3Rpb24gKG9iamVjdHMsIGtleXMkJDEpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWRic3RvcmUoUkVBRFdSSVRFLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgIGlmICghaWRic3RvcmUua2V5UGF0aCAmJiAhX3RoaXMuc2NoZW1hLnByaW1LZXkuYXV0byAmJiAha2V5cyQkMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa1B1dCgpIHdpdGggbm9uLWluYm91bmQga2V5cyByZXF1aXJlcyBrZXlzIGFycmF5IGluIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaWRic3RvcmUua2V5UGF0aCAmJiBrZXlzJCQxKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrUHV0KCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMkJDEgJiYga2V5cyQkMS5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTsgLy8gQ2FsbGVyIHByb3ZpZGVkIGVtcHR5IGxpc3QuXG4gICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckxpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEJ1bGtFcnJvcihfdGhpcy5uYW1lICsgXCIuYnVsa1B1dCgpOiBcIiArIGVycm9yTGlzdC5sZW5ndGggKyBcIiBvZiBcIiArIG51bU9ianMgKyBcIiBvcGVyYXRpb25zIGZhaWxlZFwiLCBlcnJvckxpc3QpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciByZXEsIGVycm9yTGlzdCA9IFtdLCBlcnJvckhhbmRsZXIsIG51bU9ianMgPSBvYmplY3RzLmxlbmd0aCwgdGFibGUgPSBfdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaG9vay5jcmVhdGluZy5maXJlID09PSBub3AgJiYgX3RoaXMuaG9vay51cGRhdGluZy5maXJlID09PSBub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhbmRhcmQgQnVsayAobm8gJ2NyZWF0aW5nJyBvciAndXBkYXRpbmcnIGhvb2tzIHRvIGNhcmUgYWJvdXQpXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlciA9IEJ1bGtFcnJvckhhbmRsZXJDYXRjaEFsbChlcnJvckxpc3QpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBrZXlzJCQxID8gaWRic3RvcmUucHV0KG9iamVjdHNbaV0sIGtleXMkJDFbaV0pIDogaWRic3RvcmUucHV0KG9iamVjdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBuZWVkIHRvIGNhdGNoIHN1Y2Nlc3Mgb3IgZXJyb3Igb24gdGhlIGxhc3Qgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byB0aGUgSURCIHNwZWMuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gQnVsa0Vycm9ySGFuZGxlckNhdGNoQWxsKGVycm9yTGlzdCwgZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudFN1Y2Nlc3NIYW5kbGVyKGRvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVmZmVjdGl2ZUtleXMgPSBrZXlzJCQxIHx8IGlkYnN0b3JlLmtleVBhdGggJiYgb2JqZWN0cy5tYXAoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvLCBpZGJzdG9yZS5rZXlQYXRoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIG1hcCBvZiB7W2tleV06IG9iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdExvb2t1cCA9IGVmZmVjdGl2ZUtleXMgJiYgYXJyYXlUb09iamVjdChlZmZlY3RpdmVLZXlzLCBmdW5jdGlvbiAoa2V5LCBpKSB7IHJldHVybiBrZXkgIT0gbnVsbCAmJiBba2V5LCBvYmplY3RzW2ldXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gIWVmZmVjdGl2ZUtleXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXV0by1pbmNyZW1lbnRlZCBrZXktbGVzcyBvYmplY3RzIG9ubHkgd2l0aG91dCBhbnkga2V5cyBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmJ1bGtBZGQob2JqZWN0cykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2V5cyBwcm92aWRlZC4gRWl0aGVyIGFzIGluYm91bmQgaW4gcHJvdmlkZWQgb2JqZWN0cywgb3IgYXMgYSBrZXlzIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVnaW4gd2l0aCB1cGRhdGluZyB0aG9zZSB0aGF0IGV4aXN0cyBpbiBEQjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLndoZXJlKCc6aWQnKS5hbnlPZihlZmZlY3RpdmVLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgIT0gbnVsbDsgfSkpLm1vZGlmeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9iamVjdExvb2t1cFt0aGlzLnByaW1LZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdExvb2t1cFt0aGlzLnByaW1LZXldID0gbnVsbDsgLy8gTWFyayBhcyBcImRvbid0IGFkZCB0aGlzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKE1vZGlmeUVycm9yLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTGlzdCA9IGUuZmFpbHVyZXM7IC8vIE5vIG5lZWQgdG8gY29uY2F0IGhlcmUuIFRoZXNlIGFyZSB0aGUgZmlyc3QgZXJyb3JzIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm93LCBsZXQncyBleGFtaW5lIHdoaWNoIGl0ZW1zIGRpZG50IGV4aXN0IHNvIHdlIGNhbiBhZGQgdGhlbTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Jqc1RvQWRkID0gW10sIGtleXNUb0FkZCA9IGtleXMkJDEgJiYgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHMuIFdoeT8gQmVjYXVzZSBpZiBzYW1lIGtleSB3YXMgdXNlZCB0d2ljZSwganVzdCBhZGQgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBlZmZlY3RpdmVLZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBlZmZlY3RpdmVLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgb2JqZWN0TG9va3VwW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ianNUb0FkZC5wdXNoKG9iamVjdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cyQkMSAmJiBrZXlzVG9BZGQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdExvb2t1cFtrZXldID0gbnVsbDsgLy8gTWFyayBhcyBcImRvbnQgYWRkIGFnYWluXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaXRlbXMgYXJlIGluIHJldmVyc2Ugb3JkZXIgc28gcmV2ZXJzZSB0aGVtIGJlZm9yZSBhZGRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgYmUgaW1wb3J0YW50IGluIG9yZGVyIHRvIGdldCBhdXRvLWluY3JlbWVudGVkIGtleXMgdGhlIHdheSB0aGUgY2FsbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd291bGQgZXhwZWN0LiBDb3VsZCBoYXZlIHVzZWQgdW5zaGlmdCBpbnN0ZWFkIG9mIHB1c2goKS9yZXZlcnNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0OiBodHRwOi8vanNwZXJmLmNvbS91bnNoaWZ0LXZzLXJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpzVG9BZGQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMkJDEgJiYga2V5c1RvQWRkLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuYnVsa0FkZChvYmpzVG9BZGQsIGtleXNUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChsYXN0QWRkZWRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHdpdGgga2V5IG9mIHRoZSBsYXN0IG9iamVjdCBpbiBnaXZlbiBhcmd1bWVudHMgdG8gYnVsa1B1dCgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0RWZmZWN0aXZlS2V5ID0gZWZmZWN0aXZlS2V5c1tlZmZlY3RpdmVLZXlzLmxlbmd0aCAtIDFdOyAvLyBLZXkgd2FzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0RWZmZWN0aXZlS2V5ICE9IG51bGwgPyBsYXN0RWZmZWN0aXZlS2V5IDogbGFzdEFkZGVkS2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihkb25lKS5jYXRjaChCdWxrRXJyb3IsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25jYXQgZmFpbHVyZSBmcm9tIE1vZGlmeUVycm9yIGFuZCByZWplY3QgdXNpbmcgb3VyICdkb25lJyBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckxpc3QgPSBlcnJvckxpc3QuY29uY2F0KGUuZmFpbHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFwibG9ja2VkXCIpOyAvLyBJZiBjYWxsZWQgZnJvbSB0cmFuc2FjdGlvbiBzY29wZSwgbG9jayB0cmFuc2FjdGlvbiB0aWwgYWxsIHN0ZXBzIGFyZSBkb25lLlxuICAgICAgICB9LFxuICAgICAgICBidWxrQWRkOiBmdW5jdGlvbiAob2JqZWN0cywga2V5cyQkMSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBjcmVhdGluZ0hvb2sgPSB0aGlzLmhvb2suY3JlYXRpbmcuZmlyZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZGJzdG9yZShSRUFEV1JJVEUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlLCB0cmFucykge1xuICAgICAgICAgICAgICAgIGlmICghaWRic3RvcmUua2V5UGF0aCAmJiAhc2VsZi5zY2hlbWEucHJpbUtleS5hdXRvICYmICFrZXlzJCQxKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrQWRkKCkgd2l0aCBub24taW5ib3VuZCBrZXlzIHJlcXVpcmVzIGtleXMgYXJyYXkgaW4gc2Vjb25kIGFyZ3VtZW50XCIpO1xuICAgICAgICAgICAgICAgIGlmIChpZGJzdG9yZS5rZXlQYXRoICYmIGtleXMkJDEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyQkMSAmJiBrZXlzJCQxLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpOyAvLyBDYWxsZXIgcHJvdmlkZWQgZW1wdHkgbGlzdC5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb25lKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JMaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBCdWxrRXJyb3Ioc2VsZi5uYW1lICsgXCIuYnVsa0FkZCgpOiBcIiArIGVycm9yTGlzdC5sZW5ndGggKyBcIiBvZiBcIiArIG51bU9ianMgKyBcIiBvcGVyYXRpb25zIGZhaWxlZFwiLCBlcnJvckxpc3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcSwgZXJyb3JMaXN0ID0gW10sIGVycm9ySGFuZGxlciwgc3VjY2Vzc0hhbmRsZXIsIG51bU9ianMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmdIb29rICE9PSBub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHN1YnNjcmliZXJzIHRvIGhvb2soJ2NyZWF0aW5nJylcbiAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBiZWhhdmUgYXMgZG9jdW1lbnRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBpZGJzdG9yZS5rZXlQYXRoLCBob29rQ3R4O1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIgPSBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0hhbmRsZXIgPSBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB0cnlDYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9va0N0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXMkJDEgJiYga2V5cyQkMVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXSwgZWZmZWN0aXZlS2V5ID0ga2V5cyQkMSA/IGtleSA6IGtleVBhdGggPyBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKSA6IHVuZGVmaW5lZCwga2V5VG9Vc2UgPSBjcmVhdGluZ0hvb2suY2FsbChob29rQ3R4LCBlZmZlY3RpdmVLZXksIG9iaiwgdHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3RpdmVLZXkgPT0gbnVsbCAmJiBrZXlUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBkZWVwQ2xvbmUob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGtleVRvVXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleVRvVXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IGtleSAhPSBudWxsID8gaWRic3RvcmUuYWRkKG9iaiwga2V5KSA6IGlkYnN0b3JlLmFkZChvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5faG9va0N0eCA9IGhvb2tDdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBsIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvb2tDdHgub25zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va0N0eC5vbmVycm9yICYmIGhvb2tDdHgub25lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBkb25lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIoZG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZCBCdWxrIChubyAnY3JlYXRpbmcnIGhvb2sgdG8gY2FyZSBhYm91dClcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyID0gQnVsa0Vycm9ySGFuZGxlckNhdGNoQWxsKGVycm9yTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IGtleXMkJDEgPyBpZGJzdG9yZS5hZGQob2JqZWN0c1tpXSwga2V5cyQkMVtpXSkgOiBpZGJzdG9yZS5hZGQob2JqZWN0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG5lZWQgdG8gY2F0Y2ggc3VjY2VzcyBvciBlcnJvciBvbiB0aGUgbGFzdCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBJREIgc3BlYy5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBkb25lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50U3VjY2Vzc0hhbmRsZXIoZG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgICAgICAvLy8gICBBZGQgYW4gb2JqZWN0IHRvIHRoZSBkYXRhYmFzZS4gSW4gY2FzZSBhbiBvYmplY3Qgd2l0aCBzYW1lIHByaW1hcnkga2V5IGFscmVhZHkgZXhpc3RzLCB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9ialwiIHR5cGU9XCJPYmplY3RcIj5BIGphdmFzY3JpcHQgb2JqZWN0IHRvIGluc2VydDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlcIiBvcHRpb25hbD1cInRydWVcIj5QcmltYXJ5IGtleTwvcGFyYW0+XG4gICAgICAgICAgICB2YXIgY3JlYXRpbmdIb29rID0gdGhpcy5ob29rLmNyZWF0aW5nLmZpcmU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWRic3RvcmUoUkVBRFdSSVRFLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSwgdHJhbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9va0N0eCA9IHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nSG9vayAhPT0gbm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZmZlY3RpdmVLZXkgPSAoa2V5ICE9IG51bGwpID8ga2V5IDogKGlkYnN0b3JlLmtleVBhdGggPyBnZXRCeUtleVBhdGgob2JqLCBpZGJzdG9yZS5rZXlQYXRoKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlUb1VzZSA9IGNyZWF0aW5nSG9vay5jYWxsKGhvb2tDdHgsIGVmZmVjdGl2ZUtleSwgb2JqLCB0cmFucyk7IC8vIEFsbG93IHN1YnNjcmliZXJzIHRvIHdoZW4oXCJjcmVhdGluZ1wiKSB0byBnZW5lcmF0ZSB0aGUga2V5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0aXZlS2V5ID09IG51bGwgJiYga2V5VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkYnN0b3JlLmtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwgaWRic3RvcmUua2V5UGF0aCwga2V5VG9Vc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleVRvVXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBrZXkgIT0gbnVsbCA/IGlkYnN0b3JlLmFkZChvYmosIGtleSkgOiBpZGJzdG9yZS5hZGQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLl9ob29rQ3R4ID0gaG9va0N0eDtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBob29rZWRFdmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoZXNlIHR3byBsaW5lcyBpbiBuZXh0IG1ham9yIHJlbGVhc2UgKDIuMD8pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIG5vIGdvb2QgcHJhY3RpY2UgdG8gaGF2ZSBzaWRlIGVmZmVjdHMgb24gcHJvdmlkZWQgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBpZGJzdG9yZS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rQ3R4Lm9uZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBob29rQ3R4Lm9uZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1dDogZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxuICAgICAgICAgICAgLy8vICAgQWRkIGFuIG9iamVjdCB0byB0aGUgZGF0YWJhc2UgYnV0IGluIGNhc2UgYW4gb2JqZWN0IHdpdGggc2FtZSBwcmltYXJ5IGtleSBhbHJlYWQgZXhpc3RzLCB0aGUgZXhpc3Rpbmcgb25lIHdpbGwgZ2V0IHVwZGF0ZWQuXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib2JqXCIgdHlwZT1cIk9iamVjdFwiPkEgamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zZXJ0IG9yIHVwZGF0ZTwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlcIiBvcHRpb25hbD1cInRydWVcIj5QcmltYXJ5IGtleTwvcGFyYW0+XG4gICAgICAgICAgICB2YXIgY3JlYXRpbmdIb29rID0gdGhpcy5ob29rLmNyZWF0aW5nLmZpcmUsIHVwZGF0aW5nSG9vayA9IHRoaXMuaG9vay51cGRhdGluZy5maXJlO1xuICAgICAgICAgICAgaWYgKGNyZWF0aW5nSG9vayAhPT0gbm9wIHx8IHVwZGF0aW5nSG9vayAhPT0gbm9wKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBQZW9wbGUgbGlzdGVucyB0byB3aGVuKFwiY3JlYXRpbmdcIikgb3Igd2hlbihcInVwZGF0aW5nXCIpIGV2ZW50cyFcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGtub3cgd2hldGhlciB0aGUgcHV0IG9wZXJhdGlvbiByZXN1bHRzIGluIGFuIENSRUFURSBvciBVUERBVEUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgZWZmZWN0aXZlS2V5ID0gKGtleSAhPT0gdW5kZWZpbmVkKSA/IGtleSA6IChrZXlQYXRoICYmIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0aXZlS2V5ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvYmopO1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGtleSBpcyBvcHRpb25hbCwgbWFrZSBzdXJlIHdlIGdldCBpdCBmcm9tIG9iaiBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBQcmltYXJ5IGtleSBleGlzdC4gTG9jayB0cmFuc2FjdGlvbiBhbmQgdHJ5IG1vZGlmeWluZyBleGlzdGluZy4gSWYgbm90aGluZyBtb2RpZmllZCwgY2FsbCBhZGQoKS5cbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBvYmogYmVmb3JlIHRoaXMgYXN5bmMgY2FsbC4gSWYgY2FsbGVyIG1vZGlmaWVzIG9iaiB0aGUgbGluZSBhZnRlciBwdXQoKSwgdGhlIElEQiBzcGVjIHJlcXVpcmVzIHRoYXQgaXQgc2hvdWxkIG5vdCBhZmZlY3Qgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucyhSRUFEV1JJVEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhlZmZlY3RpdmVLZXkpLm1vZGlmeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGlzdGluZyB2YWx1ZSB3aXRoIG91ciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENSVUQgZXZlbnQgZmlyaW5nIGhhbmRsZWQgaW4gQ29sbGVjdGlvbi5tb2RpZnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIGNvdW50ID09PSAwID8gX3RoaXMuYWRkKG9iaiwga2V5KSA6IGVmZmVjdGl2ZUtleTsgfSk7XG4gICAgICAgICAgICAgICAgfSwgXCJsb2NrZWRcIik7IC8vIExvY2sgbmVlZGVkIGJlY2F1c2Ugb3BlcmF0aW9uIGlzIHNwbGl0dGVkIGludG8gbW9kaWZ5KCkgYW5kIGFkZCgpLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzdGFuZGFyZCBJREIgcHV0KCkgbWV0aG9kLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZGJzdG9yZShSRUFEV1JJVEUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBrZXkgIT09IHVuZGVmaW5lZCA/IGlkYnN0b3JlLnB1dChvYmosIGtleSkgOiBpZGJzdG9yZS5wdXQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGlkYnN0b3JlLmtleVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBldi50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwia2V5XCI+UHJpbWFyeSBrZXkgb2YgdGhlIG9iamVjdCB0byBkZWxldGU8L3BhcmFtPlxuICAgICAgICAgICAgaWYgKHRoaXMuaG9vay5kZWxldGluZy5zdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBQZW9wbGUgbGlzdGVucyB0byB3aGVuKFwiZGVsZXRpbmdcIikgZXZlbnQuIE11c3QgaW1wbGVtZW50IGRlbGV0ZSB1c2luZyBDb2xsZWN0aW9uLmRlbGV0ZSgpIHRoYXQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGNhbGwgdGhlIENSVUQgZXZlbnQuIE9ubHkgQ29sbGVjdGlvbi5kZWxldGUoKSB3aWxsIGtub3cgd2hldGhlciBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkuZGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBvbmUgbGlzdGVucy4gVXNlIHN0YW5kYXJkIElEQiBkZWxldGUoKSBtZXRob2QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkYnN0b3JlKFJFQURXUklURSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYnN0b3JlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvb2suZGVsZXRpbmcuc3Vic2NyaWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gUGVvcGxlIGxpc3RlbnMgdG8gd2hlbihcImRlbGV0aW5nXCIpIGV2ZW50LiBNdXN0IGltcGxlbWVudCBkZWxldGUgdXNpbmcgQ29sbGVjdGlvbi5kZWxldGUoKSB0aGF0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBDUlVEIGV2ZW50LiBPbmx5IENvbGxlY3Rpb24uZGVsZXRlKCkgd2lsbCBrbm93cyB3aGljaCBvYmplY3RzIHRoYXQgYXJlIGFjdHVhbGx5IGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuZGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faWRic3RvcmUoUkVBRFdSSVRFLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRic3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGtleU9yT2JqZWN0LCBtb2RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWNhdGlvbnMgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkobW9kaWZpY2F0aW9ucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiTW9kaWZpY2F0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0ID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShrZXlPck9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvYmplY3QgdG8gbW9kaWZ5LiBBbHNvIG1vZGlmeSBnaXZlbiBvYmplY3Qgd2l0aCB0aGUgbW9kaWZpY2F0aW9uczpcbiAgICAgICAgICAgICAgICBrZXlzKG1vZGlmaWNhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCBrZXlQYXRoLCBtb2RpZmljYXRpb25zW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJHaXZlbiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBpdHMgcHJpbWFyeSBrZXlcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXkpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGtleSB0byBtb2RpZnlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5T3JPYmplY3QpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFRyYW5zYWN0aW9uIENsYXNzXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgIC8vLyAgICBUcmFuc2FjdGlvbiBjbGFzcy4gUmVwcmVzZW50cyBhIGRhdGFiYXNlIHRyYW5zYWN0aW9uLiBBbGwgb3BlcmF0aW9ucyBvbiBkYiBnb2VzIHRocm91Z2ggYSBUcmFuc2FjdGlvbi5cbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibW9kZVwiIHR5cGU9XCJTdHJpbmdcIj5Bbnkgb2YgXCJyZWFkd3JpdGVcIiBvciBcInJlYWRvbmx5XCI8L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdG9yZU5hbWVzXCIgdHlwZT1cIkFycmF5XCI+QXJyYXkgb2YgdGFibGUgbmFtZXMgdG8gb3BlcmF0ZSBvbjwvcGFyYW0+XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgICAgdGhpcy5pZGJ0cmFucyA9IG51bGw7XG4gICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJjb21wbGV0ZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIik7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjdWxvY2sgPSAwO1xuICAgICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWl0aW5nUXVldWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zcGluQ291bnQgPSAwOyAvLyBKdXN0IGZvciBkZWJ1Z2dpbmcgd2FpdEZvcigpXG4gICAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHdhc0FjdGl2ZSA9IF90aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMub24uZXJyb3IuZmlyZShlKTtcbiAgICAgICAgICAgIF90aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgX3RoaXMucGFyZW50Ll9yZWplY3QoZSkgOlxuICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiBfdGhpcy5pZGJ0cmFucyAmJiBfdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTsgLy8gSW5kaWNhdGUgd2UgYWN0dWFsbHkgRE8gTk9UIGNhdGNoIHRoaXMgZXJyb3IuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wcyhUcmFuc2FjdGlvbi5wcm90b3R5cGUsIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVHJhbnNhY3Rpb24gUHJvdGVjdGVkIE1ldGhvZHMgKG5vdCByZXF1aXJlZCBieSBBUEkgdXNlcnMsIGJ1dCBuZWVkZWQgaW50ZXJuYWxseSBhbmQgZXZlbnR1YWxseSBieSBkZXhpZSBleHRlbnNpb25zKVxuICAgICAgICAvL1xuICAgICAgICBfbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTsgLy8gTG9ja2luZyBhbmQgdW5sb2NraW5nIHJldWlyZXMgdG8gYmUgd2l0aGluIGEgUFNEIHNjb3BlLlxuICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHNldCBhbGwgcmVxdWVzdHMgaW50byBhIHBlbmRpbmcgcXVldWUgaWYgdGhleSBhcmUgY2FsbGVkIGJlZm9yZSBkYXRhYmFzZSBpcyByZWFkeS5cbiAgICAgICAgICAgICsrdGhpcy5fcmVjdWxvY2s7IC8vIFJlY3Vyc2l2ZSByZWFkL3dyaXRlIGxvY2sgcGF0dGVybiB1c2luZyBQU0QgKFByb21pc2UgU3BlY2lmaWMgRGF0YSkgaW5zdGVhZCBvZiBUTFMgKFRocmVhZCBMb2NhbCBTdG9yYWdlKVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlY3Vsb2NrID09PSAxICYmICFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF91bmxvY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICAgICAgICAgIGlmICgtLXRoaXMuX3JlY3Vsb2NrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fYmxvY2tlZEZ1bmNzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlUFNEKGZuQW5kUFNEWzFdLCBmbkFuZFBTRFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfbG9ja2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgYW55IHdyaXRlLWxvY2sgaXMgYXBwbGllZCBvbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgLy8gVG8gc2ltcGxpZnkgdGhlIERleGllIEFQSSBmb3IgZXh0ZW5zaW9uIGltcGxlbWVudGF0aW9ucywgd2Ugc3VwcG9ydCByZWN1cnNpdmUgbG9ja3MuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSB1c2luZyBcIlByb21pc2UgU3BlY2lmaWMgRGF0YVwiIChQU0QpLlxuICAgICAgICAgICAgLy8gUFNEIGRhdGEgaXMgYm91bmQgdG8gYSBQcm9taXNlIGFuZCBhbnkgY2hpbGQgUHJvbWlzZSBlbWl0dGVkIHRocm91Z2ggdGhlbigpIG9yIHJlc29sdmUoIG5ldyBQcm9taXNlKCkgKS5cbiAgICAgICAgICAgIC8vIFBTRCBpcyBsb2NhbCB0byBjb2RlIGV4ZWN1dGluZyBvbiB0b3Agb2YgdGhlIGNhbGwgc3RhY2tzIG9mIGFueSBvZiBhbnkgY29kZSBleGVjdXRlZCBieSBQcm9taXNlKCk6XG4gICAgICAgICAgICAvLyAgICAgICAgICogY2FsbGJhY2sgZ2l2ZW4gdG8gdGhlIFByb21pc2UoKSBjb25zdHJ1Y3RvciAgKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3Qpey4uLn0pXG4gICAgICAgICAgICAvLyAgICAgICAgICogY2FsbGJhY2tzIGdpdmVuIHRvIHRoZW4oKS9jYXRjaCgpL2ZpbmFsbHkoKSBtZXRob2RzIChmdW5jdGlvbiAodmFsdWUpey4uLn0pXG4gICAgICAgICAgICAvLyBJZiBjcmVhdGluZyBhIG5ldyBpbmRlcGVuZGFudCBQcm9taXNlIGluc3RhbmNlIGZyb20gd2l0aGluIGEgUHJvbWlzZSBjYWxsIHN0YWNrLCB0aGUgbmV3IFByb21pc2Ugd2lsbCBkZXJpdmUgdGhlIFBTRCBmcm9tIHRoZSBjYWxsIHN0YWNrIG9mIHRoZSBwYXJlbnQgUHJvbWlzZS5cbiAgICAgICAgICAgIC8vIERlcml2YXRpb24gaXMgZG9uZSBzbyB0aGF0IHRoZSBpbm5lciBQU0QgX19wcm90b19fIHBvaW50cyB0byB0aGUgb3V0ZXIgUFNELlxuICAgICAgICAgICAgLy8gUFNELmxvY2tPd25lckZvciB3aWxsIHBvaW50IHRvIGN1cnJlbnQgdHJhbnNhY3Rpb24gb2JqZWN0IGlmIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIFBTRCBzY29wZSBvd25zIHRoZSBsb2NrLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Vsb2NrICYmIFBTRC5sb2NrT3duZXJGb3IgIT09IHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMuaWRidHJhbnMpO1xuICAgICAgICAgICAgaWYgKCFpZGJ0cmFucyAmJiAhaWRiZGIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRiT3BlbkVycm9yICYmIGRiT3BlbkVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkRhdGFiYXNlQ2xvc2VkRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9ycyB3aGVyZSBpdCBpcyBubyBkaWZmZXJlbmNlIHdoZXRoZXIgaXQgd2FzIGNhdXNlZCBieSB0aGUgdXNlciBvcGVyYXRpb24gb3IgYW4gZWFybGllciBjYWxsIHRvIGRiLm9wZW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvcnMgd2hlcmUgaXQgaXMgbm8gZGlmZmVyZW5jZSB3aGV0aGVyIGl0IHdhcyBjYXVzZWQgYnkgdGhlIHVzZXIgb3BlcmF0aW9uIG9yIGFuIGVhcmxpZXIgY2FsbCB0byBkYi5vcGVuKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoZGJPcGVuRXJyb3IubWVzc2FnZSwgZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBpdCBjbGVhciB0aGF0IHRoZSB1c2VyIG9wZXJhdGlvbiB3YXMgbm90IHdoYXQgY2F1c2VkIHRoZSBlcnJvciAtIHRoZSBlcnJvciBoYWQgb2NjdXJyZWQgZWFybGllciBvbiBkYi5vcGVuKCkhXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5PcGVuRmFpbGVkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLl9jb21wbGV0aW9uLl9zdGF0ZSA9PT0gbnVsbCk7XG4gICAgICAgICAgICBpZGJ0cmFucyA9IHRoaXMuaWRidHJhbnMgPSBpZGJ0cmFucyB8fCBpZGJkYi50cmFuc2FjdGlvbihzYWZhcmlNdWx0aVN0b3JlRml4KHRoaXMuc3RvcmVOYW1lcyksIHRoaXMubW9kZSk7XG4gICAgICAgICAgICBpZGJ0cmFucy5vbmVycm9yID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7IC8vIFByb2hpYml0IGRlZmF1bHQgYnViYmxpbmcgdG8gd2luZG93LmVycm9yXG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlamVjdChpZGJ0cmFucy5lcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgJiYgX3RoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uKFwiYWJvcnRcIikuZmlyZShldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkYnRyYW5zLm9uY29tcGxldGUgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3Byb21pc2U6IGZ1bmN0aW9uIChtb2RlLCBmbiwgYldyaXRlTG9jaykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBSRUFEV1JJVEUgJiYgdGhpcy5tb2RlICE9PSBSRUFEV1JJVEUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2NrZWRGdW5jcy5wdXNoKFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFBTRF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYldyaXRlTG9jaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcC5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl91bmxvY2soKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfcm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX3Jvb3QoKSA6IHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgb3BlcmF0ZSBvbiB0aGUgcm9vdCB0cmFuc2FjdGlvbiAoaW4gY2FzZSB0aGlzIGlzIGEgc3ViIHN0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdCgpO1xuICAgICAgICAgICAgLy8gRm9yIHN0YWJpbGl0eSByZWFzb25zLCBjb252ZXJ0IHBhcmFtZXRlciB0byBwcm9taXNlIG5vIG1hdHRlciB3aGF0IHR5cGUgaXMgcGFzc2VkIHRvIHdhaXRGb3IoKS5cbiAgICAgICAgICAgIC8vIChXZSBtdXN0IGJlIGFibGUgdG8gY2FsbCAudGhlbigpIG9uIGl0LilcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgY2FsbGVkIHdhaXRGb3IoKS4gV2FpdCBmb3IgYm90aCB0byBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb21pc2U7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgbm90IGluIHdhaXRpbmcgc3RhdGUuIFN0YXJ0IHdhaXRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgaW50ZXJhY3Rpbmcgd2l0aCBpbmRleGVkREIgdW50aWwgcHJvbWlzZSBjb21wbGV0ZXM6XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gcm9vdC5pZGJ0cmFucy5vYmplY3RTdG9yZShyb290LnN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICAgICAgICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDsgLy8gRm9yIGRlYnVnZ2luZyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyb290Ll93YWl0aW5nUXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHJvb3QuX3dhaXRpbmdRdWV1ZS5zaGlmdCgpKSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldCgtSW5maW5pdHkpLm9uc3VjY2VzcyA9IHNwaW47XG4gICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50V2FpdFByb21pc2UgPSByb290Ll93YWl0aW5nRm9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlamVjdC5iaW5kKG51bGwsIGVycikpKTsgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG9uZSBhZGRlZCBhIHdhaXQgYWZ0ZXIgdXMuIFNhZmUgdG8gc3RvcCB0aGUgc3Bpbm5pbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRyYW5zYWN0aW9uIFB1YmxpYyBQcm9wZXJ0aWVzIGFuZCBNZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSAmJiB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICB0YWJsZXM6IHtcbiAgICAgICAgICAgIGdldDogZGVwcmVjYXRlZChcIlRyYW5zYWN0aW9uLnRhYmxlc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxUYWJsZXM7IH0pXG4gICAgICAgIH0sXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gZGIudGFibGUobmFtZSk7IC8vIERvbid0IGNoZWNrIHRoYXQgdGFibGUgaXMgcGFydCBvZiB0cmFuc2FjdGlvbi4gSXQgbXVzdCBmYWlsIGxhemlseSFcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGUobmFtZSwgdGFibGUuc2NoZW1hLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFdoZXJlQ2xhdXNlXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gV2hlcmVDbGF1c2UodGFibGUsIGluZGV4LCBvckNvbGxlY3Rpb24pIHtcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGFibGVcIiB0eXBlPVwiVGFibGVcIj48L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiIHR5cGU9XCJTdHJpbmdcIiBvcHRpb25hbD1cInRydWVcIj48L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvckNvbGxlY3Rpb25cIiB0eXBlPVwiQ29sbGVjdGlvblwiIG9wdGlvbmFsPVwidHJ1ZVwiPjwvcGFyYW0+XG4gICAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCA9PT0gXCI6aWRcIiA/IG51bGwgOiBpbmRleCxcbiAgICAgICAgICAgIG9yOiBvckNvbGxlY3Rpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvcHMoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdoZXJlQ2xhdXNlIHByaXZhdGUgbWV0aG9kc1xuICAgICAgICBmdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLCBlcnIsIFQpIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UgaW5zdGFuY2VvZiBXaGVyZUNsYXVzZSA/XG4gICAgICAgICAgICAgICAgbmV3IENvbGxlY3Rpb24oY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UpIDpcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uX2N0eC5lcnJvciA9IFQgPyBuZXcgVChlcnIpIDogbmV3IFR5cGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW1wdHlDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLm9ubHkoXCJcIik7IH0pLmxpbWl0KDApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwcGVyRmFjdG9yeShkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID8gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9VcHBlckNhc2UoKTsgfSA6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgPyBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b0xvd2VyQ2FzZSgpOyB9IDogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9VcHBlckNhc2UoKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihrZXkubGVuZ3RoLCBsb3dlck5lZWRsZS5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGxscCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsd3JLZXlDaGFyID0gbG93ZXJLZXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKGx3cktleUNoYXIgIT09IGxvd2VyTmVlZGxlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyB1cHBlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsb3dlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsbHAgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlcktleVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGx3cktleUNoYXIpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgbGxwID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPCBsb3dlck5lZWRsZS5sZW5ndGggJiYgZGlyID09PSBcIm5leHRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IGtleS5sZW5ndGggJiYgZGlyID09PSBcInByZXZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIChsbHAgPCAwID8gbnVsbCA6IGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyTmVlZGxlW2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZElnbm9yZUNhc2VBbGdvcml0aG0od2hlcmVDbGF1c2UsIG1hdGNoLCBuZWVkbGVzLCBzdWZmaXgpIHtcbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5lZWRsZXNcIiB0eXBlPVwiQXJyYXlcIiBlbGVtZW50VHlwZT1cIlN0cmluZ1wiPjwvcGFyYW0+XG4gICAgICAgICAgICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LCBuZWVkbGVzTGVuID0gbmVlZGxlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIW5lZWRsZXMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXREaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgICAgICAgICBsb3dlciA9IGxvd2VyRmFjdG9yeShkaXIpO1xuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyID09PSBcIm5leHRcIiA/IHNpbXBsZUNvbXBhcmUgOiBzaW1wbGVDb21wYXJlUmV2ZXJzZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpIH07XG4gICAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cHBlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIudXBwZXI7IH0pO1xuICAgICAgICAgICAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi5sb3dlcjsgfSk7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gZGlyO1xuICAgICAgICAgICAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdERpcmVjdGlvbihcIm5leHRcIik7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKHVwcGVyTmVlZGxlc1swXSwgbG93ZXJOZWVkbGVzW25lZWRsZXNMZW4gLSAxXSArIHN1ZmZpeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZXZlbnQgb25seXMgb2NjdXIgYmVmb3JlIGZpbHRlciBpcyBjYWxsZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgICAgICAgICAgaW5pdERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBmaXJzdFBvc3NpYmxlTmVlZGxlID0gMDtcbiAgICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY3Vyc29yXCIgdHlwZT1cIklEQkN1cnNvclwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWR2YW5jZVwiIHR5cGU9XCJGdW5jdGlvblwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzb2x2ZVwiIHR5cGU9XCJGdW5jdGlvblwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGxvd2VyS2V5ID0gbG93ZXIoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gobG93ZXJLZXksIGxvd2VyTmVlZGxlcywgZmlyc3RQb3NzaWJsZU5lZWRsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQb3NzaWJsZU5lZWRsZTsgaSA8IG5lZWRsZXNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FzaW5nID09PSBudWxsICYmIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UG9zc2libGVOZWVkbGUgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBjYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICsgbmV4dEtleVN1ZmZpeCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBXaGVyZUNsYXVzZSBwdWJsaWMgbWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmV0d2VlbjogZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgaW5jbHVkZUxvd2VyLCBpbmNsdWRlVXBwZXIpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vICAgICBGaWx0ZXIgb3V0IHJlY29yZHMgd2hvc2Ugd2hlcmUtZmllbGQgbGF5cyBiZXR3ZWVuIGdpdmVuIGxvd2VyIGFuZCB1cHBlciB2YWx1ZXMuIEFwcGxpZXMgdG8gU3RyaW5ncywgTnVtYmVycyBhbmQgRGF0ZXMuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb3dlclwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidXBwZXJcIj48L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluY2x1ZGVMb3dlclwiIG9wdGlvbmFsPVwidHJ1ZVwiPldoZXRoZXIgaXRlbXMgdGhhdCBlcXVhbHMgbG93ZXIgc2hvdWxkIGJlIGluY2x1ZGVkLiBEZWZhdWx0IHRydWUuPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmNsdWRlVXBwZXJcIiBvcHRpb25hbD1cInRydWVcIj5XaGV0aGVyIGl0ZW1zIHRoYXQgZXF1YWxzIHVwcGVyIHNob3VsZCBiZSBpbmNsdWRlZC4gRGVmYXVsdCBmYWxzZS48L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwiQ29sbGVjdGlvblwiPjwvcmV0dXJucz5cbiAgICAgICAgICAgICAgICBpbmNsdWRlTG93ZXIgPSBpbmNsdWRlTG93ZXIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICAgICAgICAgICAgICBpbmNsdWRlVXBwZXIgPSBpbmNsdWRlVXBwZXIgPT09IHRydWU7IC8vIERlZmF1bHQgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNtcChsb3dlciwgdXBwZXIpID4gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpOyAvLyBXb3JrYXJvdW5kIGZvciBpZGlvdGljIFczQyBTcGVjaWZpY2F0aW9uIHRoYXQgRGF0YUVycm9yIG11c3QgYmUgdGhyb3duIGlmIGxvd2VyID4gdXBwZXIuIFRoZSBuYXR1cmFsIHJlc3VsdCB3b3VsZCBiZSB0byByZXR1cm4gYW4gZW1wdHkgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLm9ubHkodmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhYm92ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQodmFsdWUsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhYm92ZU9yRXF1YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBJREJLZXlSYW5nZS5sb3dlckJvdW5kKHZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVsb3c6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKHZhbHVlLCB0cnVlKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVsb3dPckVxdWFsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gSURCS2V5UmFuZ2UudXBwZXJCb3VuZCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdHJcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2VlbihzdHIsIHN0ciArIG1heFN0cmluZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhcnRzV2l0aElnbm9yZUNhc2U6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdHJcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAgICAgICAgICAgICBpZiAoc3RyID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHguaW5kZXhPZihhWzBdKSA9PT0gMDsgfSwgW3N0cl0sIG1heFN0cmluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXF1YWxzSWdub3JlQ2FzZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0clwiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiB4ID09PSBhWzBdOyB9LCBbc3RyXSwgXCJcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW55T2ZJZ25vcmVDYXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4gYS5pbmRleE9mKHgpICE9PSAtMTsgfSwgc2V0LCBcIlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5pbmRleE9mKG4pID09PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBzZXQsIG1heFN0cmluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW55T2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gSURCS2V5UmFuZ2UuYm91bmQoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKTsgfSk7XG4gICAgICAgICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyZWN0aW9uID09PSBcIm5leHRcIiA/IGFzY2VuZGluZyA6IGRlc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnNvciBoYXMgcGFzc2VkIGJleW9uZCB0aGlzIGtleS4gQ2hlY2sgbmV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV4dC4gU3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBjdXJzb3IgdmFsdWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY29udGludWUgYSBzaW5nbGUgc3RlcCBpbiBjYXNlIG5leHQgaXRlbSBoYXMgdGhlIHNhbWUga2V5IG9yIHBvc3NpYmx5IG91ciBuZXh0IGtleSBpbiBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnNvci5rZXkgbm90IHlldCBhdCBzZXRbaV0uIEZvcndhcmQgY3Vyc29yIHRvIHRoZSBuZXh0IGtleSB0byBodW50IGZvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3RFcXVhbDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShbW21pbktleSwgdmFsdWVdLCBbdmFsdWUsIG1heEtleV1dLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub25lT2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7IC8vIFJldHVybiBlbnRpcmUgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXQuc29ydChhc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBbXCJhXCIsXCJiXCIsXCJjXCJdIHRvIGEgc2V0IG9mIHJhbmdlcyBmb3IgYmV0d2Vlbi9hYm92ZS9iZWxvdzogW1ttaW5LZXksXCJhXCJdLCBbXCJhXCIsXCJiXCJdLCBbXCJiXCIsXCJjXCJdLCBbXCJjXCIsbWF4S2V5XV1cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2V0LnJlZHVjZShmdW5jdGlvbiAocmVzLCB2YWwpIHsgcmV0dXJuIHJlcyA/IHJlcy5jb25jYXQoW1tyZXNbcmVzLmxlbmd0aCAtIDFdWzFdLCB2YWxdXSkgOiBbW21pbktleSwgdmFsXV07IH0sIG51bGwpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKFtzZXRbc2V0Lmxlbmd0aCAtIDFdLCBtYXhLZXldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHJhbmdlcywgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIEZpbHRlciBvdXQgdmFsdWVzIHdpdGhpbmcgZ2l2ZW4gc2V0IG9mIHJhbmdlcy5cbiAgICAgICAgICAgICogRXhhbXBsZSwgZ2l2ZSBjaGlsZHJlbiBhbmQgZWxkZXJzIGEgcmViYXRlIG9mIDUwJTpcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogICBkYi5mcmllbmRzLndoZXJlKCdhZ2UnKS5pbkFueVJhbmdlKFtbMCwxOF0sWzY1LEluZmluaXR5XV0pLm1vZGlmeSh7UmViYXRlOiAxLzJ9KTtcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxEYXRlfEFycmF5KVtdW119IHJhbmdlc1xuICAgICAgICAgICAgKiBAcGFyYW0ge3tpbmNsdWRlTG93ZXJzOiBib29sZWFuLCBpbmNsdWRlVXBwZXJzOiBib29sZWFufX0gb3B0aW9uc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluQW55UmFuZ2U6IGZ1bmN0aW9uIChyYW5nZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcy5ldmVyeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIHJhbmdlWzBdICE9PSB1bmRlZmluZWQgJiYgcmFuZ2VbMV0gIT09IHVuZGVmaW5lZCAmJiBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcIkZpcnN0IGFyZ3VtZW50IHRvIGluQW55UmFuZ2UoKSBtdXN0IGJlIGFuIEFycmF5IG9mIHR3by12YWx1ZSBBcnJheXMgW2xvd2VyLHVwcGVyXSB3aGVyZSB1cHBlciBtdXN0IG5vdCBiZSBsb3dlciB0aGFuIGxvd2VyXCIsIGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluY2x1ZGVMb3dlcnMgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmluY2x1ZGVMb3dlcnMgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZVVwcGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlVXBwZXJzID09PSB0cnVlOyAvLyBEZWZhdWx0IHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkUmFuZ2UocmFuZ2VzLCBuZXdSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMF0gPSBtaW4ocmFuZ2VbMF0sIG5ld1JhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSA9IG1heChyYW5nZVsxXSwgbmV3UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByYW5nZVNvcnRlcihhLCBiKSB7IHJldHVybiBzb3J0RGlyZWN0aW9uKGFbMF0sIGJbMF0pOyB9XG4gICAgICAgICAgICAgICAgLy8gSm9pbiBvdmVybGFwcGluZyByYW5nZXNcbiAgICAgICAgICAgICAgICB2YXIgc2V0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHJhbmdlcy5yZWR1Y2UoYWRkUmFuZ2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGtleUlzQmV5b25kQ3VycmVudEVudHJ5ID0gaW5jbHVkZVVwcGVycyA/XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtpXVsxXSkgPiAwOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYXNjZW5kaW5nKGtleSwgc2V0W2ldWzFdKSA+PSAwOyB9O1xuICAgICAgICAgICAgICAgIHZhciBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSA9IGluY2x1ZGVMb3dlcnMgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W2ldWzBdKSA+IDA7IH0gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W2ldWzBdKSA+PSAwOyB9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFrZXlJc0JleW9uZEN1cnJlbnRFbnRyeShrZXkpICYmICFrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnNvciBoYXMgcGFzc2VkIGJleW9uZCB0aGlzIGtleS4gQ2hlY2sgbmV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV4dC4gU3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBjdXJzb3IgdmFsdWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY29udGludWUgYSBzaW5nbGUgc3RlcCBpbiBjYXNlIG5leHQgaXRlbSBoYXMgdGhlIHNhbWUga2V5IG9yIHBvc3NpYmx5IG91ciBuZXh0IGtleSBpbiBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjbXAoa2V5LCBzZXRbaV1bMV0pID09PSAwIHx8IGNtcChrZXksIHNldFtpXVswXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGVVcHBlciBvciBpbmNsdWRlTG93ZXIgaXMgZmFsc2Ugc28ga2V5V2l0aGluQ3VycmVudFJhbmdlKCkgcmV0dXJucyBmYWxzZSBldmVuIHRob3VnaCB3ZSBhcmUgYXQgcmFuZ2UgYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBrZXkgYnV0IGRvbid0IGluY2x1ZGUgdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJzb3Iua2V5IG5vdCB5ZXQgYXQgc2V0W2ldLiBGb3J3YXJkIGN1cnNvciB0byB0aGUgbmV4dCBrZXkgdG8gaHVudCBmb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydHNXaXRoQW55T2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICghc2V0LmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2Uoc2V0Lm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc3RyLCBzdHIgKyBtYXhTdHJpbmddO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyBDb2xsZWN0aW9uIENsYXNzXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwga2V5UmFuZ2VHZW5lcmF0b3IpIHtcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxuICAgICAgICAvLy9cbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2hlcmVDbGF1c2VcIiB0eXBlPVwiV2hlcmVDbGF1c2VcIj5XaGVyZSBjbGF1c2UgaW5zdGFuY2U8L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlSYW5nZUdlbmVyYXRvclwiIHZhbHVlPVwiZnVuY3Rpb24oKXsgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKDAsMSk7fVwiIG9wdGlvbmFsPVwidHJ1ZVwiPjwvcGFyYW0+XG4gICAgICAgIHZhciBrZXlSYW5nZSA9IG51bGwsIGVycm9yID0gbnVsbDtcbiAgICAgICAgaWYgKGtleVJhbmdlR2VuZXJhdG9yKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBrZXlSYW5nZSA9IGtleVJhbmdlR2VuZXJhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB2YXIgd2hlcmVDdHggPSB3aGVyZUNsYXVzZS5fY3R4LCB0YWJsZSA9IHdoZXJlQ3R4LnRhYmxlO1xuICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICBpbmRleDogd2hlcmVDdHguaW5kZXgsXG4gICAgICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcbiAgICAgICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcbiAgICAgICAgICAgIGtleXNPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIGRpcjogXCJuZXh0XCIsXG4gICAgICAgICAgICB1bmlxdWU6IFwiXCIsXG4gICAgICAgICAgICBhbGdvcml0aG06IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICBqdXN0TGltaXQ6IHRydWUsXG4gICAgICAgICAgICBpc01hdGNoOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgbGltaXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgb3I6IHdoZXJlQ3R4Lm9yLFxuICAgICAgICAgICAgdmFsdWVNYXBwZXI6IHRhYmxlLmhvb2sucmVhZGluZy5maXJlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZShjdHgsIGlnbm9yZUxpbWl0RmlsdGVyKSB7XG4gICAgICAgIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG4gICAgICAgICAgICAoaWdub3JlTGltaXRGaWx0ZXIgPyBjdHguanVzdExpbWl0IDogIWN0eC5yZXBsYXlGaWx0ZXIpO1xuICAgIH1cbiAgICBwcm9wcyhDb2xsZWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBDb2xsZWN0aW9uIFByaXZhdGUgRnVuY3Rpb25zXG4gICAgICAgIC8vXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZpbHRlcihjdHgsIGZuKSB7XG4gICAgICAgICAgICBjdHguZmlsdGVyID0gY29tYmluZShjdHguZmlsdGVyLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkUmVwbGF5RmlsdGVyKGN0eCwgZmFjdG9yeSwgaXNMaW1pdEZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGN1cnIgPSBjdHgucmVwbGF5RmlsdGVyO1xuICAgICAgICAgICAgY3R4LnJlcGxheUZpbHRlciA9IGN1cnIgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKTsgfSA6IGZhY3Rvcnk7XG4gICAgICAgICAgICBjdHguanVzdExpbWl0ID0gaXNMaW1pdEZpbHRlciAmJiAhY3VycjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHgsIGZuKSB7XG4gICAgICAgICAgICBjdHguaXNNYXRjaCA9IGNvbWJpbmUoY3R4LmlzTWF0Y2gsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHBhcmFtIGN0eCB7XG4gICAgICAgICAqICAgICAgaXNQcmltS2V5OiBib29sZWFuLFxuICAgICAgICAgKiAgICAgIHRhYmxlOiBUYWJsZSxcbiAgICAgICAgICogICAgICBpbmRleDogc3RyaW5nXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQHBhcmFtIHN0b3JlIElEQk9iamVjdFN0b3JlXG4gICAgICAgICAqKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0SW5kZXhPclN0b3JlKGN0eCwgc3RvcmUpIHtcbiAgICAgICAgICAgIGlmIChjdHguaXNQcmltS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZTtcbiAgICAgICAgICAgIHZhciBpbmRleFNwZWMgPSBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpbmRleFNwZWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIHN0b3JlLm5hbWUgKyBcIiBpcyBub3QgaW5kZXhlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5pbmRleChpbmRleFNwZWMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBwYXJhbSBjdHgge1xuICAgICAgICAgKiAgICAgIGlzUHJpbUtleTogYm9vbGVhbixcbiAgICAgICAgICogICAgICB0YWJsZTogVGFibGUsXG4gICAgICAgICAqICAgICAgaW5kZXg6IHN0cmluZyxcbiAgICAgICAgICogICAgICBrZXlzT25seTogYm9vbGVhbixcbiAgICAgICAgICogICAgICByYW5nZT86IElEQktleVJhbmdlLFxuICAgICAgICAgKiAgICAgIGRpcjogXCJuZXh0XCIgfCBcInByZXZcIlxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKGN0eCwgc3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBpZHhPclN0b3JlID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgc3RvcmUpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5rZXlzT25seSAmJiAnb3BlbktleUN1cnNvcicgaW4gaWR4T3JTdG9yZSA/XG4gICAgICAgICAgICAgICAgaWR4T3JTdG9yZS5vcGVuS2V5Q3Vyc29yKGN0eC5yYW5nZSB8fCBudWxsLCBjdHguZGlyICsgY3R4LnVuaXF1ZSkgOlxuICAgICAgICAgICAgICAgIGlkeE9yU3RvcmUub3BlbkN1cnNvcihjdHgucmFuZ2UgfHwgbnVsbCwgY3R4LmRpciArIGN0eC51bmlxdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXIoY3R4LCBmbiwgcmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuICAgICAgICAgICAgaWYgKCFjdHgub3IpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBpZGJzdG9yZSksIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sIHJlc29sdmUsIHJlamVjdCwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZWJvdGgoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytyZXNvbHZlZCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7IC8vIFNlZW1zIGxpa2Ugd2UganVzdCBzdXBwb3J0IG9yIGJ0d24gbWF4IDIgZXhwcmVzc2lvbnMsIGJ1dCB0aGVyZSBhcmUgbm8gbGltaXQgYmVjYXVzZSB3ZSBkbyByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdW5pb24oaXRlbSwgY3Vyc29yLCBhZHZhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlYm90aCwgcmVqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnICsgcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duKHNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgcmVzb2x2ZWJvdGgsIHJlamVjdCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBpZGJzdG9yZSksIGN0eC5hbGdvcml0aG0sIHVuaW9uLCByZXNvbHZlYm90aCwgcmVqZWN0LCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcik7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENvbGxlY3Rpb24gUHJvdGVjdGVkIEZ1bmN0aW9uc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIF9yZWFkOiBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICAgICAgICAgIGN0eC50YWJsZS5faWRic3RvcmUoUkVBRE9OTFksIGZuKS50aGVuKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfd3JpdGU6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGFibGUuX2lkYnN0b3JlKFJFQURXUklURSwgZm4sIFwibG9ja2VkXCIpOyAvLyBXaGVuIGRvaW5nIHdyaXRlIG9wZXJhdGlvbnMgb24gY29sbGVjdGlvbnMsIGFsd2F5cyBsb2NrIHRoZSBvcGVyYXRpb24gc28gdGhhdCB1cGNvbWluZyBvcGVyYXRpb25zIGdldHMgcXVldWVkLlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hZGRBbGdvcml0aG06IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgY3R4LmFsZ29yaXRobSA9IGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZm4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pdGVyYXRlOiBmdW5jdGlvbiAoZm4sIHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCByZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKHByb3BzJCQxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksIGN0eCA9IE9iamVjdC5jcmVhdGUodGhpcy5fY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMkJDEpXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChjdHgsIHByb3BzJCQxKTtcbiAgICAgICAgICAgICAgICBydi5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDb2xsZWN0aW9uIFB1YmxpYyBtZXRob2RzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyKGN0eCwgZm4sIHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvdW50OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcGxhaW4ga2V5IHJhbmdlLiBXZSBjYW4gdXNlIHRoZSBjb3VudCgpIG1ldGhvZCBpZiB0aGUgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IChjdHgucmFuZ2UgPyBpZHguY291bnQoY3R4LnJhbmdlKSA6IGlkeC5jb3VudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKE1hdGgubWluKGUudGFyZ2V0LnJlc3VsdCwgY3R4LmxpbWl0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGdvcml0aG1zLCBmaWx0ZXJzIG9yIGV4cHJlc3Npb25zIGFyZSBhcHBsaWVkLiBOZWVkIHRvIGNvdW50IG1hbnVhbGx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcihjdHgsIGZ1bmN0aW9uICgpIHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCBmdW5jdGlvbiAoKSB7IHJlc29sdmUoY291bnQpOyB9LCByZWplY3QsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0Qnk6IGZ1bmN0aW9uIChrZXlQYXRoLCBjYikge1xuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImtleVBhdGhcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXlQYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpLCBsYXN0UGFydCA9IHBhcnRzWzBdLCBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtsYXN0UGFydF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvcmRlciA9IHRoaXMuX2N0eC5kaXIgPT09IFwibmV4dFwiID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhVmFsID0gZ2V0dmFsKGEsIGxhc3RJbmRleCksIGJWYWwgPSBnZXR2YWwoYiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFWYWwgPCBiVmFsID8gLW9yZGVyIDogYVZhbCA+IGJWYWwgPyBvcmRlciA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCAmJiBjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBvcHRpbWF0aW9uIGlmIHdlIGNvdWxkIHVzZSBJREJPYmplY3RTdG9yZS5nZXRBbGwoKSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGluZ0hvb2sgPSBjdHgudGFibGUuaG9vay5yZWFkaW5nLmZpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4T3JTdG9yZSA9IGdldEluZGV4T3JTdG9yZShjdHgsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBjdHgubGltaXQgPCBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4T3JTdG9yZS5nZXRBbGwoY3R4LnJhbmdlLCBjdHgubGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHhPclN0b3JlLmdldEFsbChjdHgucmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSByZWFkaW5nSG9vayA9PT0gbWlycm9yID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN1Y2Nlc3NIYW5kbGVyKHJlc29sdmUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN1Y2Nlc3NIYW5kbGVyKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzLm1hcChyZWFkaW5nSG9vaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldHRpbmcgYXJyYXkgdGhyb3VnaCBhIGN1cnNvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyKGN0eCwgZnVuY3Rpb24gKGl0ZW0pIHsgYS5wdXNoKGl0ZW0pOyB9LCBmdW5jdGlvbiBhcnJheUNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgY3R4Lm9mZnNldCArPSBvZmZzZXQ7IC8vIEZvciBjb3VudCgpXG4gICAgICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShvZmZzZXRMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoLS1vZmZzZXRMZWZ0IDwgMCk7IH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW1pdDogZnVuY3Rpb24gKG51bVJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpOyAvLyBGb3IgY291bnQoKVxuICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3NMZWZ0ID0gbnVtUm93cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTsgLy8gU3RvcCBhZnRlciB0aGlzIGl0ZW0gaGFzIGJlZW4gaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3dzTGVmdCA+PSAwOyAvLyBJZiBudW1Sb3dzIGlzIGFscmVhZHkgYmVsb3cgMCwgcmV0dXJuIGZhbHNlIGJlY2F1c2UgdGhlbiAwIHdhcyBwYXNzZWQgdG8gbnVtUm93cyBpbml0aWFsbHkuIE90aGVyd2lzZSB3ZSB3b3VsZG50IGNvbWUgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnRpbDogZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uLCBiSW5jbHVkZVN0b3BFbnRyeSkge1xuICAgICAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYkluY2x1ZGVTdG9wRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS50b0FycmF5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3QoY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwianNGdW5jdGlvbkZpbHRlclwiIHR5cGU9XCJGdW5jdGlvblwiPmZ1bmN0aW9uKHZhbCl7cmV0dXJuIHRydWUvZmFsc2V9PC9wYXJhbT5cbiAgICAgICAgICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIG1hdGNoIGZpbHRlcnMgbm90IHVzZWQgaW4gRGV4aWUuanMgYnV0IGNhbiBiZSB1c2VkIGJ5IDNyZCBwYXJ0IGxpYnJhcmllcyB0byB0ZXN0IGFcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0aW9uIGZvciBhIG1hdGNoIHdpdGhvdXQgcXVlcnlpbmcgREIuIFVzZWQgYnkgRGV4aWUuT2JzZXJ2YWJsZS5cbiAgICAgICAgICAgICAgICBhZGRNYXRjaEZpbHRlcih0aGlzLl9jdHgsIGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmQ6IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3I6IGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LmRpciA9ICh0aGlzLl9jdHguZGlyID09PSBcInByZXZcIiA/IFwibmV4dFwiIDogXCJwcmV2XCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UodGhpcy5fY3R4LmRpcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlYWNoS2V5OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3Iua2V5LCBjdXJzb3IpOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlYWNoVW5pcXVlS2V5OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgudW5pcXVlID0gXCJ1bmlxdWVcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoS2V5KGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlYWNoUHJpbWFyeUtleTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvcik7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpbWFyeUtleXM6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCAmJiBjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIG9wdGltYXRpb24gaWYgd2UgY291bGQgdXNlIElEQk9iamVjdFN0b3JlLmdldEFsbEtleXMoKSBvclxuICAgICAgICAgICAgICAgICAgICAvLyBJREJLZXlSYW5nZS5nZXRBbGxLZXlzKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4T3JTdG9yZSA9IGdldEluZGV4T3JTdG9yZShjdHgsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBjdHgubGltaXQgPCBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4T3JTdG9yZS5nZXRBbGxLZXlzKGN0eC5yYW5nZSwgY3R4LmxpbWl0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4T3JTdG9yZS5nZXRBbGxLZXlzKGN0eC5yYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50U3VjY2Vzc0hhbmRsZXIocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5pcXVlS2V5czogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlyc3RLZXk6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RLZXk6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdEtleShjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzdGluY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCBpZHggPSBjdHguaW5kZXggJiYgY3R4LnRhYmxlLnNjaGVtYS5pZHhCeU5hbWVbY3R4LmluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkeCB8fCAhaWR4Lm11bHRpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gZGlzdGluY3QoKSBvbmx5IG1ha2VzIGRpZmZlcmVuY2llcyBvbiBtdWx0aUVudHJ5IGluZGV4ZXMuXG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cktleSA9IGN1cnNvci5wcmltYXJ5S2V5LnRvU3RyaW5nKCk7IC8vIENvbnZlcnRzIGFueSBEYXRlIHRvIFN0cmluZywgU3RyaW5nIHRvIFN0cmluZywgTnVtYmVyIHRvIFN0cmluZyBhbmQgQXJyYXkgdG8gY29tbWEtc2VwYXJhdGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBoYXNPd24oc2V0LCBzdHJLZXkpO1xuICAgICAgICAgICAgICAgICAgICBzZXRbc3RyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE1ldGhvZHMgdGhhdCBtdXRhdGUgc3RvcmFnZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIG1vZGlmeTogZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGN0eCA9IHRoaXMuX2N0eCwgaG9vayA9IGN0eC50YWJsZS5ob29rLCB1cGRhdGluZ0hvb2sgPSBob29rLnVwZGF0aW5nLmZpcmUsIGRlbGV0aW5nSG9vayA9IGhvb2suZGVsZXRpbmcuZmlyZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUsIHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZnllcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2VzIGlzIGEgZnVuY3Rpb24gdGhhdCBtYXkgdXBkYXRlLCBhZGQgb3IgZGVsZXRlIHByb3B0ZXJ0aWVzIG9yIGV2ZW4gcmVxdWlyZSBhIGRlbGV0aW9uIHRoZSBvYmplY3QgaXRzZWxmIChkZWxldGUgdGhpcy5pdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0aW5nSG9vayA9PT0gbm9wICYmIGRlbGV0aW5nSG9vayA9PT0gbm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9vbmUgY2FyZXMgYWJvdXQgd2hhdCBpcyBiZWluZyBjaGFuZ2VkLiBKdXN0IGxldCB0aGUgbW9kaWZpZXIgZnVuY3Rpb24gYmUgdGhlIGdpdmVuIGFyZ3VtZW50IGFzIGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gY2hhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlb3BsZSB3YW50IHRvIGtub3cgZXhhY3RseSB3aGF0IGlzIGJlaW5nIG1vZGlmaWVkIG9yIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV0IG1vZGlmeWVyIGJlIGEgcHJveHkgZnVuY3Rpb24gdGhhdCBmaW5kcyBvdXQgd2hhdCBjaGFuZ2VzIHRoZSBjYWxsZXIgaXMgYWN0dWFsbHkgZG9pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY2FsbCB0aGUgaG9va3MgYWNjb3JkaW5nbHkhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ0l0ZW0gPSBkZWVwQ2xvbmUoaXRlbSk7IC8vIENsb25lIHRoZSBpdGVtIGZpcnN0IHNvIHdlIGNhbiBjb21wYXJlIGxhdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMuY2FsbCh0aGlzLCBpdGVtLCB0aGlzKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIENhbGwgdGhlIHJlYWwgbW9kaWZ5ZXIgZnVuY3Rpb24gKElmIGl0IHJldHVybnMgZmFsc2UgZXhwbGljaXRlbHksIGl0IG1lYW5zIGl0IGRvbnQgd2FudCB0byBtb2RpZnkgYW55dGluZyBvbiB0aGlzIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd24odGhpcywgXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYWwgbW9kaWZ5ZXIgZnVuY3Rpb24gcmVxdWVzdHMgYSBkZWxldGlvbiBvZiB0aGUgb2JqZWN0LiBJbmZvcm0gdGhlIGRlbGV0aW5nSG9vayB0aGF0IGEgZGVsZXRpb24gaXMgdGFraW5nIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRpbmdIb29rLmNhbGwodGhpcywgdGhpcy5wcmltS2V5LCBpdGVtLCB0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBkZWxldGlvbi4gQ2hlY2sgd2hhdCB3YXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdERpZmYgPSBnZXRPYmplY3REaWZmKG9yaWdJdGVtLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsQ2hhbmdlcyA9IHVwZGF0aW5nSG9vay5jYWxsKHRoaXMsIG9iamVjdERpZmYsIHRoaXMucHJpbUtleSwgb3JpZ0l0ZW0sIHRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvb2sgd2FudCB0byBhcHBseSBhZGRpdGlvbmFsIG1vZGlmaWNhdGlvbnMuIE1ha2Ugc3VyZSB0byBmdWxsZmlsbCB0aGUgd2lsbCBvZiB0aGUgaG9vay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzKGFkZGl0aW9uYWxDaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc1trZXlQYXRoXSk7IC8vIEFkZGluZyB7a2V5UGF0aDogdW5kZWZpbmVkfSBtZWFucyB0aGF0IHRoZSBrZXlQYXRoIHNob3VsZCBiZSBkZWxldGVkLiBIYW5kbGVkIGJ5IHNldEJ5S2V5UGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cGRhdGluZ0hvb2sgPT09IG5vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpcyBhIHNldCBvZiB7a2V5UGF0aDogdmFsdWV9IGFuZCBubyBvbmUgaXMgbGlzdGVuaW5nIHRvIHRoZSB1cGRhdGluZyBob29rLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnl0aGluZ01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBrZXlQYXRoc1tpXSwgdmFsID0gY2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoKSAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTsgLy8gQWRkaW5nIHtrZXlQYXRoOiB1bmRlZmluZWR9IG1lYW5zIHRoYXQgdGhlIGtleVBhdGggc2hvdWxkIGJlIGRlbGV0ZWQuIEhhbmRsZWQgYnkgc2V0QnlLZXlQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGlzIGEgc2V0IG9mIHtrZXlQYXRoOiB2YWx1ZX0gYW5kIHBlb3BsZSBhcmUgbGlzdGVuaW5nIHRvIHRoZSB1cGRhdGluZyBob29rIHNvIHdlIG5lZWQgdG8gY2FsbCBpdCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IGl0IHRvIGFkZCBhZGRpdGlvbmFsIG1vZGlmaWNhdGlvbnMgdG8gbWFrZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnQ2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzID0gc2hhbGxvd0Nsb25lKG9yaWdDaGFuZ2VzKTsgLy8gTGV0J3Mgd29yayB3aXRoIGEgY2xvbmUgb2YgdGhlIGNoYW5nZXMga2V5UGF0aC92YWx1ZSBzZXQgc28gdGhhdCB3ZSBjYW4gcmVzdG9yZSBpdCBpbiBjYXNlIGEgaG9vayBleHRlbmRzIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnl0aGluZ01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxDaGFuZ2VzID0gdXBkYXRpbmdIb29rLmNhbGwodGhpcywgY2hhbmdlcywgdGhpcy5wcmltS2V5LCBkZWVwQ2xvbmUoaXRlbSksIHRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZChjaGFuZ2VzLCBhZGRpdGlvbmFsQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cyhjaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBzaGFsbG93Q2xvbmUob3JpZ0NoYW5nZXMpOyAvLyBSZXN0b3JlIG9yaWdpbmFsIGNoYW5nZXMgZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9uQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWlsS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1vZGlmeUl0ZW0oaXRlbSwgY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50S2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0NvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleTogY3Vyc29yLnByaW1hcnlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25zdWNjZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxLZXlzLnB1c2godGhpc0NvbnRleHQucHJpbUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBDYXRjaCB0aGVzZSBlcnJvcnMgYW5kIGxldCBhIGZpbmFsIHJlamVjdGlvbiBkZWNpZGUgd2hldGhlciBvciBub3QgdG8gYWJvcnQgZW50aXJlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZ5ZXIuY2FsbCh0aGlzQ29udGV4dCwgaXRlbSwgdGhpc0NvbnRleHQpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiRGVsZXRlID0gIWhhc093bih0aGlzQ29udGV4dCwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IChiRGVsZXRlID8gY3Vyc29yLmRlbGV0ZSgpIDogY3Vyc29yLnVwZGF0ZSh0aGlzQ29udGV4dC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEuX2hvb2tDdHggPSB0aGlzQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBob29rZWRFdmVudFJlamVjdEhhbmRsZXIob25lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrc3VjY2Vzc0NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBvbmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNDb250ZXh0Lm9uc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvb2sgd2lsbCBleHBlY3QgZWl0aGVyIG9uZXJyb3Igb3Igb25zdWNjZXNzIHRvIGFsd2F5cyBiZSBjYWxsZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0NvbnRleHQub25zdWNjZXNzKHRoaXNDb250ZXh0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb1JlamVjdChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbEtleXMucHVzaChjdXJyZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IE1vZGlmeUVycm9yKFwiRXJyb3IgbW9kaWZ5aW5nIG9uZSBvciBtb3JlIG9iamVjdHNcIiwgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbEtleXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja0ZpbmlzaGVkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbkNvbXBsZXRlICYmIHN1Y2Nlc3NDb3VudCArIGZhaWx1cmVzLmxlbmd0aCA9PT0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9SZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3VjY2Vzc0NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb25lKCkucmF3KCkuX2l0ZXJhdGUobW9kaWZ5SXRlbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBkb1JlamVjdCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCByYW5nZSA9IGN0eC5yYW5nZSwgZGVsZXRpbmdIb29rID0gY3R4LnRhYmxlLmhvb2suZGVsZXRpbmcuZmlyZSwgaGFzRGVsZXRlSG9vayA9IGRlbGV0aW5nSG9vayAhPT0gbm9wO1xuICAgICAgICAgICAgICAgIGlmICghaGFzRGVsZXRlSG9vayAmJlxuICAgICAgICAgICAgICAgICAgICBpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoKGN0eC5pc1ByaW1LZXkgJiYgIWhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlKSB8fCAhcmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1heSB1c2UgSURCT2JqZWN0U3RvcmUuZGVsZXRlKElEQktleVJhbmdlKSBpbiB0aGlzIGNhc2UgKElzc3VlICMyMDgpXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBjaHJvbWl1bSwgdGhpcyBpcyB0aGUgd2F5IG1vc3Qgb3B0aW1pemVkIHZlcnNpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBJRS9FZGdlLCB0aGlzIGNvdWxkIGhhbmcgdGhlIGluZGV4ZWREQiBlbmdpbmUgYW5kIG1ha2Ugb3BlcmF0aW5nIHN5c3RlbSBpbnN0YWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZGZhaGxhbmRlci81YTM5MzI4ZjAyOWRlMTgyMjJjZjIxMjVkNTZjMzhmNylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXIgQVBJIGNvbnRyYWN0IGlzIHRvIHJldHVybiBhIGNvdW50IG9mIGRlbGV0ZWQgaXRlbXMsIHNvIHdlIGhhdmUgdG8gY291bnQoKSBiZWZvcmUgZGVsZXRlKCkuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpLCBjb3VudFJlcSA9IChyYW5nZSA/IGlkYnN0b3JlLmNvdW50KHJhbmdlKSA6IGlkYnN0b3JlLmNvdW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRSZXEub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudFJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gY291bnRSZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbFJlcSA9IChyYW5nZSA/IGlkYnN0b3JlLmRlbGV0ZShyYW5nZSkgOiBpZGJzdG9yZS5jbGVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsUmVxLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShjb3VudCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdmVyc2lvbiB0byB1c2Ugd2hlbiBjb2xsZWN0aW9uIGlzIG5vdCBhIHZhbmlsbGEgSURCS2V5UmFuZ2Ugb24gdGhlIHByaW1hcnkga2V5LlxuICAgICAgICAgICAgICAgIC8vIERpdmlkZSBpbnRvIGNodW5rcyB0byBub3Qgc3RhcnZlIFJBTS5cbiAgICAgICAgICAgICAgICAvLyBJZiBoYXMgZGVsZXRlIGhvb2ssIHdlIHdpbGwgaGF2ZSB0byBjb2xsZWN0IG5vdCBqdXN0IGtleXMgYnV0IGFsc28gb2JqZWN0cywgc28gaXQgd2lsbCB1c2VcbiAgICAgICAgICAgICAgICAvLyBtb3JlIG1lbW9yeSBhbmQgbmVlZCBsb3dlciBjaHVuayBzaXplLlxuICAgICAgICAgICAgICAgIHZhciBDSFVOS1NJWkUgPSBoYXNEZWxldGVIb29rID8gMjAwMCA6IDEwMDAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSwgdHJhbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZSBjb2xsZWN0aW9uIGFuZCBjaGFuZ2UgaXRzIHRhYmxlIGFuZCBzZXQgYSBsaW1pdCBvZiBDSFVOS1NJWkUgb24gdGhlIGNsb25lZCBDb2xsZWN0aW9uIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2xvbmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5c09ubHk6ICFjdHguaXNNYXRjaCAmJiAhaGFzRGVsZXRlSG9va1xuICAgICAgICAgICAgICAgICAgICB9KSAvLyBsb2FkIGp1c3Qga2V5cyAodW5sZXNzIGZpbHRlcigpIG9yIGFuZCgpIG9yIGRlbGV0ZUhvb2sgaGFzIHN1YnNjcmliZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRpc3RpbmN0KCkgLy8gSW4gY2FzZSBtdWx0aUVudHJ5IGlzIHVzZWQsIG5ldmVyIGRlbGV0ZSBzYW1lIGtleSB0d2ljZSBiZWNhdXNlIHJlc3VsdGluZyBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgLmxpbWl0KENIVU5LU0laRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yYXcoKTsgLy8gRG9uJ3QgZmlsdGVyIHRocm91Z2ggcmVhZGluZy1ob29rcyAobGlrZSBtYXBwZWQgY2xhc3NlcyBldGMpXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzT3JUdXBsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZ29ubmEgZG8gdGhpbmdzIG9uIGFzIG1hbnkgY2h1bmtzIHRoYXQgYXJlIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHJlY3Vyc2lvbiBvZiBuZXh0Q2h1bmsgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2h1bmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLmVhY2goaGFzRGVsZXRlSG9vayA/IGZ1bmN0aW9uICh2YWwsIGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZWJvZHkgc3Vic2NyaWJlcyB0byBob29rKCdkZWxldGluZycpLiBDb2xsZWN0IGFsbCBwcmltYXJ5IGtleXMgYW5kIHRoZWlyIHZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGhvb2sgY2FuIGJlIGNhbGxlZCB3aXRoIGl0cyB2YWx1ZXMgaW4gYnVsa0RlbGV0ZSgpLlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5c09yVHVwbGVzLnB1c2goW2N1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IudmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWwsIGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gb25lIHN1YnNjcmliZXMgdG8gaG9vaygnZGVsZXRpbmcnKS4gQ29sbGVjdCBvbmx5IHByaW1hcnkga2V5czpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXNPclR1cGxlcy5wdXNoKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bSBkZWxldGVzIGZhc3RlciB3aGVuIGRvaW5nIGl0IGluIHNvcnQgb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEZWxldGVIb29rID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzT3JUdXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYXNjZW5kaW5nKGFbMF0sIGJbMF0pOyB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c09yVHVwbGVzLnNvcnQoYXNjZW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWxrRGVsZXRlKGlkYnN0b3JlLCB0cmFucywga2V5c09yVHVwbGVzLCBoYXNEZWxldGVIb29rLCBkZWxldGluZ0hvb2spO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGtleXNPclR1cGxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbENvdW50ICs9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5c09yVHVwbGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgPCBDSFVOS1NJWkUgPyB0b3RhbENvdW50IDogbmV4dENodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5leHRDaHVuaygpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEhlbHAgZnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIGZ1bmN0aW9uIGxvd2VyVmVyc2lvbkZpcnN0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEFwaU9uUGxhY2Uob2JqcywgdGFibGVOYW1lcywgZGJzY2hlbWEpIHtcbiAgICAgICAgdGFibGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBkYnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0YWJsZU5hbWUgaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBUcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iaiBpcyBhIFRyYW5zYWN0aW9uIHByb3RvdHlwZSAob3IgcHJvdG90eXBlIG9mIGEgc3ViY2xhc3MgdG8gVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBBUEkgYSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoaXMudGFibGUodGFibGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChvYmosIHRhYmxlTmFtZSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIHdpbGwgbm90IGJlIGJvdW5kIHRvIGEgdHJhbnNhY3Rpb24gKHdpbGwgdXNlIERleGllLmN1cnJlbnRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialt0YWJsZU5hbWVdID0gbmV3IFRhYmxlKHRhYmxlTmFtZSwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlVGFibGVzQXBpKG9ianMpIHtcbiAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXRlcmF0ZShyZXEsIGZpbHRlciwgZm4sIHJlc29sdmUsIHJlamVjdCwgdmFsdWVNYXBwZXIpIHtcbiAgICAgICAgLy8gQXBwbHkgdmFsdWVNYXBwZXIgKGhvb2soJ3JlYWRpbmcnKSBvciBtYXBwcGVkIGNsYXNzKVxuICAgICAgICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/IGZ1bmN0aW9uICh4LCBjLCBhKSB7IHJldHVybiBmbih2YWx1ZU1hcHBlcih4KSwgYywgYSk7IH0gOiBmbjtcbiAgICAgICAgLy8gV3JhcCBmbiB3aXRoIFBTRCBhbmQgbWljcm90aWNrIHN0dWZmIGZyb20gUHJvbWlzZS5cbiAgICAgICAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4sIHJlamVjdCk7XG4gICAgICAgIGlmICghcmVxLm9uZXJyb3IpXG4gICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gdHJ5Y2F0Y2hlcihmdW5jdGlvbiBmaWx0ZXJfcmVjb3JkKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZSgpOyB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IGMgPSBhZHZhbmNlcjsgfSwgcmVzb2x2ZSwgcmVqZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbihjdXJzb3IudmFsdWUsIGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IGMgPSBhZHZhbmNlcjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHRyeWNhdGNoZXIoZnVuY3Rpb24gZmlsdGVyX3JlY29yZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUoKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBmdW5jdGlvbiAoYWR2YW5jZXIpIHsgYyA9IGFkdmFuY2VyOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VJbmRleFN5bnRheChpbmRleGVzKSB7XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4ZXNcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJBcnJheVwiIGVsZW1lbnRUeXBlPVwiSW5kZXhTcGVjXCI+PC9yZXR1cm5zPlxuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgaW5kZXhlcy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4LnRyaW0oKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5kZXgucmVwbGFjZSgvKFsmKl18XFwrXFwrKS9nLCBcIlwiKTsgLy8gUmVtb3ZlIFwiJlwiLCBcIisrXCIgYW5kIFwiKlwiXG4gICAgICAgICAgICAvLyBMZXQga2V5UGF0aCBvZiBcIlthK2JdXCIgYmUgW1wiYVwiLFwiYlwiXTpcbiAgICAgICAgICAgIHZhciBrZXlQYXRoID0gL15cXFsvLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC9eXFxbKC4qKVxcXSQvKVsxXS5zcGxpdCgnKycpIDogbmFtZTtcbiAgICAgICAgICAgIHJ2LnB1c2gobmV3IEluZGV4U3BlYyhuYW1lLCBrZXlQYXRoIHx8IG51bGwsIC9cXCYvLnRlc3QoaW5kZXgpLCAvXFwqLy50ZXN0KGluZGV4KSwgL1xcK1xcKy8udGVzdChpbmRleCksIGlzQXJyYXkoa2V5UGF0aCksIC9cXC4vLnRlc3QoaW5kZXgpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNtcChrZXkxLCBrZXkyKSB7XG4gICAgICAgIHJldHVybiBpbmRleGVkREIuY21wKGtleTEsIGtleTIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaW4oYSwgYikge1xuICAgICAgICByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGEgOiBiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXgoYSwgYikge1xuICAgICAgICByZXR1cm4gY21wKGEsIGIpID4gMCA/IGEgOiBiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICAgICAgICByZXR1cm4gaW5kZXhlZERCLmNtcChhLCBiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBpbmRleGVkREIuY21wKGIsIGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaW1wbGVDb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmVSZXZlcnNlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICAgICAgICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICAgICAgICBmaWx0ZXIyID9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgICAgICAgIGZpbHRlcjI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRHbG9iYWxTY2hlbWEoKSB7XG4gICAgICAgIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuICAgICAgICBkYi5fZGJTY2hlbWEgPSBnbG9iYWxTY2hlbWEgPSB7fTtcbiAgICAgICAgZGJTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgICAgIGlmIChkYlN0b3JlTmFtZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBEYXRhYmFzZSBjb250YWlucyBubyBzdG9yZXMuXG4gICAgICAgIHZhciB0cmFucyA9IGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgoZGJTdG9yZU5hbWVzKSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgIGRiU3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSksIGtleVBhdGggPSBzdG9yZS5rZXlQYXRoLCBkb3R0ZWQgPSBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBrZXlQYXRoLmluZGV4T2YoJy4nKSAhPT0gLTE7XG4gICAgICAgICAgICB2YXIgcHJpbUtleSA9IG5ldyBJbmRleFNwZWMoa2V5UGF0aCwga2V5UGF0aCB8fCBcIlwiLCBmYWxzZSwgZmFsc2UsICEhc3RvcmUuYXV0b0luY3JlbWVudCwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycsIGRvdHRlZCk7XG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkYmluZGV4ID0gc3RvcmUuaW5kZXgoc3RvcmUuaW5kZXhOYW1lc1tqXSk7XG4gICAgICAgICAgICAgICAga2V5UGF0aCA9IGlkYmluZGV4LmtleVBhdGg7XG4gICAgICAgICAgICAgICAgZG90dGVkID0ga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgJiYga2V5UGF0aC5pbmRleE9mKCcuJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG5ldyBJbmRleFNwZWMoaWRiaW5kZXgubmFtZSwga2V5UGF0aCwgISFpZGJpbmRleC51bmlxdWUsICEhaWRiaW5kZXgubXVsdGlFbnRyeSwgZmFsc2UsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnLCBkb3R0ZWQpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbG9iYWxTY2hlbWFbc3RvcmVOYW1lXSA9IG5ldyBUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEFwaU9uUGxhY2UoW2FsbFRhYmxlc10sIGtleXMoZ2xvYmFsU2NoZW1hKSwgZ2xvYmFsU2NoZW1hKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoc2NoZW1hLCBpZGJ0cmFucykge1xuICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgIC8vLyBJc3N1ZSAjMzAgUHJvYmxlbSB3aXRoIGV4aXN0aW5nIGRiIC0gYWRqdXN0IHRvIGV4aXN0aW5nIGluZGV4IG5hbWVzIHdoZW4gbWlncmF0aW5nIGZyb20gbm9uLWRleGllIGRiXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjaGVtYVwiIHR5cGU9XCJPYmplY3RcIj5NYXAgYmV0d2VlbiBuYW1lIGFuZCBUYWJsZVNjaGVtYTwvcGFyYW0+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlkYnRyYW5zXCIgdHlwZT1cIklEQlRyYW5zYWN0aW9uXCI+PC9wYXJhbT5cbiAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSBzdG9yZU5hbWVzW2ldO1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIGhhc0dldEFsbCA9ICdnZXRBbGwnIGluIHN0b3JlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4TmFtZSA9IHN0b3JlLmluZGV4TmFtZXNbal07XG4gICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5pbmRleChpbmRleE5hbWUpLmtleVBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIGRleGllTmFtZSA9IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IGtleVBhdGggOiBcIltcIiArIHNsaWNlKGtleVBhdGgpLmpvaW4oJysnKSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFbc3RvcmVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhTcGVjID0gc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFNwZWMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnIHdpdGggZ2V0QWxsKCkgb24gU2FmYXJpIHZlcjw2MDQgb24gV29ya2VycyBvbmx5LCBzZWUgZGlzY3Vzc2lvbiBmb2xsb3dpbmcgUFIgIzU3OVxuICAgICAgICBpZiAoL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmIF9nbG9iYWwgaW5zdGFuY2VvZiBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KSB7XG4gICAgICAgICAgICBoYXNHZXRBbGwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJlT25CbG9ja2VkKGV2KSB7XG4gICAgICAgIGRiLm9uKFwiYmxvY2tlZFwiKS5maXJlKGV2KTtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCAobm90IGZ1bGx5KikgZm9yIG1pc3NpbmcgXCJ2ZXJzaW9uY2hhbmdlXCIgZXZlbnQgaW4gSUUsRWRnZSBhbmQgU2FmYXJpOlxuICAgICAgICBjb25uZWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5uYW1lID09PSBkYi5uYW1lICYmIGMgIT09IGRiICYmICFjLl92Y0ZpcmVkOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7IH0pO1xuICAgIH1cbiAgICBleHRlbmQodGhpcywge1xuICAgICAgICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uLFxuICAgICAgICBUYWJsZTogVGFibGUsXG4gICAgICAgIFRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbixcbiAgICAgICAgVmVyc2lvbjogVmVyc2lvbixcbiAgICAgICAgV2hlcmVDbGF1c2U6IFdoZXJlQ2xhdXNlXG4gICAgfSk7XG4gICAgaW5pdCgpO1xuICAgIGFkZG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICBmbihkYik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gW3BhcnNlVHlwZSh0eXBlWzBdKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgJiYgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBydiA9IHt9O1xuICAgICAgICBhcHBseVN0cnVjdHVyZShydiwgdHlwZSk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5U3RydWN0dXJlKG9iaiwgc3RydWN0dXJlKSB7XG4gICAga2V5cyhzdHJ1Y3R1cmUpLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVR5cGUoc3RydWN0dXJlW21lbWJlcl0pO1xuICAgICAgICBvYmpbbWVtYmVyXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKHJlc29sdmUpIHtcbiAgICAvLyB3cmFwKCkgaXMgbmVlZGVkIHdoZW4gY2FsbGluZyBob29rcyBiZWNhdXNlIHRoZSByYXJlIHNjZW5hcmlvIG9mOlxuICAgIC8vICAqIGhvb2sgZG9lcyBhIGRiIG9wZXJhdGlvbiB0aGF0IGZhaWxzIGltbWVkaWF0ZWx5IChJREIgdGhyb3dzIGV4Y2VwdGlvbilcbiAgICAvLyAgICBGb3IgY2FsbGluZyBkYiBvcGVyYXRpb25zIG9uIGNvcnJlY3QgdHJhbnNhY3Rpb24sIHdyYXAgbWFrZXMgc3VyZSB0byBzZXQgUFNEIGNvcnJlY3RseS5cbiAgICAvLyAgICB3cmFwKCkgd2lsbCBhbHNvIGV4ZWN1dGUgaW4gYSB2aXJ0dWFsIHRpY2suXG4gICAgLy8gICogSWYgbm90IHdyYXBwZWQgaW4gYSB2aXJ0dWFsIHRpY2ssIGRpcmVjdCBleGNlcHRpb24gd2lsbCBsYXVuY2ggYSBuZXcgcGh5c2ljYWwgdGljay5cbiAgICAvLyAgKiBJZiB0aGlzIHdhcyB0aGUgbGFzdCBldmVudCBpbiB0aGUgYnVsaywgdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIGFmdGVyIGEgcGh5c2ljYWwgdGlja1xuICAgIC8vICAgIGFuZCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBoYXZlIGNvbW1pdHRlZCBhbHJlYWR5LlxuICAgIC8vIElmIG5vIGhvb2ssIHRoZSB2aXJ0dWFsIHRpY2sgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgcmVqZWN0KCkvcmVzb2x2ZSBvZiB0aGUgZmluYWwgcHJvbWlzZSxcbiAgICAvLyBiZWNhdXNlIGl0IGlzIGFsd2F5cyBtYXJrZWQgd2l0aCBfbGliID0gdHJ1ZSB3aGVuIGNyZWF0ZWQgdXNpbmcgVHJhbnNhY3Rpb24uX3Byb21pc2UoKS5cbiAgICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJlcSA9IGV2ZW50LnRhcmdldCwgY3R4ID0gcmVxLl9ob29rQ3R4LCAvLyBDb250YWlucyB0aGUgaG9vayBlcnJvciBoYW5kbGVyLiBQdXQgaGVyZSBpbnN0ZWFkIG9mIGNsb3N1cmUgdG8gYm9vc3QgcGVyZm9ybWFuY2UuXG4gICAgICAgIHJlc3VsdCA9IGN0eC52YWx1ZSB8fCByZXEucmVzdWx0LCAvLyBQYXNzIHRoZSBvYmplY3QgdmFsdWUgb24gdXBkYXRlcy4gVGhlIHJlc3VsdCBmcm9tIElEQiBpcyB0aGUgcHJpbWFyeSBrZXkuXG4gICAgICAgIGhvb2tTdWNjZXNzSGFuZGxlciA9IGN0eCAmJiBjdHgub25zdWNjZXNzO1xuICAgICAgICBob29rU3VjY2Vzc0hhbmRsZXIgJiYgaG9va1N1Y2Nlc3NIYW5kbGVyKHJlc3VsdCk7XG4gICAgICAgIHJlc29sdmUgJiYgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0sIHJlc29sdmUpO1xufVxuZnVuY3Rpb24gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuICAgIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBldmVudFN1Y2Nlc3NIYW5kbGVyKHJlc29sdmUpIHtcbiAgICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpIHtcbiAgICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gU2VlIGNvbW1lbnQgb24gaG9va2VkRXZlbnRTdWNjZXNzSGFuZGxlcigpIHdoeSB3cmFwKCkgaXMgbmVlZGVkIG9ubHkgd2hlbiBzdXBwb3J0aW5nIGhvb2tzLlxuICAgICAgICB2YXIgcmVxID0gZXZlbnQudGFyZ2V0LCBlcnIgPSByZXEuZXJyb3IsIGN0eCA9IHJlcS5faG9va0N0eCwgLy8gQ29udGFpbnMgdGhlIGhvb2sgZXJyb3IgaGFuZGxlci4gUHV0IGhlcmUgaW5zdGVhZCBvZiBjbG9zdXJlIHRvIGJvb3N0IHBlcmZvcm1hbmNlLlxuICAgICAgICBob29rRXJyb3JIYW5kbGVyID0gY3R4ICYmIGN0eC5vbmVycm9yO1xuICAgICAgICBob29rRXJyb3JIYW5kbGVyICYmIGhvb2tFcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBhd2FpdEl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgdmFyIGNhbGxOZXh0ID0gZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gaXRlcmF0b3IubmV4dChyZXN1bHQpOyB9LCBkb1Rocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpdGVyYXRvci50aHJvdyhlcnJvcik7IH0sIG9uU3VjY2VzcyA9IHN0ZXAoY2FsbE5leHQpLCBvbkVycm9yID0gc3RlcChkb1Rocm93KTtcbiAgICBmdW5jdGlvbiBzdGVwKGdldE5leHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dCh2YWwpLCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5kb25lID8gdmFsdWUgOlxuICAgICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KHZhbHVlKSA/IFByb21pc2UuYWxsKHZhbHVlKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikgOiBvblN1Y2Nlc3ModmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ZXAoY2FsbE5leHQpKCk7XG59XG4vL1xuLy8gSW5kZXhTcGVjIHN0cnVjdFxuLy9cbmZ1bmN0aW9uIEluZGV4U3BlYyhuYW1lLCBrZXlQYXRoLCB1bmlxdWUsIG11bHRpLCBhdXRvLCBjb21wb3VuZCwgZG90dGVkKSB7XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwibmFtZVwiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImtleVBhdGhcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJ1bmlxdWVcIiB0eXBlPVwiQm9vbGVhblwiPjwvcGFyYW0+XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwibXVsdGlcIiB0eXBlPVwiQm9vbGVhblwiPjwvcGFyYW0+XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiYXV0b1wiIHR5cGU9XCJCb29sZWFuXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb21wb3VuZFwiIHR5cGU9XCJCb29sZWFuXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJkb3R0ZWRcIiB0eXBlPVwiQm9vbGVhblwiPjwvcGFyYW0+XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMudW5pcXVlID0gdW5pcXVlO1xuICAgIHRoaXMubXVsdGkgPSBtdWx0aTtcbiAgICB0aGlzLmF1dG8gPSBhdXRvO1xuICAgIHRoaXMuY29tcG91bmQgPSBjb21wb3VuZDtcbiAgICB0aGlzLmRvdHRlZCA9IGRvdHRlZDtcbiAgICB2YXIga2V5UGF0aFNyYyA9IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IGtleVBhdGggOiBrZXlQYXRoICYmICgnWycgKyBbXS5qb2luLmNhbGwoa2V5UGF0aCwgJysnKSArICddJyk7XG4gICAgdGhpcy5zcmMgPSAodW5pcXVlID8gJyYnIDogJycpICsgKG11bHRpID8gJyonIDogJycpICsgKGF1dG8gPyBcIisrXCIgOiBcIlwiKSArIGtleVBhdGhTcmM7XG59XG4vL1xuLy8gVGFibGVTY2hlbWEgc3RydWN0XG4vL1xuZnVuY3Rpb24gVGFibGVTY2hlbWEobmFtZSwgcHJpbUtleSwgaW5kZXhlcywgaW5zdGFuY2VUZW1wbGF0ZSkge1xuICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5hbWVcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcmltS2V5XCIgdHlwZT1cIkluZGV4U3BlY1wiPjwvcGFyYW0+XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhlc1wiIHR5cGU9XCJBcnJheVwiIGVsZW1lbnRUeXBlPVwiSW5kZXhTcGVjXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnN0YW5jZVRlbXBsYXRlXCIgdHlwZT1cIk9iamVjdFwiPjwvcGFyYW0+XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByaW1LZXkgPSBwcmltS2V5IHx8IG5ldyBJbmRleFNwZWMoKTtcbiAgICB0aGlzLmluZGV4ZXMgPSBpbmRleGVzIHx8IFtuZXcgSW5kZXhTcGVjKCldO1xuICAgIHRoaXMuaW5zdGFuY2VUZW1wbGF0ZSA9IGluc3RhbmNlVGVtcGxhdGU7XG4gICAgdGhpcy5tYXBwZWRDbGFzcyA9IG51bGw7XG4gICAgdGhpcy5pZHhCeU5hbWUgPSBhcnJheVRvT2JqZWN0KGluZGV4ZXMsIGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gW2luZGV4Lm5hbWUsIGluZGV4XTsgfSk7XG59XG5mdW5jdGlvbiBzYWZhcmlNdWx0aVN0b3JlRml4KHN0b3JlTmFtZXMpIHtcbiAgICByZXR1cm4gc3RvcmVOYW1lcy5sZW5ndGggPT09IDEgPyBzdG9yZU5hbWVzWzBdIDogc3RvcmVOYW1lcztcbn1cbmZ1bmN0aW9uIGdldE5hdGl2ZUdldERhdGFiYXNlTmFtZXNGbihpbmRleGVkREIpIHtcbiAgICB2YXIgZm4gPSBpbmRleGVkREIgJiYgKGluZGV4ZWREQi5nZXREYXRhYmFzZU5hbWVzIHx8IGluZGV4ZWREQi53ZWJraXRHZXREYXRhYmFzZU5hbWVzKTtcbiAgICByZXR1cm4gZm4gJiYgZm4uYmluZChpbmRleGVkREIpO1xufVxuLy8gRXhwb3J0IEVycm9yIGNsYXNzZXNcbnByb3BzKERleGllLCBmdWxsTmFtZUV4Y2VwdGlvbnMpOyAvLyBEZXhpZS5YWFhFcnJvciA9IGNsYXNzIFhYWEVycm9yIHsuLi59O1xuLy9cbi8vIFN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG4vLyBcbnByb3BzKERleGllLCB7XG4gICAgLy9cbiAgICAvLyBTdGF0aWMgZGVsZXRlKCkgbWV0aG9kLlxuICAgIC8vXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAoZGF0YWJhc2VOYW1lKSB7XG4gICAgICAgIHZhciBkYiA9IG5ldyBEZXhpZShkYXRhYmFzZU5hbWUpLCBwcm9taXNlID0gZGIuZGVsZXRlKCk7XG4gICAgICAgIHByb21pc2Uub25ibG9ja2VkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBkYi5vbihcImJsb2NrZWRcIiwgZm4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgLy9cbiAgICAvLyBTdGF0aWMgZXhpc3RzKCkgbWV0aG9kLlxuICAgIC8vXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IERleGllKG5hbWUpLm9wZW4oKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5jYXRjaChEZXhpZS5Ob1N1Y2hEYXRhYmFzZUVycm9yLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgfSxcbiAgICAvL1xuICAgIC8vIFN0YXRpYyBtZXRob2QgZm9yIHJldHJpZXZpbmcgYSBsaXN0IG9mIGFsbCBleGlzdGluZyBkYXRhYmFzZXMgYXQgY3VycmVudCBob3N0LlxuICAgIC8vXG4gICAgZ2V0RGF0YWJhc2VOYW1lczogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBnZXREYXRhYmFzZU5hbWVzID0gZ2V0TmF0aXZlR2V0RGF0YWJhc2VOYW1lc0ZuKERleGllLmRlcGVuZGVuY2llcy5pbmRleGVkREIpO1xuICAgICAgICByZXR1cm4gZ2V0RGF0YWJhc2VOYW1lcyA/IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXEgPSBnZXREYXRhYmFzZU5hbWVzKCk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzbGljZShldmVudC50YXJnZXQucmVzdWx0LCAwKSk7IC8vIENvbnZlcnN0IERPTVN0cmluZ0xpc3QgdG8gQXJyYXk8U3RyaW5nPlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgIH0pLnRoZW4oY2IpIDogZGJOYW1lc0RCLmRibmFtZXMudG9Db2xsZWN0aW9uKCkucHJpbWFyeUtleXMoY2IpO1xuICAgIH0sXG4gICAgZGVmaW5lQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBjb25zdHJ1Y3RvciBhYmxlIHRvIGNvcHkgZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuICAgICAgICBmdW5jdGlvbiBDbGFzcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm9wZXJ0aWVzXCIgdHlwZT1cIk9iamVjdFwiIG9wdGlvbmFsPVwidHJ1ZVwiPlByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvYmplY3Qgd2l0aC5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDbGFzcztcbiAgICB9LFxuICAgIGFwcGx5U3RydWN0dXJlOiBhcHBseVN0cnVjdHVyZSxcbiAgICBpZ25vcmVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKHNjb3BlRnVuYykge1xuICAgICAgICAvLyBJbiBjYXNlIGNhbGxlciBpcyB3aXRoaW4gYSB0cmFuc2FjdGlvbiBidXQgbmVlZHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vIEV4YW1wbGUgb2YgdXNhZ2U6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIExldCdzIHNheSB3ZSBoYXZlIGEgbG9nZ2VyIGZ1bmN0aW9uIGluIG91ciBhcHAuIE90aGVyIGFwcGxpY2F0aW9uLWxvZ2ljIHNob3VsZCBiZSB1bmF3YXJlIG9mIHRoZVxuICAgICAgICAvLyBsb2dnZXIgZnVuY3Rpb24gYW5kIG5vdCBuZWVkIHRvIGluY2x1ZGUgdGhlICdsb2dlbnRyaWVzJyB0YWJsZSBpbiBhbGwgdHJhbnNhY3Rpb24gaXQgcGVyZm9ybXMuXG4gICAgICAgIC8vIFRoZSBsb2dnaW5nIHNob3VsZCBhbHdheXMgYmUgZG9uZSBpbiBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uIGFuZCBub3QgYmUgZGVwZW5kYW50IG9uIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHJ1bm5pbmcgdHJhbnNhY3Rpb24gY29udGV4dC4gVGhlbiB5b3UgY291bGQgdXNlIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkgdG8gcnVuIGNvZGUgdGhhdCBzdGFydHMgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgICAgICBkYi5sb2dlbnRyaWVzLmFkZChuZXdMb2dFbnRyeSk7XG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVW5sZXNzIHVzaW5nIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCksIHRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIHRyeSB0byByZXVzZSB0aGUgY3VycmVudCB0cmFuc2FjdGlvblxuICAgICAgICAvLyBpbiBjdXJyZW50IFByb21pc2Utc2NvcGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFuIGFsdGVybmF0aXZlIHRvIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkgd291bGQgYmUgc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLiBUaGUgcmVhc29uIHdlIHN0aWxsIHByb3ZpZGUgYW5cbiAgICAgICAgLy8gQVBJIGZvciB0aGlzIGJlY2F1c2VcbiAgICAgICAgLy8gIDEpIFRoZSBpbnRlbnRpb24gb2Ygd3JpdGluZyB0aGUgc3RhdGVtZW50IGNvdWxkIGJlIHVuY2xlYXIgaWYgdXNpbmcgc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLlxuICAgICAgICAvLyAgMikgc2V0VGltZW91dCgpIHdvdWxkIHdhaXQgdW5uZXNjZXNzYXJ5IHVudGlsIGZpcmluZy4gVGhpcyBpcyBob3dldmVyIG5vdCB0aGUgY2FzZSB3aXRoIHNldEltbWVkaWF0ZSgpLlxuICAgICAgICAvLyAgMykgc2V0SW1tZWRpYXRlKCkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgRVMgc3RhbmRhcmQuXG4gICAgICAgIC8vICA0KSBZb3UgbWlnaHQgd2FudCB0byBrZWVwIG90aGVyIFBTRCBzdGF0ZSB0aGF0IHdhcyBzZXQgaW4gYSBwYXJlbnQgUFNELCBzdWNoIGFzIFBTRC5sZXRUaHJvdWdoLlxuICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDogLy8gVXNlIHRoZSBjbG9zZXN0IHBhcmVudCB0aGF0IHdhcyBub24tdHJhbnNhY3Rpb25hbC5cbiAgICAgICAgICAgIHNjb3BlRnVuYygpOyAvLyBObyBuZWVkIHRvIGNoYW5nZSBzY29wZSBiZWNhdXNlIHRoZXJlIGlzIG5vIG9uZ29pbmcgdHJhbnNhY3Rpb24uXG4gICAgfSxcbiAgICB2aXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAvLyBUbyBiZSB1c2VkIGJ5IHN1YnNjcmliZXJzIHRvIHRoZSBvbigncmVhZHknKSBldmVudC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGxldCBjYWxsZXIgdGhyb3VnaCB0byBhY2Nlc3MgREIgZXZlbiB3aGVuIGl0IGlzIGJsb2NrZWQgd2hpbGUgdGhlIGRiLnJlYWR5KCkgc3Vic2NyaWJlcnMgYXJlIGZpcmluZy5cbiAgICAgICAgLy8gVGhpcyB3b3VsZCBoYXZlIHdvcmtlZCBhdXRvbWF0aWNhbGx5IGlmIHdlIHdlcmUgY2VydGFpbiB0aGF0IHRoZSBQcm92aWRlciB3YXMgdXNpbmcgRGV4aWUuUHJvbWlzZSBmb3IgYWxsIGFzeW5jcm9uaWMgb3BlcmF0aW9ucy4gVGhlIHByb21pc2UgUFNEXG4gICAgICAgIC8vIGZyb20gdGhlIHByb3ZpZGVyLmNvbm5lY3QoKSBjYWxsIHdvdWxkIHRoZW4gYmUgZGVyaXZlZCBhbGwgdGhlIHdheSB0byB3aGVuIHByb3ZpZGVyIHdvdWxkIGNhbGwgbG9jYWxEYXRhYmFzZS5hcHBseUNoYW5nZXMoKS4gQnV0IHNpbmNlXG4gICAgICAgIC8vIHRoZSBwcm92aWRlciBtb3JlIGxpa2VseSBpcyB1c2luZyBub24tcHJvbWlzZSBhc3luYyBBUElzIG9yIG90aGVyIHRoZW5hYmxlIGltcGxlbWVudGF0aW9ucywgd2UgY2Fubm90IGFzc3VtZSB0aGF0LlxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgb25seSB1c2VmdWwgZm9yIG9uKCdyZWFkeScpIHN1YnNjcmliZXJzIHRoYXQgaXMgcmV0dXJuaW5nIGEgUHJvbWlzZSBmcm9tIHRoZSBldmVudC4gSWYgbm90IHVzaW5nIHZpcCgpXG4gICAgICAgIC8vIHRoZSBkYXRhYmFzZSBjb3VsZCBkZWFkbG9jayBzaW5jZSBpdCB3b250IG9wZW4gdW50aWwgdGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGFuZCBhbnkgbm9uLVZJUGVkIG9wZXJhdGlvbiBzdGFydGVkIGJ5XG4gICAgICAgIC8vIHRoZSBjYWxsZXIgd2lsbCBub3QgcmVzb2x2ZSB1bnRpbCBkYXRhYmFzZSBpcyBvcGVuZWQuXG4gICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7IC8vIE1ha2Ugc3VyZSB3ZSBhcmUgbGV0IHRocm91Z2ggaWYgc3RpbGwgYmxvY2tpbmcgZGIgZHVlIHRvIG9ucmVhZHkgaXMgZmlyaW5nLlxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXN5bmM6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNwYXduOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4sIGFyZ3MsIHRoaXopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpeiwgYXJncyB8fCBbXSkpO1xuICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGV4aWUuY3VycmVudFRyYW5zYWN0aW9uIHByb3BlcnR5XG4gICAgY3VycmVudFRyYW5zYWN0aW9uOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUFNELnRyYW5zIHx8IG51bGw7IH1cbiAgICB9LFxuICAgIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlT3JGdW5jdGlvbiwgb3B0aW9uYWxUaW1lb3V0KSB7XG4gICAgICAgIC8vIElmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGludm9rZSBpdCBhbmQgcGFzcyB0aGUgcmV0dXJuaW5nIHZhbHVlIHRvIFRyYW5zYWN0aW9uLndhaXRGb3IoKVxuICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0eXBlb2YgcHJvbWlzZU9yRnVuY3Rpb24gPT09ICdmdW5jdGlvbicgPyBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihwcm9taXNlT3JGdW5jdGlvbikgOiBwcm9taXNlT3JGdW5jdGlvbilcbiAgICAgICAgICAgIC50aW1lb3V0KG9wdGlvbmFsVGltZW91dCB8fCA2MDAwMCk7IC8vIERlZmF1bHQgdGhlIHRpbWVvdXQgdG8gb25lIG1pbnV0ZS4gQ2FsbGVyIG1heSBzcGVjaWZ5IEluZmluaXR5IGlmIHJlcXVpcmVkLiAgICAgICBcbiAgICAgICAgLy8gUnVuIGdpdmVuIHByb21pc2Ugb24gY3VycmVudCB0cmFuc2FjdGlvbi4gSWYgbm8gY3VycmVudCB0cmFuc2FjdGlvbiwganVzdCByZXR1cm4gYSBEZXhpZSBwcm9taXNlIGJhc2VkXG4gICAgICAgIC8vIG9uIGdpdmVuIHZhbHVlLlxuICAgICAgICByZXR1cm4gUFNELnRyYW5zID8gUFNELnRyYW5zLndhaXRGb3IocHJvbWlzZSkgOiBwcm9taXNlO1xuICAgIH0sXG4gICAgLy8gRXhwb3J0IG91ciBQcm9taXNlIGltcGxlbWVudGF0aW9uIHNpbmNlIGl0IGNhbiBiZSBoYW5keSBhcyBhIHN0YW5kYWxvbmUgUHJvbWlzZSBpbXBsZW1lbnRhdGlvblxuICAgIFByb21pc2U6IFByb21pc2UsXG4gICAgLy8gRGV4aWUuZGVidWcgcHJvcHRlcnk6XG4gICAgLy8gRGV4aWUuZGVidWcgPSBmYWxzZVxuICAgIC8vIERleGllLmRlYnVnID0gdHJ1ZVxuICAgIC8vIERleGllLmRlYnVnID0gXCJkZXhpZVwiIC0gZG9uJ3QgaGlkZSBkZXhpZSdzIHN0YWNrIGZyYW1lcy5cbiAgICBkZWJ1Zzoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlYnVnOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0RGVidWcodmFsdWUsIHZhbHVlID09PSAnZGV4aWUnID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSA6IGRleGllU3RhY2tGcmFtZUZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEV4cG9ydCBvdXIgZGVyaXZlL2V4dGVuZC9vdmVycmlkZSBtZXRob2RvbG9neVxuICAgIGRlcml2ZTogZGVyaXZlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBvdmVycmlkZTogb3ZlcnJpZGUsXG4gICAgLy8gRXhwb3J0IG91ciBFdmVudHMoKSBmdW5jdGlvbiAtIGNhbiBiZSBoYW5keSBhcyBhIHRvb2xraXRcbiAgICBFdmVudHM6IEV2ZW50cyxcbiAgICAvLyBVdGlsaXRpZXNcbiAgICBnZXRCeUtleVBhdGg6IGdldEJ5S2V5UGF0aCxcbiAgICBzZXRCeUtleVBhdGg6IHNldEJ5S2V5UGF0aCxcbiAgICBkZWxCeUtleVBhdGg6IGRlbEJ5S2V5UGF0aCxcbiAgICBzaGFsbG93Q2xvbmU6IHNoYWxsb3dDbG9uZSxcbiAgICBkZWVwQ2xvbmU6IGRlZXBDbG9uZSxcbiAgICBnZXRPYmplY3REaWZmOiBnZXRPYmplY3REaWZmLFxuICAgIGFzYXA6IGFzYXAsXG4gICAgbWF4S2V5OiBtYXhLZXksXG4gICAgbWluS2V5OiBtaW5LZXksXG4gICAgLy8gQWRkb24gcmVnaXN0cnlcbiAgICBhZGRvbnM6IFtdLFxuICAgIC8vIEdsb2JhbCBEQiBjb25uZWN0aW9uIGxpc3RcbiAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbnMsXG4gICAgTXVsdGlNb2RpZnlFcnJvcjogZXhjZXB0aW9ucy5Nb2RpZnksXG4gICAgZXJybmFtZXM6IGVycm5hbWVzLFxuICAgIC8vIEV4cG9ydCBvdGhlciBzdGF0aWMgY2xhc3Nlc1xuICAgIEluZGV4U3BlYzogSW5kZXhTcGVjLFxuICAgIFRhYmxlU2NoZW1hOiBUYWJsZVNjaGVtYSxcbiAgICAvL1xuICAgIC8vIERlcGVuZGVuY2llc1xuICAgIC8vXG4gICAgLy8gVGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHdvcmsgaW4gYnJvd3NlcnMgd2l0aCBpbmRleGVkREIgc3VwcG9ydCwgb3Igd2hlcmUgYW4gaW5kZXhlZERCIHBvbHlmaWxsIGhhcyBiZWVuIGluY2x1ZGVkLlxuICAgIC8vXG4gICAgLy8gSW4gbm9kZS5qcywgaG93ZXZlciwgdGhlc2UgcHJvcGVydGllcyBtdXN0IGJlIHNldCBcIm1hbnVhbGx5XCIgYmVmb3JlIGluc3RhbnNpYXRpbmcgYSBuZXcgRGV4aWUoKS5cbiAgICAvLyBGb3Igbm9kZS5qcywgeW91IG5lZWQgdG8gcmVxdWlyZSBpbmRleGVkZGItanMgb3Igc2ltaWxhciBhbmQgdGhlbiBzZXQgdGhlc2UgZGVwcy5cbiAgICAvL1xuICAgIGRlcGVuZGVuY2llczogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gUmVxdWlyZWQ6XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCOiBfZ2xvYmFsLmluZGV4ZWREQiB8fCBfZ2xvYmFsLm1vekluZGV4ZWREQiB8fCBfZ2xvYmFsLndlYmtpdEluZGV4ZWREQiB8fCBfZ2xvYmFsLm1zSW5kZXhlZERCLFxuICAgICAgICAgICAgICAgIElEQktleVJhbmdlOiBfZ2xvYmFsLklEQktleVJhbmdlIHx8IF9nbG9iYWwud2Via2l0SURCS2V5UmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCOiBudWxsLFxuICAgICAgICAgICAgICAgIElEQktleVJhbmdlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoKSxcbiAgICAvLyBBUEkgVmVyc2lvbiBOdW1iZXI6IFR5cGUgTnVtYmVyLCBtYWtlIHN1cmUgdG8gYWx3YXlzIHNldCBhIHZlcnNpb24gbnVtYmVyIHRoYXQgY2FuIGJlIGNvbXBhcmFibGUgY29ycmVjdGx5LiBFeGFtcGxlOiAwLjksIDAuOTEsIDAuOTIsIDEuMCwgMS4wMSwgMS4xLCAxLjIsIDEuMjEsIGV0Yy5cbiAgICBzZW1WZXI6IERFWElFX1ZFUlNJT04sXG4gICAgdmVyc2lvbjogREVYSUVfVkVSU0lPTi5zcGxpdCgnLicpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHBhcnNlSW50KG4pOyB9KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwLCBjLCBpKSB7IHJldHVybiBwICsgKGMgLyBNYXRoLnBvdygxMCwgaSAqIDIpKTsgfSksXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzE4NlxuICAgIC8vIHR5cGVzY3JpcHQgY29tcGlsZXIgdHNjIGluIG1vZGUgdHMtLT5lczUgJiBjb21tb25KUywgd2lsbCBleHBlY3QgcmVxdWlyZSgpIHRvIHJldHVyblxuICAgIC8vIHguZGVmYXVsdC4gV29ya2Fyb3VuZDogU2V0IERleGllLmRlZmF1bHQgPSBEZXhpZS5cbiAgICBkZWZhdWx0OiBEZXhpZSxcbiAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGltcG9ydCB7RGV4aWV9IChub24tZGVmYXVsdCBpbXBvcnQpXG4gICAgLy8gUmVhc29uIDE6IE1heSBzd2l0Y2ggdG8gdGhhdCBpbiBmdXR1cmUuXG4gICAgLy8gUmVhc29uIDI6IFdlIGRlY2xhcmUgaXQgYm90aCBkZWZhdWx0IGFuZCBuYW1lZCBleHBvcnRlZCBpbiBkLnRzIHRvIG1ha2UgaXQgcG9zc2libGVcbiAgICAvLyB0byBsZXQgYWRkb25zIGV4dGVuZCB0aGUgRGV4aWUgaW50ZXJmYWNlIHdpdGggVHlwZXNjcmlwdCAyLjEgKHdvcmtzIG9ubHkgd2hlbiBleHBsaWNpdGVseVxuICAgIC8vIGV4cG9ydGluZyB0aGUgc3ltYm9sLCBub3QganVzdCBkZWZhdWx0IGV4cG9ydGluZylcbiAgICBEZXhpZTogRGV4aWVcbn0pO1xuLy8gTWFwIERPTUVycm9ycyBhbmQgRE9NRXhjZXB0aW9ucyB0byBjb3JyZXNwb25kaW5nIERleGllIGVycm9ycy4gTWF5IGNoYW5nZSBpbiBEZXhpZSB2Mi4wLlxuUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcbi8vIEluaXRpYWxpemUgZGJOYW1lc0RCICh3b24ndCBldmVyIGJlIG9wZW5lZCBvbiBjaHJvbWl1bSBicm93c2VycycpXG5kYk5hbWVzREIgPSBuZXcgRGV4aWUoJ19fZGJuYW1lcycpO1xuZGJOYW1lc0RCLnZlcnNpb24oMSkuc3RvcmVzKHsgZGJuYW1lczogJ25hbWUnIH0pO1xuKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNaWdyYXRlIGZyb20gRGV4aWUgMS54IGRhdGFiYXNlIG5hbWVzIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2U6XG4gICAgdmFyIERCTkFNRVMgPSAnRGV4aWUuRGF0YWJhc2VOYW1lcyc7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IHVuZGVmaW5lZCAmJiBfZ2xvYmFsLmRvY3VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEhhdmUgbG9jYWxTdG9yYWdlIGFuZCBpcyBub3QgZXhlY3V0aW5nIGluIGEgd29ya2VyLiBMZXRzIG1pZ3JhdGUgZnJvbSBEZXhpZSAxLnguXG4gICAgICAgICAgICBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKERCTkFNRVMpIHx8IFwiW11cIilcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZGJOYW1lc0RCLmRibmFtZXMucHV0KHsgbmFtZTogbmFtZSB9KS5jYXRjaChub3ApOyB9KTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKERCTkFNRVMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfZSkgeyB9XG59KSgpO1xuXG5yZXR1cm4gRGV4aWU7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXhpZS5qcy5tYXBcbiIsImltcG9ydCB7IENhY2hlTW9kZWwgfSBmcm9tIFwiLi9jYWNoZS5tb2RlbHNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNhY2hlQ29uZmlnU2VydmljZSB7XHJcbiAgICBlbmFibGVMb2dzOiBib29sZWFuO1xyXG4gICAgbW9kZWxzOiBDYWNoZU1vZGVsW107XHJcbiAgICBwcmVmaXg6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENhY2hlQ29uZmlnU2VydmljZSBpbXBsZW1lbnRzIElDYWNoZUNvbmZpZ1NlcnZpY2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHVibGljIGVuYWJsZUxvZ3M6IGJvb2xlYW4sXHJcbiAgICAgICAgcHVibGljIG1vZGVsczogQ2FjaGVNb2RlbFtdLFxyXG4gICAgICAgIHB1YmxpYyBwcmVmaXg6IHN0cmluZ1xyXG4gICAgKSB7IH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQ2FjaGVDb25maWdQcm92aWRlciB7XHJcbiAgICBlbmFibGVMb2dzOiBib29sZWFuO1xyXG4gICAgbW9kZWxzOiBDYWNoZU1vZGVsW107XHJcbiAgICBwcmVmaXg6IHN0cmluZztcclxufVxyXG5cclxuY2xhc3MgQ2FjaGVDb25maWdQcm92aWRlciBpbXBsZW1lbnRzIElDYWNoZUNvbmZpZ1Byb3ZpZGVyLCBuZy5JU2VydmljZVByb3ZpZGVyIHtcclxuXHJcbiAgICBwcml2YXRlIF9zZXJ2aWNlOiBDYWNoZUNvbmZpZ1NlcnZpY2U7XHJcblxyXG4gICAgZW5hYmxlTG9nczogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgbW9kZWxzOiBDYWNoZU1vZGVsW10gPSBbXTtcclxuICAgIHByZWZpeDogc3RyaW5nID0gJ1BpcENhY2hlJztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBcIm5nSW5qZWN0XCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRnZXQoKSB7XHJcbiAgICAgICAgXCJuZ0luamVjdFwiO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fc2VydmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UgPSBuZXcgQ2FjaGVDb25maWdTZXJ2aWNlKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVMb2dzLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbHMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZWZpeFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2U7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5hbmd1bGFyXHJcbiAgICAubW9kdWxlKFwicGlwQ2FjaGVcIilcclxuICAgIC5wcm92aWRlcigncGlwQ2FjaGVDb25maWcnLCBDYWNoZUNvbmZpZ1Byb3ZpZGVyKTsiLCJpbXBvcnQgeyBJQ2FjaGVTZXJ2aWNlIH0gZnJvbSBcIi4vY2FjaGUuc2VydmljZVwiO1xyXG5pbXBvcnQgeyBDYWNoZUNvbGxlY3Rpb25QYXJhbXMgfSBmcm9tIFwiLi9jYWNoZS5tb2RlbHNcIjtcclxuXHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZUludGVyY2VwdG9yKFxyXG4gICAgJGh0dHBQcm92aWRlcjogbmcuSUh0dHBQcm92aWRlclxyXG4pIHtcclxuICAgIFwibmdJbmplY3RcIjtcclxuXHJcbiAgICAkaHR0cFByb3ZpZGVyLmludGVyY2VwdG9ycy5wdXNoKGZ1bmN0aW9uICgkcTogbmcuSVFTZXJ2aWNlLCBwaXBDYWNoZTogSUNhY2hlU2VydmljZSkge1xyXG4gICAgICAgIGNvbnN0IGdldERlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zOiBhbnkpOiBDYWNoZUNvbGxlY3Rpb25QYXJhbXMge1xyXG4gICAgICAgICAgICBjb25zdCByZXQ6IENhY2hlQ29sbGVjdGlvblBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSkgeyByZXQub2Zmc2V0ID0gcGFyc2VJbnQocGFyYW1zLm9mZnNldCwgMTApOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KCdsaW1pdCcpKSB7IHJldC5saW1pdCA9IHBhcnNlSW50KHBhcmFtcy5saW1pdCwgMTApOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IChjb25maWc6IG5nLklSZXF1ZXN0Q29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHBpcENhY2hlLm1vZGVscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWsgb2YgT2JqZWN0LmtleXMobW9kZWwuaW50ZXJjZXB0b3JzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IG1vZGVsLmludGVyY2VwdG9yc1tpa107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gaW50ZXJjZXB0b3IubWF0Y2guZXhlYyhjb25maWcudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZpZy5tZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdHRVQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGlrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGdyb3VwcyB9ID0gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpcENhY2hlLmdldEl0ZW0obW9kZWwubmFtZSwgaW50ZXJjZXB0b3IuZ2V0S2V5KGdyb3VwcyksIGludGVyY2VwdG9yLm9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmZpZyBhcyBhbnkpLm9uUmVzcG9uc2UgPSAoYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXBDYWNoZS5zZXRJdGVtKG1vZGVsLm5hbWUsIGJvZHksIGludGVyY2VwdG9yLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnRpbWVvdXQgPSAkcS5kZWZlcigpLnByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCh7IGNhY2hlZERhdGE6IGl0ZW0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29sbGVjdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gaW50ZXJjZXB0b3IuZ2V0UGFyYW1zID8gaW50ZXJjZXB0b3IuZ2V0UGFyYW1zKGNvbmZpZy5wYXJhbXMpIDogZ2V0RGVmYXVsdFBhcmFtcyhjb25maWcucGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGlwQ2FjaGUuZ2V0SXRlbXMobW9kZWwubmFtZSwgcGFyYW1zLCBpbnRlcmNlcHRvci5vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihpdGVtcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmZpZyBhcyBhbnkpLm9uUmVzcG9uc2UgPSAoYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdHMgPSBpbnRlcmNlcHRvci5yZXNwb25zZU1vZGlmeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnRlcmNlcHRvci5yZXNwb25zZU1vZGlmeS5yZXNwb25zZVRvSXRlbXMoYm9keSkgOiBib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXBDYWNoZS5zZXRJdGVtcyhtb2RlbC5uYW1lLCBpdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHBhcmFtcywgb3B0aW9uczogaW50ZXJjZXB0b3Iub3B0aW9ucyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy50aW1lb3V0ID0gJHEuZGVmZXIoKS5wcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBpbnRlcmNlcHRvci5yZXNwb25zZU1vZGlmeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGludGVyY2VwdG9yLnJlc3BvbnNlTW9kaWZ5Lml0ZW1zVG9SZXNwb25zZShpdGVtcykgOiBpdGVtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KHsgY2FjaGVkRGF0YTogcmVzcCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVua25vd24gdHlwZSBvZiBpbnRlcmNlcHRvciAoJHtpa30pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdQT1NUJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdQVVQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGlrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbGxlY3Rpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25maWcgYXMgYW55KS5vblJlc3BvbnNlID0gKGJvZHkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlwQ2FjaGUuc2V0SXRlbShtb2RlbC5uYW1lLCBib2R5LCB7IHJlbW92ZVRvdGFsOiBjb25maWcubWV0aG9kID09PSAnUE9TVCcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdERUxFVEUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGlrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGdyb3VwcyB9ID0gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmZpZyBhcyBhbnkpLm9uUmVzcG9uc2UgPSAoYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXBDYWNoZS5kZWxldGVJdGVtcyhtb2RlbC5uYW1lLCBbaW50ZXJjZXB0b3IuZ2V0S2V5KGdyb3VwcyldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzcG9uc2U6IDxUPihyZXNwb25zZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5jb25maWcuaGFzT3duUHJvcGVydHkoJ29uUmVzcG9uc2UnKSAmJiB0eXBlb2YgKHJlc3BvbnNlLmNvbmZpZyBhcyBhbnkpLm9uUmVzcG9uc2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UuY29uZmlnIGFzIGFueSkub25SZXNwb25zZShyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzcG9uc2VFcnJvcjogZnVuY3Rpb24gKHJlamVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlamVjdGlvbiAmJiByZWplY3Rpb24uY2FjaGVkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZXNvbHZlKHsgZGF0YTogcmVqZWN0aW9uLmNhY2hlZERhdGEgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KHJlamVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGFzIG5nLklIdHRwSW50ZXJjZXB0b3I7XHJcbiAgICB9KTtcclxufVxyXG5cclxuYW5ndWxhclxyXG4gICAgLm1vZHVsZSgncGlwQ2FjaGUnKVxyXG4gICAgLmNvbmZpZyhjb25maWd1cmVJbnRlcmNlcHRvcik7IiwiZXhwb3J0IGNsYXNzIENhY2hlQ29sbGVjdGlvblBhcmFtcyB7XHJcbiAgICBvZmZzZXQ/OiBudW1iZXI7XHJcbiAgICBsaW1pdD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENhY2hlSW50ZXJjZXB0b3JPcHRpb25zIHtcclxuICAgIG1heEFnZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENhY2hlTW9kZWwge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAgIG1heEFnZTogbnVtYmVyO1xyXG4gICAgICAgIGtleT86IHN0cmluZztcclxuICAgIH07XHJcbiAgICBpbnRlcmNlcHRvcnM6IHtcclxuICAgICAgICBpdGVtPzoge1xyXG4gICAgICAgICAgICBtYXRjaDogUmVnRXhwO1xyXG4gICAgICAgICAgICBvcHRpb25zPzogQ2FjaGVJbnRlcmNlcHRvck9wdGlvbnM7XHJcbiAgICAgICAgICAgIGdldEtleTogKGdyb3VwczogYW55KSA9PiBhbnk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb2xsZWN0aW9uPzoge1xyXG4gICAgICAgICAgICBtYXRjaDogUmVnRXhwO1xyXG4gICAgICAgICAgICBvcHRpb25zPzogQ2FjaGVJbnRlcmNlcHRvck9wdGlvbnM7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlTW9kaWZ5Pzoge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUb0l0ZW1zOiAocmVzcDogYW55KSA9PiBhbnlbXTtcclxuICAgICAgICAgICAgICAgIGl0ZW1zVG9SZXNwb25zZTogKGl0ZW1zOiBhbnlbXSkgPT4gYW55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldFBhcmFtcz86IChwYXJhbXM6IGFueSkgPT4gQ2FjaGVDb2xsZWN0aW9uUGFyYW1zO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbiIsImltcG9ydCB7IENhY2hlSW50ZXJjZXB0b3JPcHRpb25zLCBDYWNoZUNvbGxlY3Rpb25QYXJhbXMsIENhY2hlTW9kZWwgfSBmcm9tICcuL2NhY2hlLm1vZGVscyc7XHJcbmltcG9ydCB7IElDYWNoZUNvbmZpZ1Byb3ZpZGVyIH0gZnJvbSAnLi9jYWNoZS1jb25maWcuc2VydmljZSc7XHJcbmltcG9ydCAqIGFzIERleGllIGZyb20gJ2RleGllJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNhY2hlU2VydmljZSB7XHJcbiAgICBtb2RlbHM6IENhY2hlTW9kZWxbXTtcclxuICAgIGdldEl0ZW0obW9kZWxOYW1lOiBzdHJpbmcsIGtleTogYW55LCBvcHRpb25zPzogQ2FjaGVJbnRlcmNlcHRvck9wdGlvbnMpOiBQcm9taXNlPGFueT47XHJcbiAgICBnZXRJdGVtcyhtb2RlbE5hbWU6IHN0cmluZywgcGFyYW1zPzogQ2FjaGVDb2xsZWN0aW9uUGFyYW1zLCBvcHRpb25zPzogQ2FjaGVJbnRlcmNlcHRvck9wdGlvbnMpOiBQcm9taXNlPGFueVtdPjtcclxuICAgIHNldEl0ZW0obW9kZWxOYW1lOiBzdHJpbmcsIGl0ZW06IGFueSwgb3B0aW9ucz86IHsgcmVtb3ZlVG90YWw/OiBib29sZWFuIH0pOiBQcm9taXNlPGFueT47XHJcbiAgICBzZXRJdGVtcyhtb2RlbE5hbWU6IHN0cmluZywgaXRlbXM6IGFueVtdLCBwYXlsb2FkPzoge1xyXG4gICAgICAgIHBhcmFtcz86IENhY2hlQ29sbGVjdGlvblBhcmFtcywgb3B0aW9ucz86IENhY2hlSW50ZXJjZXB0b3JPcHRpb25zXHJcbiAgICB9KTogUHJvbWlzZTxhbnlbXT5cclxuICAgIGRlbGV0ZUl0ZW1zKG1vZGVsTmFtZTogc3RyaW5nLCBrZXlzOiBhbnlbXSk6IFByb21pc2U8YW55PjtcclxuICAgIGNsZWFyKG1vZGVsPzogc3RyaW5nIHwgc3RyaW5nW10pOiBQcm9taXNlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDYWNoZVNlcnZpY2UgaW1wbGVtZW50cyBJQ2FjaGVTZXJ2aWNlIHtcclxuXHJcbiAgICBwcml2YXRlIG9wZW5lZERicyA9IG5ldyBNYXA8c3RyaW5nLCBEZXhpZS5EZXhpZT4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZzogSUNhY2hlQ29uZmlnUHJvdmlkZXIpIHsgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0RGJOYW1lKG1vZGVsTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoIW1vZGVsTmFtZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIG5hbWUgc2hvdWxkIGJlIGRlZmluZWQnKTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5wcmVmaXggKyBtb2RlbE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtb2RlbE5hbWUuc2xpY2UoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXREYihtb2RlbDogQ2FjaGVNb2RlbCk6IERleGllLkRleGllIHtcclxuICAgICAgICBpZiAoIW1vZGVsIHx8ICFtb2RlbC5uYW1lKSB7IHRocm93IG5ldyBFcnJvcignTW9kZWwgc2hvdWxkIGJlIGRlZmluZWQnKTsgfVxyXG4gICAgICAgIGNvbnN0IGRiTmFtZSA9IHRoaXMuZ2V0RGJOYW1lKG1vZGVsLm5hbWUpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wZW5lZERicy5oYXMoZGJOYW1lKSkgeyByZXR1cm4gdGhpcy5vcGVuZWREYnMuZ2V0KGRiTmFtZSk7IH1cclxuICAgICAgICBjb25zdCBkYiA9IG5ldyBEZXhpZS5EZXhpZShkYk5hbWUpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsS2V5ID0gbW9kZWwub3B0aW9ucy5rZXkgfHwgJ2lkJztcclxuICAgICAgICBkYi52ZXJzaW9uKDEpLnN0b3Jlcyh7XHJcbiAgICAgICAgICAgIGl0ZW1zOiBtb2RlbEtleSxcclxuICAgICAgICAgICAgbGFzdFJlYWQ6ICcnLFxyXG4gICAgICAgICAgICBpbmRleGVzOiAnaWR4LCcgKyBtb2RlbEtleSxcclxuICAgICAgICAgICAgbWV0YTogJydcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9wZW5lZERicy5zZXQoZGJOYW1lLCBkYik7XHJcbiAgICAgICAgcmV0dXJuIGRiO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0TW9kZWwobW9kZWxOYW1lOiBzdHJpbmcpOiBDYWNoZU1vZGVsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHMuZmluZChtID0+IG0ubmFtZSA9PT0gbW9kZWxOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG1vZGVscygpOiBDYWNoZU1vZGVsW10geyByZXR1cm4gdGhpcy5jb25maWcubW9kZWxzIHx8IFtdOyB9XHJcblxyXG4gICAgYXN5bmMgZ2V0SXRlbShtb2RlbE5hbWU6IHN0cmluZywga2V5OiBhbnksIG9wdGlvbnM/OiBDYWNoZUludGVyY2VwdG9yT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmdldE1vZGVsKG1vZGVsTmFtZSk7XHJcbiAgICAgICAgY29uc3QgZGIgPSB0aGlzLmdldERiKG1vZGVsKTtcclxuICAgICAgICBjb25zdCBbZXhwaXJlLCBpdGVtXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgZGIudGFibGUoJ2xhc3RSZWFkJykuZ2V0KGtleSksXHJcbiAgICAgICAgICAgIGRiLnRhYmxlKCdpdGVtcycpLmdldChrZXkpXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgbWF4QWdlID0gb3B0aW9ucyAmJiBvcHRpb25zLm1heEFnZSB8fCBtb2RlbC5vcHRpb25zLm1heEFnZTtcclxuICAgICAgICBjb25zdCBleHBpcmVkID0gZXhwaXJlICsgbWF4QWdlIDw9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJ1tQaXBDYWNoZV0gR0VUIHNpbmdsZSBpdGVtICMnICsga2V5KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0l0ZW06ICcsIGl0ZW0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXhwaXJlZDogJywgZXhwaXJlZCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFeHBpcmVkIGF0OiAnLCBuZXcgRGF0ZShleHBpcmUpKTtcclxuICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXhwaXJlZCA/IG51bGwgOiBpdGVtO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0SXRlbXMobW9kZWxOYW1lOiBzdHJpbmcsIHBhcmFtcz86IENhY2hlQ29sbGVjdGlvblBhcmFtcywgb3B0aW9ucz86IENhY2hlSW50ZXJjZXB0b3JPcHRpb25zKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZXRNb2RlbChtb2RlbE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGRiID0gdGhpcy5nZXREYihtb2RlbCk7XHJcbiAgICAgICAgY29uc3QgbW9kZWxLZXkgPSBtb2RlbC5vcHRpb25zLmtleSB8fCAnaWQnO1xyXG4gICAgICAgIC8vIGdldCBpbmRleGVzIG9mIGl0ZW1zIHdlIHNob3VsZCByZWNlaXZlXHJcbiAgICAgICAgY29uc3QgdG90YWxEZXRhaWxzOiB7IHRvdGFsOiBudW1iZXIsIGxhc3RSZWFkOiBudW1iZXIgfSA9IGF3YWl0IGRiLnRhYmxlKCdtZXRhJykuZ2V0KCd0b3RhbCcpO1xyXG4gICAgICAgIGNvbnN0IG1heEFnZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhBZ2UgfHwgbW9kZWwub3B0aW9ucy5tYXhBZ2U7XHJcbiAgICAgICAgY29uc3QgdG90YWwgPSB0b3RhbERldGFpbHMgJiYgKHRvdGFsRGV0YWlscy5sYXN0UmVhZCArIG1heEFnZSA+PSBuZXcgRGF0ZSgpLnZhbHVlT2YoKSlcclxuICAgICAgICAgICAgPyB0b3RhbERldGFpbHMudG90YWwgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZCgnW1BpcENhY2hlXSBHRVQgY29sbGVjdGlvbiBvZiBpdGVtcycpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUGFyYW1zOiAnLCBwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zICYmIE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgc29tZSBsaW1pdGF0aW9ucyB3ZSBoYXZlIHRvIGdldCBpZHMgb2YgaXRlbXMgYW5kIHRoZW4gaXRlbXNcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyYW1zLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSA/IHBhcmFtcy5vZmZzZXQgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnbGltaXQnKSA/IHBhcmFtcy5saW1pdCA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBkb24ndCBuZWVkIHRvIGtub3cgYWJvdXQgdG90YWwgaXRlbXMgY291bnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ZXMgPSBhd2FpdCBkYi50YWJsZSgnaW5kZXhlcycpLndoZXJlKCdpZHgnKS5iZXR3ZWVuKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQsIHRydWUsIGZhbHNlKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhlcy5sZW5ndGggIT09IGxpbWl0ICYmICh0b3RhbCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ZXMubGVuZ3RoICE9PSB0b3RhbCAtIG9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGhlcmVcXCdzIG5vdCBlbm91Z2ggaW5mb3JtYXRpb24gYWJvdXQgaW5kZXhlcycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHMgPSBpbmRleGVzLm1hcChpZHggPT4gaWR4LmlkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbaXRlbXMsIHJlYWRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGIudGFibGUoJ2l0ZW1zJykud2hlcmUobW9kZWxLZXkpLmFueU9mKGlkcykudG9BcnJheSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYi50YWJsZSgnbGFzdFJlYWQnKS53aGVyZSgnJykuYW55T2YoaWRzKS50b0FycmF5KClcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCAhPT0gaW5kZXhlcy5sZW5ndGggfHwgIXJlYWRzIHx8IHJlYWRzLmxlbmd0aCAhPT0gaW5kZXhlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTm90IGFsbCBpdGVtcyBwcmVzZW50ZWQgaW4gY2FjaGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKC4uLnJlYWRzKSArIG1heEFnZSA8PSBuZXcgRGF0ZSgpLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0l0ZW1zIHdhcyBleHBpcmVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJdGVtczogJywgaXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3RhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIGNoZWNrIGlzIHRvdGFsIGNvdW50IG9mIGl0ZW1zIHByZXNlbnRlZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhlcyA9IGF3YWl0IGRiLnRhYmxlKCdpbmRleGVzJykud2hlcmUoJ2lkeCcpLmFib3ZlT3JFcXVhbChvZmZzZXQpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleGVzLmxlbmd0aCAhPT0gbGltaXQgfHwgaW5kZXhlcy5sZW5ndGggIT09IHRvdGFsIC0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vdCBhbGwgaXRlbXMgcHJlc2VudGVkIGluIGNhY2hlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZHMgPSBpbmRleGVzLm1hcChpZHggPT4gaWR4LmlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtpdGVtcywgcmVhZHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIGRiLnRhYmxlKCdpdGVtcycpLndoZXJlKG1vZGVsS2V5KS5hbnlPZihpZHMpLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgICAgICAgICBkYi50YWJsZSgnbGFzdFJlYWQnKS53aGVyZShtb2RlbEtleSkuYW55T2YoaWRzKS50b0FycmF5KClcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggIT09IGluZGV4ZXMubGVuZ3RoIHx8ICFyZWFkcyB8fCByZWFkcy5sZW5ndGggIT09IGluZGV4ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vdCBhbGwgaXRlbXMgcHJlc2VudGVkIGluIGNhY2hlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4oLi4ucmVhZHMpICsgbWF4QWdlID49IG5ldyBEYXRlKCkudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0l0ZW1zIHdhcyBleHBpcmVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJdGVtczogJywgaXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodG90YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBsaW1pdGF0aW9ucyB3ZSBoYXZlIHRvIHJldHVybiBhbGwgaXRlbXMgaWYgdGhleSdyZSBhbGwgcHJlc2VudGVkXHJcbiAgICAgICAgICAgIGNvbnN0IFtpdGVtcywgcmVhZHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgZGIudGFibGUoJ2l0ZW1zJykudG9BcnJheSgpLFxyXG4gICAgICAgICAgICAgICAgZGIudGFibGUoJ2xhc3RSZWFkJykudG9BcnJheSgpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCAhPT0gdG90YWwgfHwgIXJlYWRzIHx8IHJlYWRzLmxlbmd0aCAhPT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vdCBhbGwgaXRlbXMgcHJlc2VudGVkIGluIGNhY2hlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE1hdGgubWluKC4uLnJlYWRzKSArIG1heEFnZSA8PSBuZXcgRGF0ZSgpLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSXRlbXMgd2FzIGV4cGlyZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0l0ZW1zOiAnLCBpdGVtcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV2Ugd2FudCB0byByZXR1cm4gYWxsIGl0ZW1zLCBidXQgd2UgZG9uXFwndCBrbm93IGhvdyBtYW55IHRoZXkgYXJlJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0SXRlbShtb2RlbE5hbWU6IHN0cmluZywgaXRlbTogYW55LCBvcHRpb25zPzogeyByZW1vdmVUb3RhbD86IGJvb2xlYW47IH0pOiBQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZXRNb2RlbChtb2RlbE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGRiID0gdGhpcy5nZXREYihtb2RlbCk7XHJcbiAgICAgICAgY29uc3QgW2V4cGlyZSwgaXRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICBkYi50YWJsZSgnbGFzdFJlYWQnKS5wdXQobmV3IERhdGUoKS52YWx1ZU9mKCksIGl0ZW1bbW9kZWwub3B0aW9ucy5rZXldKSxcclxuICAgICAgICAgICAgZGIudGFibGUoJ2l0ZW1zJykucHV0KGl0ZW0pXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlVG90YWwpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRiLnRhYmxlKCdtZXRhJykuZGVsZXRlKCd0b3RhbCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJ1tQaXBDYWNoZV0gU0VUIHNpbmdsZSBpdGVtICMnICsgaXRlbVttb2RlbC5vcHRpb25zLmtleV0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSXRlbTogJywgaXQpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhZGVkIGF0OiAnLCBuZXcgRGF0ZSgpKTtcclxuICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXQ7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZXRJdGVtcyhtb2RlbE5hbWU6IHN0cmluZywgaXRlbXM6IGFueVtdLCBwYXlsb2FkPzpcclxuICAgICAgICB7IHBhcmFtcz86IENhY2hlQ29sbGVjdGlvblBhcmFtczsgb3B0aW9ucz86IENhY2hlSW50ZXJjZXB0b3JPcHRpb25zOyB9KTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZXRNb2RlbChtb2RlbE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsS2V5ID0gbW9kZWwub3B0aW9ucy5rZXkgfHwgJ2lkJztcclxuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZ2V0RGIobW9kZWwpO1xyXG4gICAgICAgIGNvbnN0IGxyID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGF5bG9hZCAmJiBwYXlsb2FkLnBhcmFtcyAmJiBwYXlsb2FkLnBhcmFtcy5vZmZzZXQgfHwgMDtcclxuICAgICAgICBjb25zdCBpZHMgPSBpdGVtcy5tYXAoaXQgPT4gaXRbbW9kZWxLZXldKTtcclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaWRzLm1hcCgoaWQsIGlkeCkgPT4gKHsgaWQsIGlkeDogaWR4ICsgb2Zmc2V0IH0pKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcclxuICAgICAgICAgICAgZGIudGFibGUoJ2xhc3RSZWFkJykuYnVsa1B1dChuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKS5maWxsKGxyKSwgaWRzKSxcclxuICAgICAgICAgICAgZGIudGFibGUoJ2l0ZW1zJykuYnVsa1B1dChpdGVtcyksXHJcbiAgICAgICAgICAgIGRiLnRhYmxlKCdpbmRleGVzJykuYnVsa1B1dChpbmRleGVzKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgbGV0IHRvdGFsO1xyXG4gICAgICAgIGlmICgocGF5bG9hZCAmJiBwYXlsb2FkLnBhcmFtcyAmJiBwYXlsb2FkLnBhcmFtcy5saW1pdCAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPCBwYXlsb2FkLnBhcmFtcy5saW1pdClcclxuICAgICAgICAgICAgfHwgKCFwYXlsb2FkIHx8ICFwYXlsb2FkLnBhcmFtcyB8fCAhT2JqZWN0LmtleXMocGF5bG9hZC5wYXJhbXMpLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgdG90YWwgPSAocGF5bG9hZC5wYXJhbXMub2Zmc2V0IHx8IDApICsgaXRlbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLnRhYmxlKCdtZXRhJykucHV0KHsgbGFzdFJlYWQ6IG5ldyBEYXRlKCkudmFsdWVPZigpLCB0b3RhbCB9LCAndG90YWwnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoW2FyZ3NdKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCdbUGlwQ2FjaGVdIFNFVCBjb2xsZWN0aW9uIG9mIGl0ZW1zJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUGFyYW1zOiAnLCBwYXlsb2FkLnBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSXRlbXM6ICcsIGl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHJlYWQgYXQ6ICcsIG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTmV3IHRvdGFsOiAnLCB0b3RhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZGVsZXRlSXRlbXMobW9kZWxOYW1lOiBzdHJpbmcsIGtleXM6IGFueVtdKTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuZ2V0TW9kZWwobW9kZWxOYW1lKTtcclxuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZ2V0RGIobW9kZWwpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsS2V5ID0gbW9kZWwub3B0aW9ucy5rZXkgfHwgJ2lkJztcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICBkYi50YWJsZSgnbGFzdFJlYWQnKS5idWxrRGVsZXRlKGtleXMpLFxyXG4gICAgICAgICAgICBkYi50YWJsZSgnaXRlbXMnKS5idWxrRGVsZXRlKGtleXMpLFxyXG4gICAgICAgICAgICBkYi50YWJsZSgnaW5kZXhlcycpLndoZXJlKG1vZGVsS2V5KS5hbnlPZihrZXlzKS5kZWxldGUoKSxcclxuICAgICAgICAgICAgZGIudGFibGUoJ21ldGEnKS5kZWxldGUoJ3RvdGFsJylcclxuICAgICAgICBdKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJ1tQaXBDYWNoZV0gREVMRVRFJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnS2V5czogJywga2V5cyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNsZWFyKG1vZGVsPzogc3RyaW5nIHwgc3RyaW5nW10pOiBQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGJzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAobW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobW9kZWwpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBkYnMucHVzaCguLi5tb2RlbC5tYXAobSA9PiB0aGlzLmdldERiTmFtZShtKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBkYnMucHVzaCh0aGlzLmdldERiTmFtZShtb2RlbCkpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYnMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShEZXhpZS5EZXhpZS5nZXREYXRhYmFzZU5hbWVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkudGhlbigobmFtZXM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRicyA9IG5hbWVzLmZpbHRlcihuYW1lID0+IG5hbWUuc3RhcnRzV2l0aCh0aGlzLmNvbmZpZy5wcmVmaXgpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkYXRhYmFzZXMgdG8gZGVsZXRlOiAnLCBuYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGRicykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IHRoaXMub3BlbmVkRGJzLmhhcyhuYW1lKSA/IHRoaXMub3BlbmVkRGJzLmdldChuYW1lKSA6IG5ldyBEZXhpZS5EZXhpZShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLnRhYmxlKCdpdGVtcycpLmNsZWFyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGIudGFibGUoJ21ldGEnKS5jbGVhcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLnRhYmxlKCdsYXN0UmVhZCcpLmNsZWFyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGIudGFibGUoJ2luZGV4ZXMnKS5jbGVhcigpKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3Igb3BlbmluZyBkYXRhYmFzZSAnICsgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfSkudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVjJXMnLCAnY29sb3I6IGJsdWU7IGZvbnQ6IDEuMnJlbSBJbXBhY3Q7JywgJ1tQaXBDYWNoZV0gQ0xFQVInKTtcclxuICAgICAgICAgICAgICAgIGlmIChtb2RlbCkgeyBjb25zb2xlLmxvZygnTW9kZWwocyk6ICcsIG1vZGVsKTsgfSBlbHNlIHsgY29uc29sZS5sb2coJ2FsbCBtb2RlbHMnKTsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQ2FjaGVQcm92aWRlciB7XHJcbiAgICBtb2RlbHM6IENhY2hlTW9kZWxbXTtcclxuICAgIHJlZ2lzdGVyTW9kZWwobW9kZWw6IENhY2hlTW9kZWwpOiBib29sZWFuO1xyXG59XHJcblxyXG5jbGFzcyBDYWNoZVByb3ZpZGVyIGltcGxlbWVudHMgSUNhY2hlUHJvdmlkZXIge1xyXG5cclxuICAgIHByaXZhdGUgX3NlcnZpY2U6IElDYWNoZVNlcnZpY2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBwaXBDYWNoZUNvbmZpZ1Byb3ZpZGVyOiBJQ2FjaGVDb25maWdQcm92aWRlcikge1xyXG4gICAgICAgIFwibmdJbmplY3RcIjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG1vZGVscygpOiBDYWNoZU1vZGVsW10geyByZXR1cm4gdGhpcy5waXBDYWNoZUNvbmZpZ1Byb3ZpZGVyLm1vZGVsczsgfVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3Rlck1vZGVsKG1vZGVsOiBDYWNoZU1vZGVsKSB7XHJcbiAgICAgICAgaWYgKCFtb2RlbCkgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLm1vZGVscy5maW5kKG0gPT4gbS5uYW1lID09PSBtb2RlbC5uYW1lKTtcclxuICAgICAgICBpZiAocmVzKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMubW9kZWxzLnB1c2gobW9kZWwpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZ2V0KCkge1xyXG4gICAgICAgIFwibmdJbmplY3RcIjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3NlcnZpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlID0gbmV3IENhY2hlU2VydmljZSh0aGlzLnBpcENhY2hlQ29uZmlnUHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2U7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5hbmd1bGFyXHJcbiAgICAubW9kdWxlKFwicGlwQ2FjaGVcIilcclxuICAgIC5wcm92aWRlcigncGlwQ2FjaGUnLCBDYWNoZVByb3ZpZGVyKTsiLCJhbmd1bGFyLm1vZHVsZSgncGlwQ2FjaGUnLCBbXSk7XHJcblxyXG5pbXBvcnQgJy4vY2FjaGUtY29uZmlnLnNlcnZpY2UnO1xyXG5pbXBvcnQgJy4vY2FjaGUuc2VydmljZSc7XHJcbmltcG9ydCAnLi9jYWNoZS5pbnRlcmNlcHRvcic7XHJcblxyXG5leHBvcnQgKiBmcm9tICcuL2NhY2hlLm1vZGVscyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vY2FjaGUtY29uZmlnLnNlcnZpY2UnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NhY2hlLnNlcnZpY2UnO1xyXG4iLCLvu79pbXBvcnQgJy4vY2FjaGUvaW5kZXgnO1xyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9jYWNoZS9pbmRleCc7XHJcbiJdfQ=="}